{"pages":[{"title":"tags","text":"","link":"/tags/index.html"}],"posts":[{"title":"Clean Code Summary","text":"Chapter 2 Meangingful Names Use Intention-Revealing Names: avoid nonsense naming Avoid Disinformation: using FULLNAME, avoid abbrevation accountList &gt; accounts &gt; List Make Meaningful Distinctions: ProductInfo and ProductData, Customer and CustomerObject has no difference at all! Use Pronounceable, Searchable Names: the length of a name should correspond to the size of its scope Interface and Implementtations: avoid passing IShapeFactory as interface, using ShapeFactoryImpl in implementation Class Name: Avoid using Manager, Processor, Info, Dataas class name, using noun or noun phrase word One Word Per Concept: Don’t use retrieve, fetchr, get all at same time! It’s horrible! Chapter 3 Functions Small!: Funtions should be very small Avoid nested structures and each block should be one line Function should do one thing can’t extract another function from it witha nmae that is not merely a restatement of its implementation Switch statements: using polymorphism with abstract factory pattern Common Monadic Forms Ask question about argument like boolean isFileExist(File file) Operating on argument, transforming it into something and return like InputStream fileOpen(File file) Interpret function call as event and use argument to alter state of system without output argument like void passwordAttemptFailedNtimes(int attempts) Try to avoid any other form besides those three above Dyadic Forms Sometime reasonable if it’s a natural cohesion or ordering like new Point(0, 0) or assertEquals(expected, actual) It itn’s evil, but it has cost and there always a way to at least convert it to Monadic, just depends on whether it worth or not Argument Objects Using wrapper to wrap into a class of their own see these two following declarations: 12Circle makeCircle(double x, double y, double radius);Circle makeCircle(Point center, double radius); Output Arguments Try not using output argument, if must change state of something, make it change inside it’s own Prefer Exception to Returning Error Codes Error code always force caller to deal with it immediately using using try-catch block, the code to deal with succeed or error will be separated extract try and catch block to its own method should be more clear Chapter 4 Comments Comment should be no need at all It’s always the compensate for failure to express in code Programmer always forget to maintain, which makes them misleading Save the energy to write better and clearer code Chapter 6 Objects and Data Structures Data Abstraction Expose abstract interfaces to allow user manipulate data without knowing its implementation Consider serious which data should be exposed Data/Object Anti-Symmetry Objects: Hide data behind abstractions and expose funtions that operate their data Data: Expose data and have no meaningful functions Procedural code: Easy to add new functions, hard to change data structure Object Oriented code Easy to add new classes, hard to add new functions Need to use both of them properly to make clean code, but not in one class (hybird is the worst!) Chapter 7 Error Handling Use Exceptions Rather Than Return Codes Error code needs to be returned every single case, make the code very complicated and cultter caller Separate detection logic with handle logic Define Exception Classes in Terms of Caller’s Needs Wrapping third-party API is a best practice, easy testing, easy migration and less dependencies Define your own exception type inside wrapper to make handling logic easier outside the wrapper(only one type outside) Null Handling Don’t Return Null: throw an exception or using Special Case Pattern Don’t Pass Null: never pass null in methods Chapter 8 Boundaries Using Third-Party Code Hide the interface inside a class that we can control Avoid when change comes, we need change everywhere Make a Wrapper or Adapter to hide thrid-party interface Learning Test / Boundary Test It’s free and can be used to learning thrid-party code It can be used to detect breaking changes Chapter 10 Classes Class Organization Public static constants Private static constants Public instance variables (if any) Private instance variables Public functions Private function should directly after their caller Class should be small The more ambiguous the class name, the more likely it has too many responsibilities Avoid weasel words like Manager, Processor or Super which will aggregate responsibilities Single Responsibility Principle A class or module should have one and only one reason to change Identity reason to change often helps for better abstraction of our code A system composed of many small , well-structured classes is always better than a few large, multipurpose classes Chapter 11 System (Need revisit in future) Separate Constructing a System from Use it System should not know or care about startup logic, it assume everything should be constructed correctly when start running Using Dynamic Factory pattern to hide the building logic and allow application to decide when and what to build during runtime Dependency Injection: a way to achieve IOC (Inversion of Control) principle: the responsibility of instantiating dependencies will delegate to another “authoritative” mechanism","link":"/2020/04/28/cleanCode/"},{"title":"Dependency Injection","text":"What is Dependency InjectionBefore answering this question, a better question to ask might be: What is dependencyTo answer this question, let’s take a look at this Kotlin code here: 12345678910111213class SimpleFeature constructor( val businessLogicDelegate: BusinessLogicDelegate, val validator: Validator, val listener: Listener) { fun doSomeThing() { val helper = Helper() if (validator.validate()) { businessLogicDelegate.doSomething(helper, listener) } }} This is a very common secenario in real life: I have a class and serveral parameters in its constructor, I need call some methods of those parameters inside this class. At the same time, I also need initialize a helper class inside and use it. In this case, both the parameters and helper class will be considered as the Dependency of SimplyFeature class. Cause this SimpleFeature needs “depend on“ something to finsh its own job. In another word, if any class’s method is called inside a class A, those class will be considered as A’s dependency. So now I know dependency, what is dependency injection?Let’s look back to this code again: 12345678910111213class SimpleFeature constructor( val businessLogicDelegate: BusinessLogicDelegate, val validator: Validator, val listener: Listener) { fun doSomeThing() { val helper = Helper() if (validator.validate()) { businessLogicDelegate.doSomething(helper, listener) } }} There are two main issues in this code block: Inside the doSomeThing(), we need to initialize a Helper class to help finishing business logic. This can work for sure, but if this helper needs to be a static class, or I need to using a Signleton helper class, here, how can I use it? When writing unit test with Mockito or Mockk, a common way is passing in a “mock“ instance and testing if the expected method of this mock is called with correct parameter. But how can we pass in the mock of Helper class if the new operator is called inside? To solve these problems, what can we do? Just simply pass a helper instance in the constructor so it can become the dependency of SimpleFeature as well! The constructor will look like this: 12345678910111213class SimpleFeature constructor( val businessLogicDelegate: BusinessLogicDelegate, val validator: Validator, val listener: Listener, val helper: Helper) { fun doSomeThing() { if (validator.validate()) { businessLogicDelegate.doSomething(helper, listener) } }} Now it looks great! I can pass in any Helper class and also mocking it and do the unit test! Nice! Now we can make a conclusion here: Dependency Injection means:Passing the dependency into the class and use it One thing need to mention here is: passing through class’s constructor is only one of the way to do DI. More details about this concept can be find here. How can I use dependencies injection?To use dependencies injection effectively, let me introduce this super-useful library here: This Dagger 2 library are powerful for android application dependency injection, by using this, all we need to do it’s define each class’s dependency list and the scope to use it. All other stuff will be handled by this library automatically and anonymously. So how to use it? First, we need to have a module class: 12345678910111213141516@Moduleinterface MainModule { @Binds fun providesBusinessLogicDelegate(businessLogicDelegateImpl: BusinessLogicDelegateImpl): BusinessLogicDelegate @Binds fun providesValidator(validatorImpl: ValidatorImpl): Validator @Binds fun providesListener(listenerImpl: ListenerImpl): Listener @Binds fun providesHelper(helperImpl: HelperImpl): Helper} What is this Module use for? Basically this is the place you want dagger helps you to initialize all your dependency. There are two ways to initial dependency in dagger, one is through @Bind annotation and another is @Provides. In here I’m using @Binds since it’s much simpler if all dependencies has implement an interface. Then we need another class which is called componenet class: 1234567@Component (modules = [MainModule::class])interface MainComponent { fun inject(activity: MainActivity) fun inject(feature: SimpleFeature)} Inside this Component, the inject() method defines “where those dependencies should be injected to”. And following the @Component annotation we can declare all modules that can be included, so we can inject multiple module’s dependencies inside one single class that called by inject() method. So far so good! After create these two classes above, we defined What is the dependency and Where should we inject into. Now the final step will be refactor our SimpleFeature class: 12345678910111213class SimpleFeature @Inject constructor( val businessLogicDelegate: BusinessLogicDelegate, val validator: Validator, val listener: Listener, val helper: Helper) { fun doSomeThing() { if (validator.validate()) { businessLogicDelegate.doSomething(helper, listener) } }} Since all parameters inside the constructor are initialized in module class and the injection of this feature class also declared in component class, the only change needed in here is add @Inject annotation before constructor, then dagger knows that all parameters can be find in module and injected by component magically. Done! Now enjoy inject any dependency you want! Now there are still some notes worth mention here: What we using here is just a very brief introduction of Dagger, it has a lot powerful methods and tools that worth to try and play with it. More detail should be found in here One of the very useful feature of Dagger is @Scope annotation. It can be used in complicated structured project to define different scope for different dependencies to access. This part will be added in future as a follow-up of our DI topic. The main purpose of DI is align with one of the basic SOLID principle in softwate development, which is know as Dependency Inversion Rules. This principle states: High-level Module should not depends on low-level module, both should depend on abstractions (interface); Abstractions should not depend on details. Details (concrete implementation) should depends on abstraction. We will cover all these principles one by one in future, they are very important in industrial software development world. Although there are tons of advantages in DI, but it has its limit or disadvantage for sure. For example, when dependency is missing, it’s hard to find out which dependency is missing by checking the build output. So at this time, log is very useful to check.","link":"/2020/02/28/Dependency%20Injection/"},{"title":"Clear Architecture - Programming Paradigms &amp; Design Principles","text":"Part II Starting with the Bricks: Programming ParadigmsStructured Programming: direct transfer of controlConstructed from sequence, selection and iteration to replace old goto keyword. A typical structured programming example: 123456789101112131415// sequence executionval sum = 0val current = 1// iterationwhile (current &lt; 10) { sum += current current += 1}// selectionif (needNegative) { return sum *= -1} else { return sum}return sum All programs can be constructed from just these three structures: sequence, selection and iteration. Object-Oriented Programming: indirect transfer of controlThrough the use of polymorphism to gain absolute control over every source code dependency in the system.To better understnad about power of polymorphism. also check Dependency Inversion Principle below. A typical object-oriented programming example: 123456789101112131415161718192021222324252627282930313233343536// define Vehicle interfaceinterface Vehicle { fun alarm() fun turnOn() fun turnOff()}// different brand of car, should all implement the same interfaceclass BMW: Vehicle { override fun alarm() { makrSound(\"di~di~\") } override fun turnOn() { ... } override fun turnOff() { ... }}// but they can have diffrent implementation (such as differnt alram sound)class Ford: Vehicle { override fun alarm() { makrSound(\"do~do~\") } override fun turnOn() { ... } override fun turnOff() { ... }}// when client code is using them, they don't need to know the implementation detailsFord().turnOn()BMW().ring() Any source code dependency, no matter where it is, can be inverted. Functional Programming: variable assignmentVariables in functional languages do not vary, which will causing none of race condition, deadlock or concurrent update problems. A typical functional programming example: 123456789class Person constructor ( private val name: String) { fun getName(): String { return name }}// define a function to get person's nameval personName = fun(person: Person) = person.getName Concurrent problems can be eliminated by segregate the application into mutable and immutable components. Part III Design PrinciplesSingle Responsibility Principle (SRP) A module should have one, and only one reason to change A common way to impose this principle is: Separate shared functional code blocks from specific logic. For example, here is a Employee class from payroll application: 1234567891011121314class Employee { private val employeeDB = EmployeeDatabase() fun getWorkingHours(): Int { return employeeDB.queryWorkingHours() } fun calculatePayroll(): Int { val workingHours = getWorkingHours() val salaryRatePerHour = employeeDB.querySalaryRatePerHour() return workingHours * salaryRatePerHour } fun saveEmployee() { employeeDB.updateEmpployee(this) }} It’s clear that this Employee class has too many responsibilities including query working hour, query salary rate, calculate payroll, update employee info etc. And typical problem can be: It’s hard to extends, when introduce different ways to calculate payroll for example; Who wants to change ONLY working hours fetching may also touch payroll calculation accidentally; EmployeeDatabase is exposed to Employee class, which is dangerous for open visibility. To solve these issues, we can do: 1234567891011121314class Employee { private val hourReporter = HourReporter() private val payCalculator = PayCalculator() private val employeeSaver = EmployeeSaver() fun getWorkingHours(): Int { return hourReporter.reportHours() } fun calculatePayroll(): Int { return payCalculator.calculatePay() } fun saveEmployee() { employeeSaver.saveEmpployee(this) }} As we can see, after we create HourReporter, PayCalculator and EmployeeSaver, we separate different responsibilities to different class so: if we want to have diffrent ways to calculate payroll, it can be updated inside PayCalculator and no need to update Employee class; when working hours fetching need to change, no need to touch payroll calculation logic; no more database expose to Employee class since it’s handled by these three classes internally. Open-Closed Principle (OCP) A software artifact should be open for extension but closed for modification. This is a common case that sometimes we want to extends part of our code and extends without having to modify that artifact. To make this possible, we need to implement component hierarchy structure so code change in lower level component will not effect higher level component. In other word, higher level component is being protected from code change chain. Let’s continue on the Employee example: 1234567891011121314class Employee { private val hourReporter = HourReporter() private val payCalculator = PayCalculator() private val employeeSaver = EmployeeSaver() fun getWorkingHours(): Int { return hourReporter.reportHours() } fun calculatePayroll(): Int { return payCalculator.calculatePay() } fun saveEmployee() { employeeSaver.saveEmpployee(this) }} It’s easy to understand that HourReporter, PayCalculator, EmployeeSaver classes has higher prority then Employee class and we want to avoid code change on them when we need change Employee class. The UML of structure is like: Note that an arrow pointing from class A (Employee) to class B(HourReporter, PayCalculator, EmployeeSaver) means: the source code of class A mentionas the name of class B, but class B mentions nothing about class A. In this XML, Employee depends on these three classes, so those three classes is protected from changes in Employee. Liskov Substitution Principle (LSP) Subclass should be substitutable for their base class A typical example of this principle is square/rectangle problem, let’s briefly recall the problem first by UML: As common sense, a Square should be treated as a special Rectangle which means all operations or parameters for a rectangle object should also effect on a square object. Let’s see the code block below: 1234val rectangle = Rectangle()rectangle.setWidth(2)rectangle.setHeight(5)assert(rectangle.getArea() == 10) This should work fine and the assertion should pass as well, but when we do the same thing to a Square like: 1234val square= Square()square.setSide(2) // how can width and height change at same time???square.setSide(5)assert(rectangle.getArea() == 10) // this will failed and area will be 25 The core problem behind this case is : square has a feature which rectangle don't: need set both width and height always at same time with same value, they can't be changed separately. It may causing a lot problems becuase of this. Interface Segregation Principle (ISP) No client should be forced to implement methods it doesn’t use When we play with abstract interfaces and implementation, a common problem is we find there are extra methods that the implementation not used at all. The easiest way to handle it is just override it and make it empty. But by doing this, there is a risk that it might be touched by other maintainers or even yourself in future since you may not remember. A good fix on this should be separate it into multiple specific interfaces like: In my opinion this is a good way to minimum the risk and separate interface for different class if they not use all of them, but also note that this might causing a lot interfaces to be generated, this is the trade-off. Dependency Inversion Principle (DIP) High-level module shouldn’t depend on low-level, but both should only depend on abstraction, not on concretions This is the most information principle in my opinion and also the hardest one to understand. To understand this, first question is: what is abstraction and why we need it? To answer this, let’s see this example UML: This is the concrete implementation for an application with a simple service. Service is created by ServiceFactory by calling serviceFactory.createService(). It works fine but it has several problems: Application can access everthing inside Service and ServiceFactory, it including something they don’t use (violation of ISP); Both Service and ServiceFactory are dependencies of Application, which means when their code changed, Application will need to re-comple and re-generated everytime (violation of OCP); If we want to add new type of service in future, both Application and ServiceFactory need change the code and still hard to extends (violation of OCP again). So according to what we learned before, here is a better solution for all three points above: As you can see in the solution UML, we make both ServiceFactory and Service as Interface and give them implemnentations for each interface. Note that implementation is hided from Application so it only communicate with interfaces. Why? Look back into all three problems above and you will find all of them is successfully solved by using Interface! Now let’s understand the description of this principle with the example: consider Application as low-level module and ServiceFactory, Service as high-level module, Application should not depends on ServiceFactory and Service because of the violation of ISP, OCP and DIP, and they should all depends on the abstraction, which is Interface in this case. And by using interface, the control flow is successfully inverted from Application -&gt; ServiceFactory to ServiceFactoryImpl -&gt; Application, same for Service as well. This is how Inversion come from.","link":"/2020/05/11/clearArchitecture_1/"},{"title":"clearArchitecture - Desgin Principles &amp; Component Principles","text":"Part III Desgin Principles","link":"/2020/06/06/clearArchitecture_2/"}],"tags":[{"name":"Clean Code","slug":"Clean-Code","link":"/tags/Clean-Code/"},{"name":"Android","slug":"Android","link":"/tags/Android/"},{"name":"Clean Architecture","slug":"Clean-Architecture","link":"/tags/Clean-Architecture/"}],"categories":[]}