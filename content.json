{"pages":[{"title":"your name","text":"导语 正文 参考文章链接link","link":"/template.html"},{"title":"categories","text":"","link":"/categories/index.html"},{"title":"tags","text":"","link":"/tags/index.html"}],"posts":[{"title":"Android Architecture(MVC, MVP and MVVM)","text":"To make our Android application easy to extend, modify, refactor, test or even just read it, the architecture of the application is very important. For sure we can’t have a single class MainApplication or MainActivity and put everything inside, it will be a nightmare to just read the code and understand. There are three main architectures to use in Android to build our application and gives us power to do all operations we mentioned above: Model-View-Controller(MVC), Model-View-PResenter(MVP) and Model-View-VIewModel(MVVM). Let’s talk about them one by one. MVC Model contains all data models and states inside, it also has business logic as well; View responsible for rendering UI and it contains everything that interact with user like Views/Layouts; Controller is like a bridge in between, it handles the communication between model and view to finish the workflow. A normal MVC workflow looks like this: Pros Decoupling View and Model, Model itself is easy to test Faster development process Cons Controller contains a lot of code, which makes it hard to extends and modify Controller usually is Fragment/Activity and it’s hard to do unit test Model is hard to change and maintain when View changes frequently (change from View is hard to adapt) MVP Model contains all data models and states inside, it also has business logic as well (same as MVC); View responsible for rendering UI and it contains an implementation of View interface which will be used by presenter; Presenter contains the View interface and communicate to View through interface methods call, it also communicate to Model same as MVC. MVP workflow is like: Pros Presenter and View communicate through View Interface which makes Presenter easy to test Model and View totally decoupled, View can be modified without change Model Presenter is easy to extends, modify and reuse View has only pure dumb UI functions and it’s easy to swap different views Cons Presenter and View still tightly coupling Code size is excessive and need create lots of View Interface for each MVP sturcture MVVM Model is same as MVC/MVP architecture; View is same as MVP architecture, but normally it is a XML file or DataBinding; ViewModel has same responsible as MVP architecture, but by using Observable and DataBinding, it can update view without knowing what it will do (decoupling from View). MVVM workflow shown like: Pros View and ViewModel is loosely coupling through DataBinding Easy to test ViewModel and higher code coverage (XML file no need to test at all) Cons Sometimes for complex UI, XML file can be very large and complicated Code size is still quite excessive Compare and diffIn conclusion, here is a comparsion chart of all these three architectures: Reference linkCommon Android Architecture MVC vs MVP vs MVVM Architecture in Android","link":"/2021/01/15/AndroidArchitecture/"},{"title":"Android开发笔记（一）- 四大组件简介","text":"因为最近开始系统地学习Android开发，所以在这里记录一下所学到的Android内容做一个整理。既算是对已学到知识的总结和梳理，也可以检查自己理解中出现的问题，和大家共同讨论一下。因为是第一次写东西，所以有什么不详细，不清楚，不准确的地方，还希望可以指正，我们共同讨论，共同进步。 本篇文章大部分的内容都是基于自己通过Google官方说明文档，StackoverFlow, CSDN等网站的阅读获得的，希望通过我个人的理解，让这些知识更容易被读者所理解和接受。 Application Structure进入Andorid的第一个需要理解的知识，也是我个人认为最为重要的基础知识之一，就是了解Android application的架构。构成一个完整安卓APP的，是各种各样不同的Component（组件），这些Component分别承担着不同的工作和职责，比如负责与用户进行交互的Activity，负责后台相关工作的Service，负责监听传递信息的BoardcastReceiver， 以及存储读取数据的ContentProvider等等。 我们用一个简单的例子来解释一下：如果说现在需要做一个负责计算汇率转换的Android应用，那么其对应的组件功能分别为： 首先要实现汇率转换的功能，我们就需要一个让用户输入金额大小，选择转换货币类别的界面，这就是CurrencyConvertActivity，在其中定义了一切UI与用户进行交互的逻辑； 接着我们想在后台服务器实时获取当前的汇率数据信息，那么就需要一个BoardcastReceiver来随时向服务器发送请求获取当前最新的汇率信息并传送给CurrencyConvertActivity，用来计算金额； 如果我们想在App启动时根据系统中用户设定的当前国家来显示对应的国家货币，并且在用户切换国家/时区时在APP内进行实时更新，就需要建立一个CountryChangeReceiver来监听TIMEZONE_CHANGED系统事件并在监听到切换国家/时区时进行识别； 如果我们想将实时获得的汇率进行缓存，以便在网络环境恶劣的情况下获得最近一次实时汇率表，那么就可以使用ExchangeRateContentProvider将汇率数据进行保存和处理 现在整个Application的架构大致就是这样: 123456789101112131415161718192021222324252627282930313233&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; package=&quot;com.yunze.myapplication&quot;&gt; &lt;application android:allowBackup=&quot;true&quot; android:icon=&quot;@mipmap/ic_launcher&quot; android:label=&quot;@string/app_name&quot; android:roundIcon=&quot;@mipmap/ic_launcher_round&quot; android:supportsRtl=&quot;true&quot; android:theme=&quot;@style/AppTheme&quot;&gt; &lt;activity android:name=&quot;com.yunze.myapplication.CurrencyActivity&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt; &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;service android:name=&quot;.BackendService&quot;&gt; &lt;intent-filter /&gt; &lt;/service&gt; &lt;receiver android:name=&quot;.CountryChangeReceiver&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.TIMEZONE_CHANGED&quot; /&gt; &lt;/intent-filter&gt; &lt;/receiver&gt; &lt;provider android:name=&quot;.ExchangeRateContentProvider&quot; android:authorities=&quot;.ExchangeRateDB&quot;&gt; &lt;/provider&gt; &lt;/application&gt;&lt;/manifest&gt; 上面显示的这个AndroidManifest.xml，可以理解为一个Android Application的“骨架”。正如我们之前所说，Activity，Service，BroadcastReceiver和ContentProvider可以算是Android Application的四大“组件”。而AndroidManifest.xml文件则正是申明这个App所使用的所有组件的地方，所以当我们开始上手一个新的安卓项目时，应该要从AndroidManifest.xml开始看起，才能比较详尽全面地了解这个App。 Android Components下面具体来比较一下不同的组件之间的关系，让我们有更进一步的了解。 Activity：整个Android开发中最为重要的一个概念。Acitivity中定义了App与用户的交互逻辑，例如当用户点击当前这个按钮，应该发生什么事，是显示一个文本框，更改图片的颜色，或者关闭当前界面回到上一个界面等等。可以说：所有关于用户交互的逻辑全部都只能定义和存在与Activity之中。 Service：如果我们的APP中需要一个长时间运行在后台来处理业务的功能，比如频繁向服务器发送请求，或者需要等待服务器随时返回请求，或者要长时间从服务器加载大型文件（比如在线浏览视频），此时就需要用到我们的Service组件。Service组件最重要的特征就是：可以长时间的运行在后台进行服务，直到完成任务后将自己结束，并且其中不能定义任何与用户UI有关的内容。 BroadcastReceiver: 这可能是四个组件中比较不好理解的一个，其实可以把它想象成APP的一根“天线”，它的功能就是主动接受其他APP传来的特定“信号”。比如我们之前说的TIMEZONE_CHANGED这个event，当安卓系统检测到用户手机切换了时区时，就会向整个系统内广播这个TIMEZONE_CHANGED event，此时如果我们的APP中含有一个注册了TIMEZONE_CHANGED的BroadcastReceiver，那么这个receiver就会被触发并完成一系列我们定义好的逻辑。 ContentProvider：这个组件一般为存储和获取数据提供统一的接口，可以在不同的应用程序之间共享数据。通过这个接口，其他应用看不到数据是如何存储的, 但通过ContentResolver可以对其进行包括：添加(insert), 删除(delete), 获取(query), 修改(update) &amp; 返回MIME类型(getType)等一系列的操作。在这个组件中，所有文件都是通过URI来识别，结构为: content://授权信息/表名/记录。 这里要稍微说一下BroadcastReceiver与Service的区别，它们都是运行在后台，不带有任何UI的组件。但是Service作为消息的接收方是只能被单独触发的，而不同的BoardcastReceiver却是可以被一起触发的，前提就是它们都注册了同一个event。下面是在看他人的总结介绍时看到的一张很有意思的图： 从这张图上来看，有几点值得我们特别注意的： 只有Activity才可以启动一个新的Activity（理论上讲其实是有其他办法可以从Service和BoardcastReceiver中启动的，但是这里说的不是“能不能”，而是“是否应该”），当我们创建一个新的Android项目时，都会自动生成一个MainActivity，所有关于APP的行为和逻辑都应该在这个或者几个Activity内来完成，项目也会有一个Application类，这个类一般是作为各种Activity的容器来使用，不要轻易将代码逻辑写在Application里；而启动新的Activity的方式就是在StartActivity()方法中传递一个Intent类，这个下面会讲到。 只有Activity才可以Layout Inflation。这个也比较好理解，因为前面说过，只有Activity才能处理和用户的交互，显示所有的UI和Layout（其实所有的UI都只能run在UI Thread，也就是Main Thread上，而只有Activity可以access到Main Thread，所以当然只有它可以处理UI的部分）。当然也是有Tricky way来做的，比如call runOnUiThread()之类的，之后等到写multi-thread的时候会涉及这部分。 Broadcast Receiver所监听的Event一般来说是向全系统广播的一些事件，比如手机连接好了WIFI，手机外接了电源等等。当然也可以监听自定义的event，但是根据我们前面说的用途，自定义的情况比较少，毕竟没有必要只向自己的一个service或者activity进行广播。 Communication between Components下面我们来了解一下各组件间的通信方式，所谓“通信”，其实就是指：1. 从一个组件向另一个组件传递参数；2. 从一个组件生成另一个新组件。传递参数的方式有很多，但是生成组件的方式却很有限： Activity启动一个新的Activity的方式主要就是通过 startActivity() 或startActivityForResult() 方法并传递一个Intent实例。这两个方法的主要区别在于是否需要从新的activity返回一个结果，比如通过新的activity选择一张本地存储的图片，或者通过新的activity确定一个文件是否已经发送完毕等等。Intent中包含了新的Activity的类名以及一些初始化需要的数据(Extra)。 通过putExtra()方法可以将这些数据传入Intent，从而传递给新的Activity。 Service启动一个Service的方法大致有三种： 直接开启：通过startService()方法并传递一个Intent实例，这个方法和Activity基本一致； 绑定开启：通过bindService()方法并传递一个Intent实例，绑定开启与直接开启的一个最大的区别就是：绑定开启的service会在开启它的组件生命周期结束时随之结束，而直接开启则不会。实际上，直接开启的service会一直运行，直到stopService()被执行，或者App被卸载。 JobScheduler调度：在Android 5.0+中，可以通过JobScheduler中的schedule()方法来启动一个service，这个方式目前我还没有用到过，以后如果涉及到再单独写一篇吧。 BroadcastReceiver启动BroadcastReceiver的方式和Activity基本一致，区别在于可使用的方法更多，其中包括：sendBroadCast()，sendOrderedBroadcast()以及sendStickyBroadcast()，也都需要传递Intent实例到各个方法中。Broadcast有一个不同点在于静态注册/动态注册，之后会专门写一篇讲它。 ContentProvider这个组件和其他组件不同，因为它只是一个接口，所以其不需要进行启动或者初始化。而使用ContentProvider的一般步骤包括： 创建一个实现ContentProvider接口的类，并实现接口中的各个方法（insert()， delete()， query()等）; 在AndroidManifest.xml中进行注册； 通过getContentResolver().query(URI)方法就可以直接获得定义的ContentProvider中的数据。 参考链接Application Fundamentals - Google Android 官方说明文档","link":"/2020/06/10/AndroidBasic1/"},{"title":"Android开发笔记（二）- UI组件（Activity，Fragment, Dialog）","text":"之前的Android开发笔记之基础篇(一)中主要讲到了一些关于Android Components的基本概念以及它们的异同。今天就来讲解一下关于Activity中涉及UI部分的三个核心组件：Activity，Fragment和Dialog。它们基本承担起了APP中所有的图形界面和交互逻辑，也是面向用户最直观的展现。 Activity前面我们说到过，在Activity中定义了与用户交互的所有逻辑（Presentation Layer Logic）。举个例子，我们想做一个电话本App，那么就需要设计当用户点击某个按钮时，其背后发生的一切逻辑，而这些定义都包含在Activity中。那么，一个Application中可以包含多个Activity么？答案当然是可以的，而且是几乎必须的！想象一下在这个Application中可能会出现的界面包括： 基本的浏览电话本页面（DashboardActivity），显示一个联系人的列表； 当选中一个电话时，要显示一个详细联系人的页面（ContactActivity）； 点击电话号码时，弹出一个拨打电话的界面(DialingActivity)； Dashboard里要有一个“编辑”按钮，点击后弹出一个新建联系人界面（NewContactActivity） 可以看出，这每一个单独的界面，都是一个专门的Activity。也正是因为一个APP中有多个Activity的存在，才使整个安卓App的架构变得更加清晰，也更有利于我们阅读，重构以及debug。 对于一个Activity来说，可以采用多种不同的设计模式（Design Pattern）比如MVC，MVVM以及MVP。这其中我个人非常喜欢MVP（Model-View-Presenter）来设计代码。对于不同的Activity，出于解耦（De-coupling）的考虑，通常将它们放入不同的package中，方便区分以及日后对它们分别进行重构。像如上我们举例的电话App，它的结构大致就是这样： 在上一次我们说到，AndroidManifest这个文件里定义了所有App所需要的Activity，Service，BoardcastReceiver, ContentProvider等等，所以不要忘记在创建完Activity之后，一定要在Manifest里面把它声明好。 Activity Lifecycle关于生命周期（Lifecycle），我们只需要知道它定义了一个组件什么时候被初始化，什么时候对应什么状态，以及应该在何时进行何种操作即可。Activity的生命周期如下图所示： 让我们来一步步说明一下各生命周期方法的作用： onCreate()：必须实现，主要用于初始化activity以及设定各种参数； onRestart()：onStop()后如果没有被kill，会从这里唤醒，早于onStart()； onStart()：系统正在启动，UI已显示，但无法交互； onResume()：UI已显示，用户可以进行交互，而如果在Acitivity内部初始化其他Dialog或Fragment时，不论activity是否全屏，它都会保持在此状态； onPause()：最好在此释放CPU，保存数据； onStop()：activity完全从前台结束，看不见时进入此状态； onDestory()：activity被完全销毁，可以做回收和最终释放。 另外值得注意的一点就是：当设备进行横竖屏切换时：acitivity会销毁并重新初始化。如不销毁，需在manifest对应的activity内部声明configChange=“orientation | screenSize”, 此时onConfigurationChanged()会被call。 Fragment在说完Activity之后，下面我们要说一下Fragment这个重要的component。在各种Android的档案定义里，都会反复出现对于Fragment的定义：A Fragment represents a behavior or a portion of user interface in a FragmentActivity. You can combine multiple fragments in a single activity to build a multi-pane UI and reuse a fragment in multiple activities. 但是我一直就觉得这个解释非常不明确，为什么我们需要用Fragment呢？我个人的理解是：当在一个Activity内有多个单独显示的页面，并且每个页面与用户交互的逻辑都各不相同时，Fragment可以帮助我们减少很多麻烦，将整个Activity的架构变得十分清晰。这是我认为Fragment最为有用的一点。 还是以前面的电话本App为例，在拨打电话的界面DialingActivity中，可能会分为三个阶段： 接收到来电（InComingCall） 电话被接通（Calling） 通话结束（CallEnded） 根据需求不同，这三个阶段的界面可能会有完全不同的UI布局，每个按钮也可能会有不同的功能，但是它们同属于一个打电话的功能之中（DialingActivity）。此时如果我们使用三个不同的Activity，当然是可以的，这不仅意味着我们需要在各个activity之间传递各种各样的参数，而且处理不同Activity之间的沟通会变得十分麻烦，也不利于我们之后对于代码的维护。 此时就轮到Fragment出场了，我们可以在DialingActivity里定义三个Fragment：InComingCallFragment，CallingFragment以及CallEndedFragment，每个Fragment都可以有自己的model和presenter（MVP pattern）而在DialingActivity里，我们可以定义三个Fragment的共同行为逻辑。通过这种方式，可以使整个Activity结构清晰，分工明确，它的结构大概是这样： Activity和Fragment都是关于UI部分的重要组件。一般来说对于一个比较成熟的App来说，其包含的Activity和Fragment可能是成百上千的，所以熟练掌握它们的使用方法是极为重要的。 Fragment LifecycleFragment的生命周期相比于Activity要简单不少，下面分别简单介绍一下各生命周期方法下的作用： onAttach(Context context)：与调用的Activity发生联系，可以通过getActivity()获取调用它的Activity实例； onCreate(Bundle savedInstanceState)：从bundle中获取从Acitivity传来的数据，可用于初始化； onCreateView(LayoutInflater, ViewGroup, Bundle)：创建视图，inflater用于装载局部文件，viewGroup是父标签对象； onViewCreated(View, Bundle)：此时View创建完成，但还没有显示， View就是之前创建的对象； onActivityCreated(Bundle)：窗口初始化已完成，可以通过findViewById()来找到Activity中的view； onStart()：此时UI已经显示在屏幕上，但无法交互； onResume()：可以与用户开始进行交互了； onPause()：可以保存一些临时性的暂定工作，比如播放器的保存音乐播放进度，以便在OnResume里恢复； onStop()：fragment从屏幕上消失； onDestroyView()：移除所有视图，所有在onCreateView中的视图都将被移除； onDestroy()：此时Activity还是和Fragment保持联系的，可以获得Fragment对象，无法进行任何操作； onDetach()：最后一步,执行过后Activity与Fragment不再有任何关联。 此外，关于Fragment生命周期还有几点值得说明： Fragment的引入，主要是为了在大屏幕上显示更加灵活的界面设计，比如在平板电脑上，可以同时并排显示两个Fragment； Fragment必须始终托管在 Activity 中，其生命周期直接受宿主 Activity 生命周期的影响，当Activity暂停时，其所有Fragmenty也会暂停，Activity被销毁时，其所有Fragment也会被销毁。 Dialog相比于Activity和Fragment，Dialog就简单一些。Dialog主要应用于一些临时的对话框，比如向用户询问是否允许开启一些权限AlertDialog，让用户选择一个时间TimePickerDialog，或者自定义界面进行选择DialogFragment。初始化一个简单的Dialog的语法是： 123456789101112131415// 使用Builder class来定义AlertDialog的属性val builder = AlertDialog.Builder(this)builder.setMessage(R.string.your_dialog_message) .setPositiveButton( R.string.ok, DialogInterface.OnClickListener { dialog, id -&gt; // 定义用户按下OK按钮后的行为 }) .setNegativeButton( R.string.cancel, DialogInterface.OnClickListener { dialog, id -&gt; // 定义用户按下CANCEL按钮后的行为 })// 创建一个AlertDIalog实例builder.create() 上面的代码会创建出一个带有两个按钮的对话框，并且根据用户的选择来运行相对应的逻辑。 Dialog LifecycleDialog由于其特殊性，并不存在复杂的生命周期，它在初始化之后显示在用户界面上，随着用户的交互获得结果后被销毁。唯一的例外就是DialogFragment，因为它是Fragment的子类，所以其生命周期遵从于其父类Fragment，这里也就不再赘述了。 参考链接Activity - Google Android 官方说明文档 Fragment - Google Android 官方说明文档 Dialog - Google Android 官方说明文档","link":"/2020/06/16/AndroidBasic2/"},{"title":"Android开发笔记（三）- Multi-thread","text":"今天的内容是这周工作中出现的一个相关内容的学习：多线程（Multi-thread）。多线程可以极大地减少程序在并发执行时所付出的时空开销，提高操作系统的并发性能。在Android的开发中，多线程是非常重要的一环，而相信很多人也在面试中被问到过不止一次进程（Process）与线程（Thread）的区别。那么我们就来看看和Android相关的多线程组件Process，Thread，Looper，Handler各自的概念和实例。 Process vs Thread进程（Process）是多线程的第一个概念。简单来说，进程是指计算机中已经运行的程序，而对于安卓系统，一般一个Android应用程序就是一个进程，其中包含多个线程协同工作。 线程（Thread）是一种轻量级的子进程，是一个基本的CPU执行单元 &amp; 程序执行流的最小单元，也是独立运行和独立调度的基本单位。在Android的环境里，一个线程可以理解为一群任务的有序集合，所有线程共享进程所拥有的系统资源和存储资源，各线程之间通信快速高效。当这个线程的任务全部执行结束时，线程就会被终止。 Android Multi-threadAndroid系统中的线程分为两类：主线程（Main Thread）和其他子线程。 主线程也叫UI线程，在Android APP启动时会自动生成，主要负责处理Android四大组件（可以看这篇中关于四大组件的介绍）与用户进行交互的事件响应与逻辑，所以也叫主线程也叫UI线程。要注意的是，因为用户随时会与界面发生交互，因此主线程任何时候都必须保持很高的响应速度，所以主线程不允许进行耗时操作，否则会出现ANR（ApplicationNotResponding）异常。 子线程就是APP的工作线程，子线程都是APP运行过程中手动创建的线程，可以在其中处理一些耗时的操作例如网络请求、I/O操作等。可以通过使用RxJava等函数库来创建用于不同操作的特定子线程。 在Android官方声明中，对于多线程编程时有两大原则： 不要阻塞UI线程（即主线程）：主线程被阻塞超过5s则会出现ANR错误； 不要在UI线程之外更新UI组件。 那么现在我们来看看如何在代码中创建一个子线程吧。代码如下： 123456789package com.example.yunzeli.testapplicationpublic class MyWorkingThread extends Thread { private boolean isRunning; @Override public void run() { // 开始线程的工作 }} 可以看到，我们真正需要做的，就是继承Thread这个类，并实现run()方法。将我们需要做的工作在run()里完成即可，这个方法简单方便，但是却有一个问题：上面我们说过，当这个线程的任务全部执行结束时，线程就会被终止，那么如果我们需要在工作线程完成当前工作后不被中止，而是继续等待新的任务到来呢？那么就可以这样： 123456789101112131415package com.example.yunzeli.testapplicationpublic class MyWorkingThread extends Thread { private boolean isRunning; @Override public void run() { isRunning = ture; while (isRunning) { // 开始线程的工作 // 线程的工作完成后 isRunning = false; } }} 上面的代码中，我们通过设置一个isRunning的flag，可以用循环的方式来block住这个线程，然后等待新的任务到来。很好，现在我们有了一个独立运行的，随时可以使用的工作线程。但事实上，Java代码库里给我们提供了一个更加简单清晰，并且可靠的类，这就是Looper。 Looper从上面的内容我们知道，要想将一个线程block住，我们需要用looping将其不断循环并等待新的任务。在Android的开发包里，就有一个设计好的Looper类供我们使用。这个Looper一直在不停的循环并监听新来的task，每个Looper都有一个messageQueue用来存放分配的task，也叫做Message。Looper的使用有两个基本原则： 每一个Thread有且只能有一个Looper； 当想让某一个Thread执行某个任务时，就将message传送给对应Looper的messageQueue。 Looper在thread的具体使用方法如下： 12345678910111213141516package com.example.yunzeli.testapplicationimport android.os.Looperpublic class MyLooperThread extends Thread { @Override public void run() { // prepare the loop Looper.prepare(); // start looping Looper.loop(); // do your staff here... }} Looper.prepare()：检查当前这个thread是否已经分配好looper，如果没有，则新建一个looper来监听这个thread； Looper.loop()：looper开始监听当前线程，开始处理收到的message； 简而言之，Looper的作用就是一直looping and keep thread alive。值得注意的是，Main Thread也就是UI线程，是已经初始化了MainLooper的。所以不需要对于Main Thread进行任何的操作，Android系统已经帮我们都处理好了。 MessageQueue &amp; Handler说完了Looper，现在我们来说说Looper里面的一个重要概念：MessageQueue。当我们想向一个thread里派送一个新的task时，Java规定了我们只能派送如下两种类型：Message和Runnable。那么，我们如何将这两种类型的实例派送到目标线程的messageQueue里呢？这里就用到了另一个重要概念：Handler。Handler的功能相当于一个装配器，它可以将任意继承了Message或者Runnable类的实例放入其监听的Looper的messageQueue里，例如： 12345678910111213141516171819202122232425262728293031323334353637383940public class MyLooperThread extends Thread { private static final int MSG_1 = 1; private static final int MSG_2 = 2; @Override public void run() { // prepare the loop Looper.prepare(); // start looping Looper.loop(); // send message here Handler handler = new MyHandler(); handler.obtainMessage(MSG_1).sendToTarget(); handler.post(new Runnable() { @Override public void run() { // do something here... } }); } class MyHandler extends Handler { @Override public void handleMessage(Message message) { // switch your message type here switch(message.what) { case MSG_1: // do something here... break; case MSG_2： // do something here... break; default: } } }} 由上面例子可见，Handler通过obtainMessage(Message msg)的方法来传送message实例，用post(Runnable runable)的方法来传送Runnable实例。那么，Handler如何知道所要传送的目标thread呢？Android官方文档里写的很清楚，Handler有两个默认的构造器（constructor），如果使用new Handler()的话，则当前线程就会成为创建的Handler的目标线程；而如果使用new Handler(Looper looper)的话，则传入的looper对应的线程就会作为创建的Handler的目标线程。总结一下，Hanlder的作用主要就是两点： 从任意thread中将message或者runnable传入其对应的looper的message queue中； 获取其对应looper的message queue中的下一个task（message或runnable）并执行对应的操作。 需要强调的一点是：虽然一个thread只能有一个对应的looper，但是一个looper却可以同时被多个Handler所引用（允许将同一个Looper传入多个Handler的构造器）以便指定给同一thread的不同handler分别处理不同的message或者runnable。这样的设计也方便了我们对于多个task的处理。 Message &amp; Runnable最后关于Message和Runnable再简单介绍一下： 当我们希望在一个thread里执行一段代码（task）时，Android OS 规定了这两种类型作为传入的参数。Message的使用方式在于：我们预先在Handler里定义好了如何处理这个MESSAGE_TYPE的逻辑，然后将对应的MESSAGE_TYPE传入。个人理解比较像是pre-define了一个处理逻辑，然后只需要传入对应message就可以trigger这个task；而Runnable是一个Interface，当我们传入时，则需要重写它的run()方法并将我们想执行的代码逻辑写在里面。 关于这两种方式的区别，个人认为主要取决于这段逻辑是否需要传入动态变化的参数：比如，如果是执行例如显示一个文本框并高亮这种固定的，静态的逻辑，那么message的方法是比较好的选择。但如果执行根据用户输入值来显示字体大小这种需要参数的逻辑，则runnable的方法或更好些。 总结这一篇只是对于Android多线程一个非常简单的介绍。希望通过我的简单介绍能让读者对于多线程有一个简单直观的认识。Android多线程还有着许多许多复杂的内容，以后会在碰到并解决之后，一一在这里介绍给大家的。让我们共同学习，共同进步，谢谢！ 参考文章：Understanding Android Core: Looper, Handler, and HandlerThread A journey on the Android Main Thread — PSVM Android Handler Internals Android多线程 Multithreading Interview Question","link":"/2020/06/22/AndroidBasic3/"},{"title":"Android开发笔记（四）- Layout布局","text":"在Android开发的大部分场景里，我们需要构建各种各样的UI界面用于与用户进行交互。很多UI设计看起来很简单也很清晰，但一旦开始上手设计，就会发现：设计师轻松画出的各个UI组件，它们的排列，间隔，对齐，大小，其实没有那么容易摆放正确。再加上对于安卓系统的手机，屏幕大小尺寸更是多种多样。这是我们就需要用到页面布局（UI Layout）这个工具。那么今天就来看看Android中关于页面布局的一些概念和知识。 四种常见的Android Layout布局在Android开发环境中，一个UI layout布局页面以xml文件的格式存于：你的工程路径/main/res/layout里面。xml文件的具体格式这里不再赘述，但是要具体对于不同种类的Layout稍微解释一下： LinearLayout第一种是LinearLayout，这种布局一般来说是最简单，直接，快速的一种，当新建一个layout布局文件时，Android Studio默认的布局文件即为这种LinearLayout。顾名思义，这种布局最适用于线性的UI呈现方式，比如如下的布局： 对于这种只需要横向(Horizontal)或纵向(Vertical)排列的布局，LinearLayout可以说是最适合不过的选择了，它减少了很多处理各部件之前位置关系的参数声明，只需按需调整当前部件和上一个部件之间的位置关系，直到完成布局即可。简单来说，LinearLayout就像堆积木，你只需要沿某一个方向不断堆砌你的subview，并给每个subview规定好边距等参数即可。但是需要注意的是：这种Layout类型不允许在同一层内堆多个subview。如果需要的话，要使用下面的RelativeLayout。 RelativeLayout第二种是RelativeLayout，这种布局的特点在于：各部件之间的位置关系主要靠定义与其同布局的其他部件(Sibling)的位置关系来决定。比如我们在定义下面这样一个页面： 类似如上的界面一般会出现在列表（List）中，对于这种布局我们希望view 1和view 3的左边界对齐，而view 2和view 3的右边界对齐。至于整体布局的高度我们并不是十分介意（一般这种布局会采用上滑显示更多的RecyclerListView，这个以后会继续讲到）。所以此时RelativeLayout就可以通过声明 android:layout_toLeftOf 以及 android:layout_toRightOf 来限制组件间位置关系，从而达到我们想要的效果。 RelativeLayout顾名思义，在定义同一个subview内的不同组件间相对位置关系时非常有效。但在使用时需要处理好相对位置关系间的冲突，一般需要花费一些时间用于调整相对的位置关系。这种布局的使用方法在面对稍微复杂一点的UI界面时相比LinearLayout更灵活，更高效。 FrameLayout第三种是FrameLayout，这种布局一般应用于多层嵌套的视图布局。其实上面介绍的两种视图也可以用于层叠（Overlap）效果，对于到底使用哪种布局在一些特定的应用场景下也会有所不同。但我的理解是: FrameLayout对于层叠场景会有更好的表现和处理方式，在FrameLayout中也会有更多不同的声明方式来进行布局，而一般的RelativeLayout来定义层叠的位置关系会变得很复杂。所以不妨分离出所设计的页面中的层叠部分，来用FrameLayout完成，而其他的部分则采用RelativeLayout。 将你的页面进行分离，使用不同的UI布局框架来定义不同的子页面，也是UI设计布局中十分重要的一步。决定好使用的框架会让你的UI设计变得简单易懂，并且易于改动。相信很多人都遇到过改UI的时候一改就要动到所有的框架这种十分痛苦的事情。 ConstraintLayout最后一个，也是我认为最为重要，功能最为强大的一个，就是ConstraintLayout。ConstraintLayout和其它布局方式最明显的区别在于，它需要对于每一个组件声明布局的constraint，这些constraints会按照优先级被执行并布局。但是必须声明得比较完备，才能获得想要呈现的效果（也正是因为需要声明的constraint比较多，所以ConstraintLayout可以比较好的大部分在App中我们想要呈现的布局效果）。 在ConstraintLayout中，当定义一个组件的时候，可以通过声明app:layout_constraintXX_toXXOf来定义其相对于另一个组建的位置，同时也可以通过声明android:layout_marginXX来定义其相对边距，其用法是十分灵活的。ConstranitLayout在进行诸如边缘对齐，居中，各子视图(subview)平均分配等功能时十分有效，目前可以说是我最喜欢使用，也最经常使用的一种布局框架。","link":"/2020/07/02/AndroidBasic4/"},{"title":"Android开发笔记（六）- BroadcastReceiver组件","text":"在介绍了Activity组件和Service组件之后，这篇文章将会介绍Android开发中的第三个重要组件：BroadcastRecevier。简单来说，BroadcastReceiver主要用于监听、接收来自Android系统或者其他应用程序的广播信息，是用于不同APP之间，以及APP和Android系统之间通信的重要工具。APP可以根据接收到的信息，采取不同的操作来进行响应。 BroadcastReceiver首先还是先上Google的官方说明文档： Android apps can send or receive broadcast messages from the Android system and other Android apps, similar to the publish-subscribe design pattern. These broadcasts are sent when an event of interest occurs. 这里值得注意的是：BroadcastReceiver使用了观察者模式（Observer Pattern），从而解耦了广播的发送者和接收者。一个APP既可以是广播的发送者，也可以是接收者。发送广播需要通过手动调用sendBroadCast(Intent)方法来完成，而接收广播则需要通过注册一个自定义的BroadcastReceiver子类来完成。 实现原理BroadcastReceiver的工作流程如下图所示： 如上图所示，其中实现BroadcastReceiver子类以及注册子类需要通过代码手动完成，其他部分均是自动完成的。那么我们就来看看如何创建并注册BroadcastReceiver子类，示例代码如下： 1234567class SampleBroadcastReceiver: BroadcastReceiver() { override fun onReceive(context: Context?, intent: Intent?) { // define the behaviour when receive broadcast // 在这里定义接收到广播之后的操作 TODO(\"Not yet implemented\") }} 要注意的是：一般情况下onReceive()会运行在主线程（main thread），所以为了避免ANR，尽量不要在这里执行长时间的复杂操作，必要的话可以从这里开启一个Service来执行具体的操作。 静态注册 VS 动态注册 （重要！！！）实现了BroadcastReceiver子类之后，就是要在消息中心进行注册(register)，这里可以采用两种注册方式：静态注册和动态注册： 静态注册（静态广播）在Androidmanifest.xml中对实现的BroadcastReceiver子类进行声明，示例代码如下： 123456789&lt;receiver android:name=\"broadcast.SimpleBroadcastReceiver\" android:enabled=\"true\" android:exported=\"true\"&gt; &lt;intent-filter&gt; &lt;action android:name=\"android.intent.action.BOOT_COMPLETED\" /&gt; &lt;action android:name=\"android.net.conn.CONNECTIVITY_CHANGE\" /&gt; &lt;/intent-filter&gt;&lt;/receiver&gt; 其中receiver标签内可以定义注册时的很多属性，比如exported，enabled，permission，precess等，而intent-filter标签里则定义了允许接收的广播类型，比如BOOT_COMPLETED就是当Android设备Boot结束时系统会发送的广播类型，而INPUT_METHOD_CHANGED则是当用户切换了输入法时系统会发送的广播类型。通过在intent-filter里声明各种不同的广播类型，可以让APP对于不同的系统事件做出反应（onReceive()被调用）。 动态注册（动态广播）在代码中手动调用Context.registerReceiver()方法，传入BroadcastReceiver子类实例，并在使用结束后手动调用unregisterReceiver()方法来销毁。在Activity中使用动态注册的实例代码如下： 123456789101112131415161718192021222324class BroadcastDemoActivity : AppCompatActivity() { // 实例化实现的BroadcastReceiver子类 private val sampleBroadcastReceiver = SampleBroadcastReceiver() override fun onResume() { super.onResume() // 创建IntentFilter实例并添加需要监听的广播类型(Action) val intentFilter = IntentFilter() intentFilter.addAction(android.content.Intent.ACTION_BOOT_COMPLETED) intentFilter.addAction(android.content.Intent.ACTION_INPUT_METHOD_CHANGED) // 通过registerReceiver()方法动态注册 this.registerReceiver(sampleBroadcastReceiver, intentFilter) } override fun onPause() { super.onPause() // 通过unregisterReceiver()方法销毁广播接收者 this.unregisterReceiver(sampleBroadcastReceiver) }} 两者区别 使用静态注册时，当app退出后，BroadcastReceiver依旧可以接收广播并处理，而使用动态注册时，BroadcastReceiver的生命周期跟随Context的生命周期。例如，如果使用Activity.registerReceiver()，则当activity销毁时，receiver也会失效；而使用ApplicationContext.registerReceiver()时，当application退出时，receiver才会失效； 使用静态注册时，不需要手动声明销毁；而使用静态注册时，需要通过手动调用unregisterReceiver()来销毁接收器对象，否则会出现内存泄漏的情况，一般来说要在activity的onResume()和onPause()中成对出现，因为其他的生命周期都无法保证被成对调用，会出现重复注册或无法销毁的情况，Activity的生命周期相关内容可以看这里； 静态注册会更消耗内存和设备的电量，常用于需要时刻监听广播的情况，而动态注册更加灵活，常用于特定情况需要监听广播的情况，一般来说动态注册要优于静态注册。 Broadcast广播类型普通广播（normal broadcast）通过发送、接收包含自定义Action的Intent来实现通信的广播，这个Intent可以是开发者自行定义并创建的，普通广播是最常用的广播类型。如果发送的广播包含权限，那么接收器也需要相对应的权限才能接收。示例代码如下： 123456// 创建一个Intent示例并设置自定义的Actionval intent = Intent()intent.action = \"my_custom_action_name\" // 调用sendBroadcast()方法来发送广播this.sendBroadcast(intent) 此时，只需要广播接收者在注册时添加这个my_custom_action_name作为监听的广播类型（Action）即可接收这个自定义的广播。要注意的是，普通广播不能将处理结果传递给下一个接收者，并且无法终止广播Intent的传播。 系统广播（system broadcast）Android系统内置的广播，Android操作系统是发送者，主要用于监听手机的操作，状态变化等信息。不需要手动发送广播，只需要注册特定Action类型的接收器就可以等待接收。常用的系统广播包括：ACTION_AIRPLANE_MODE_CHANGED()，ACTION_BATTERY_LOW，ACTION_BOOT_COMPLETED等，系统广播的所有Action类型可以在这里找到。 本地广播（local broadcast）普通广播意味着其他APP也可以发送、接收当前APP的广播，但如果想获得效率更高，安全性更强的广播，可以使用本地广播。可以把它理解成一种APP内部的局部广播，它可以通过不同的方式来阻止外部广播的发送和接收。具体的方式有两种： 对普通广播加以限制，使其只能在APP内部通信： 对于静态注册的BroadcastReceiver，可以通过在manifest.xml中加入exported = &quot;false&quot;，使得非App内部发出的此广播不被接收。并且增设相应权限 permission，用于权限验证； 对于动态注册的BroadcastReceiver，可以通过调用intent.setPackage(packageName)来指定目标广播接收器的包名，可以使除此包名外的所有接收器无法接受广播（排他性）； 使用LocalBroadcastManager类来进行动态注册，此时发送、接受的广播全部属于本地广播，但是LocalBroadcastManager已经被弃用了，所以这里就不多做解释了。 有序广播（ordered broadcast）不论是普通广播，还是系统广播，都是按照随机顺序发送给所有符合条件的接收者的。但是有序广播会按照priority由大到小的顺序，依次发给所有符合条件的接收者。priority在manifest.xml或者通过手动调用intentFilter.setPrority(1000)来设置，prority是一个Int类型，示例代码如下： 12345678910111213141516171819// 静态注册设置prority&lt;receiver android:name=\"broadcast.SampleBroadcastReceiver\" android:enabled=\"true\" android:exported=\"true\"&gt; &lt;intent-filter android:priority=\"1000\"&gt; &lt;action android:name=\"android.intent.action.BOOT_COMPLETED\" /&gt; &lt;action android:name=\"android.net.conn.CONNECTIVITY_CHANGE\" /&gt; &lt;/intent-filter&gt;&lt;/receiver&gt;// 动态注册设置prorityval intentFilter = IntentFilter()intentFilter.addAction(android.content.Intent.ACTION_BOOT_COMPLETED)intentFilter.addAction(android.content.Intent.ACTION_INPUT_METHOD_CHANGED)intentFilter.priority = 1000// 发送有序广播, finalResultRecevier是终结接收者this.sendOrderedBroadcast(intent, null, finalResultRecevier) 这里要注意有序广播区别于其他广播的几个特点： 有序广播可以被截止，高优先级（priority）的广播接收者有权利决定比它低的接收者们是否可以接收到对应的广播，截断广播通过手动调用abortBroadcast()来实现； 有序广播可以被修改，高优先级（priority）的广播接收者可以修改后续比它低的接收者们所接收到的广播； 有序广播可以设置终结接收者，也就是无论终结接收者的优先级，最终它都会接收到广播并在此终结。 滞留广播（sticky broadcast）滞留广播在发送后会一直等待，在有符合条件的接收器被注册后，会立刻发送至该接收器，并继续等待。发送滞留广播需要获得BROADCAST_STICKY权限，而停止滞留广播需要手动调用removeStickyBroadcast()方法。因为滞留广播也已经在API 21中弃用，这里就不再多讲了。 注意事项对于不同注册方式的广播接收器回调OnReceive（Context context，Intent intent）中的context返回类型是不一样的： 对于静态注册（全局+应用内广播），回调onReceive(context, intent)中的context返回类型是ReceiverRestrictedContext； 对于全局广播的动态注册，回调onReceive(context, intent)中的context返回类型是Activity Context**； 对于应用内广播的动态注册（非LocalBroadcastManager方式），回调onReceive(context, intent)中的context返回类型是Activity Context； 对于应用内广播的动态注册（LocalBroadcastManager方式），回调onReceive(context, intent)中的context返回类型是Application Context。 参考文章Google Document: BroadcastReceiver overview Android四大组件：BroadcastReceiver史上最全面解析 Android四大组件——BroadcastReceiver普通广播、有序广播、拦截广播、本地广播、Sticky广播、系统广播","link":"/2021/01/13/AndroidBasic6/"},{"title":"Clean Code Summary","text":"Recently I read this book written by Robert C. Martin also known as “Uncle Bob”. In this book it talked about general coding principles to make your code “clean“ and easy to understand. And here is some useful tips and summaries I extracted. Chapter 2 Meangingful Names Use Intention-Revealing Names: avoid nonsense naming Avoid Disinformation: using FULLNAME, avoid abbrevation accountList &gt; accounts &gt; List Make Meaningful Distinctions: ProductInfo and ProductData, Customer and CustomerObject has no difference at all! Use Pronounceable, Searchable Names: the length of a name should correspond to the size of its scope Interface and Implementtations: avoid passing IShapeFactory as interface, using ShapeFactoryImpl in implementation Class Name: Avoid using Manager, Processor, Info, Dataas class name, using noun or noun phrase word One Word Per Concept: Don’t use retrieve, fetchr, get all at same time! It’s horrible! Chapter 3 Functions Small!: Funtions should be very small Avoid nested structures and each block should be one line Function should do one thing can’t extract another function from it witha nmae that is not merely a restatement of its implementation Switch statements: using polymorphism with abstract factory pattern Common Monadic Forms Ask question about argument like boolean isFileExist(File file) Operating on argument, transforming it into something and return like InputStream fileOpen(File file) Interpret function call as event and use argument to alter state of system without output argument like void passwordAttemptFailedNtimes(int attempts) Try to avoid any other form besides those three above Dyadic Forms Sometime reasonable if it’s a natural cohesion or ordering like new Point(0, 0) or assertEquals(expected, actual) It itn’s evil, but it has cost and there always a way to at least convert it to Monadic, just depends on whether it worth or not Argument Objects Using wrapper to wrap into a class of their own see these two following declarations: 12Circle makeCircle(double x, double y, double radius);Circle makeCircle(Point center, double radius); Output Arguments Try not using output argument, if must change state of something, make it change inside it’s own Prefer Exception to Returning Error Codes Error code always force caller to deal with it immediately using using try-catch block, the code to deal with succeed or error will be separated extract try and catch block to its own method should be more clear Chapter 4 Comments Comment should be no need at all It’s always the compensate for failure to express in code Programmer always forget to maintain, which makes them misleading Save the energy to write better and clearer code Chapter 6 Objects and Data Structures Data Abstraction Expose abstract interfaces to allow user manipulate data without knowing its implementation Consider serious which data should be exposed Data/Object Anti-Symmetry Objects: Hide data behind abstractions and expose funtions that operate their data Data: Expose data and have no meaningful functions Procedural code: Easy to add new functions, hard to change data structure Object Oriented code Easy to add new classes, hard to add new functions Need to use both of them properly to make clean code, but not in one class (hybird is the worst!) Chapter 7 Error Handling Use Exceptions Rather Than Return Codes Error code needs to be returned every single case, make the code very complicated and cultter caller Separate detection logic with handle logic Define Exception Classes in Terms of Caller’s Needs Wrapping third-party API is a best practice, easy testing, easy migration and less dependencies Define your own exception type inside wrapper to make handling logic easier outside the wrapper(only one type outside) Null Handling Don’t Return Null: throw an exception or using Special Case Pattern Don’t Pass Null: never pass null in methods Chapter 8 Boundaries Using Third-Party Code Hide the interface inside a class that we can control Avoid when change comes, we need change everywhere Make a Wrapper or Adapter to hide thrid-party interface Learning Test / Boundary Test It’s free and can be used to learning thrid-party code It can be used to detect breaking changes Chapter 10 Classes Class Organization Public static constants Private static constants Public instance variables (if any) Private instance variables Public functions Private function should directly after their caller Class should be small The more ambiguous the class name, the more likely it has too many responsibilities Avoid weasel words like Manager, Processor or Super which will aggregate responsibilities Single Responsibility Principle A class or module should have one and only one reason to change Identity reason to change often helps for better abstraction of our code A system composed of many small , well-structured classes is always better than a few large, multipurpose classes Chapter 11 System (Need revisit in future) Separate Constructing a System from Use it System should not know or care about startup logic, it assume everything should be constructed correctly when start running Using Dynamic Factory pattern to hide the building logic and allow application to decide when and what to build during runtime Dependency Injection: a way to achieve IOC (Inversion of Control) principle: the responsibility of instantiating dependencies will delegate to another “authoritative” mechanism","link":"/2020/04/28/CleanCode/"},{"title":"Android开发笔记（五）- Service组件","text":"在Android开发笔记之基础篇（二）中，我们简单总结了Activity组件的特性和使用方法。在其之后的第二个重要组件就是Service（服务）。简单来说，如果说Activity是负责处理与用户交互的UI部分的内容，那么Service则是负责在后台处理一些长时间，大型的操作或计算的内容。今天我们就继续来看看Service组件的特性以及使用方法。 Service首先，在Google doc官方说明文档中对Service的解释是： A Service is an application component that can perform long-running operations in the background. It does not provide a user interface. 所以从这里我们可以很清晰的看到Service的两个特性：后台运行和长时间运行。适合使用Service的场景实例有很多，比如播放音乐或者进行网络文件下载，与ContentProvider进行交互等等。在某些情况下，即使App被关闭后，其开启的Service依旧能够在后台运行。 Service分类按照不同的分类方式，Service可以从运行地点，运行类型以及功能进行分类： 运行地点 本地服务(local service)：运行在主线程（main thread），受线程的控制，主线程终止时，其也会被终止； 远程服务(remote service)：运行在自己的独立线程，常驻后台，不被其他activity影响，但会消耗更多资源。 运行类型 前台服务(Forground)：所谓“前台”，是指其会在通知栏中显示出来，需要让用户看到，并且终止时通知也会消失； 后台服务(Background)：不会显示在通知栏，用户无法知晓是否仍在运行。 功能 不可通信：使用startService()直接开启，调用者退出后，该service可继续存在，不可与调用者（例如activity）进行通信； 可通信：使用bindService()绑定开启，调用者退出后，该service也会退出并销毁，可以与调用者（例如activity）进行通信。 生命周期 Service lifecycle启动一个Service主要有两种方式：startService() 直接开启 或 bindService()绑定开启，两种方式产生的Service的生命周期不完全相同。先放上Google doc官方文档中给出的说明图： 这里我们首先需要知道，在Service中有四个手动调用的方法：startService(), stopService(), bindService()和unbindService()，通过手动调用这四个方法，可以使其自动调用另外五个方法：onCreate(), onStartCommand(), onBind(), onDestory()和onUnbind()。所以下面我们就对四个需手动调用的方法来一一详细分析其在Service生命周期中的使用方法和规律： startService() startService()会直接启动Service服务，即使多次手动调用startService() 只会调用一次onCreate()， 但会多次调用onStartCommand()，onStartCommand()的调用次数和startService()保持一致，也只有onStartCommand()可以被多次自动调用。 当onStartCommand()被自动调用时，会返回一个整数flag，其用于表示当该Service被系统销毁时要如何处理，这个flag有三种可能的状态：1. START_NOT_STICKY：除非还存在未发送的intent，否则该Service不会被重建；2. START_STICKY: 重建服务，但不会再次发送最近一次已发送的intent，适用于例如媒体播放等需要持续待命，但不用立刻运行的场景；3. START_REDELIVER_STICKY： 重建服务并发送最近一次已发送的intent，适用于例如文件下载等需要立刻恢复运行的场景； 当返回的flag是START_STICKY或START_REDELIVER_STICKY时， onStartCommand()也会被重新调用。 stopService() stopService()会直接关闭Service服务，但需要注意的是：在已经绑定服务（调用过bindService()）之后如果没有解绑，stopService()是不会关闭服务的。 bindService() 即使多次手动调用bindService()，实际上onCreate()也只会被调用一次，即只存在一个Service实例； 当一个服务已经通过startService()直接启动之后，依旧可以通过bindService()来绑定服务并使用。 unbindService() 如果使用bindService()绑定启动服务，那么 当多个客户端（client）绑定到同一个Service服务时，系统会在所有的客户端都解绑之后自动销毁服务，不需要手动调用unbindService()。 题目练习不妨用以下的test case来测试一下上面的流程图是否已经掌握，通过手动调用方法的顺序来判断Service自动调用方法的顺序： Service VS IntentServiceService与IntentService的区别是一个非常常见的面试题目，其主要区别包括： IntentService是Service的一个子类，主要通过一个work queue来处理从客户端接收到的intent，适用于处理较长时间的任务； Service运行在主线程(main thread)，无法处理耗时任务，否则主线程阻塞会出现ANR，而IntentService可以在独立的子线程上运行； Service可以从任何线程上启动，而IntentService只能从主线程上启动； Service通过手动调用startService()或bindService()来开启服务，而IntentService需通过Context.startService(Intent)来开启服务； Service通过手动调用stopService()来停止并销毁服务。但IntentService会在所有intent被处理完之后自动停止； IntentService会自动调用onBind()方法并返回一个null值，并为onStartCommand()提供了默认实现，将请求的intent添加进队列中。 参考文章Google Document: Services overview JavaTpoint: Android Service Tutorial Android：Service生命周期 完全解析 Android的Service生命周期 Service vs IntentService in Android","link":"/2021/01/11/AndroidBasic5/"},{"title":"Android SDK Version","text":"In Android development, I’m always confused about the properties in build.gradle like compileSdkVersion, targetSdkVersion, minSdkVersion etc. To end up this confusion and make it clear, after I read offical Google docuement and some posts, here is a short conclusion to explain each of them and compare the diff. minSdkVersionLike the name suggests, minSdkVersion is the minimum sdk version that your app should running at. For example, if the minSdkVersion of your app is 24 (Android 7), then trying to install the app at an Android 6 device or lower will failed because you declared that the minimum accepted SDK version of your app is Android 7. Another important usage is with the help of Lint check during development, you will get warning about using any API that required higher than your minSdkVersion. For example, if your minSdkVersion is 24 (Android 7) and you are trying to call an API introduced on Android 8, compiler will give you a warning and ask you to add a SDK version check at runtime before calling that API like: 123456private fun setUpActionBar() { // Make sure we're running on Honeycomb (Android 11) or higher to use ActionBar APIs if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.HONEYCOMB) { actionBar.setDisplayHomeAsUpEnabled(true) }} Also need aware that: the minSdkVersion of your app should be at least the highest minSdkVersion of all your dependency library or modules. For example, if your app has libraries required 9, 11, 14, then the minSdkVersion of your app must be at least 14. There are some ways to override this, but not recommended and should be carefully use. maxSdkVersionSimilar to minSdkVersion, it also can define the maximum sdk version that your app should running at. But since the Android platform is fully backward-compatitable, is attribute is not recommended by Google. Also when the Android version of device updated and exceed this maxSdkVersion, your app will be uninstalled automatically. complieSdkVersionStart from here, it is a bit hard to understand. So in general, compileSdkVersion is the android sdk version you tell the compiler to compile your app with. The most important thing here is: compileSdkVersion is not included in your APK, it is used purely at compile time, so it has no effect on runtime behaviour. So what compileSdkVersion effect? It effects the newest API available to you, for example, if a new API is introduced at Android version X, then you can only using this API when you set compileSdkVersion to X or higher. At this point, this is why it is strongly recommended to always set your compileSdkVersion to the latest, because by doing this you will get all benefits of new compilation checks on existing code, avoid using newly deprecated API and ready to use any new API. One more thing need mention here is: if you use the Android Support library, complieSdkVersion needs to be the same level or higher than the support library main version (first number). For example, if your app is using suport library version 23.1.1, then the compileSdkVersion needs to be at least 23 to make this compiled correctly. And to using AndroidX library as a replacement of Android support library, compileSdkVersion needs to be 28 or higher. targetSdkVersionThe last version, and also most “interesting” version is targetSdkVersion. As we said before, complieSdkVersion has no effect on runtime behaviour, but targetSdkVersion has, which means OS will decide how it should handle your app in term of OS features. It is more like a certification of sign off that indicate you have fully tested your app on this version. For example, when targetSdkVersion is higher than 23, Android OS will enable the runtime permission model to your app because it is the new feature introduced at that version. So please make sure you fully tested your app with that version before set targetSdkVersion into that number. Since targetSdkVersion will change your app runtime behaviour, it is suggested to always try to updated this number after fully test it. Also updating to latest SDK should be a higher priority of your app so you can use all new-introduced features and make your app looks up-to-date. Compare &amp; DiffNow after we know each of the version stands for, here we can come to a comparison table between each of them: So idealiy, the relationship about these three main versions in an Android app should be: minSdkVersion ( lowest possible ) &lt;= targetSdkVersion == compileSdkVersion ( latest SDK ) In this way, your app will always align with latest API changes, looks up-to-date, stable and easy-to-use. Your Audience will thank you for maintaining the SDK version and building this wonderful application! 参考文章Google Android Developer Doc - SDK Versions Google Manifest tag Picking your compileSdkVersion, minSdkVersion, targetSdkVersion Using androidx libraries in your project","link":"/2021/01/07/AndroidSDKVersion%20/"},{"title":"Android开发笔记之易混淆概念","text":"这篇文章中将会列出在Android开发中经常遇到并且容易混淆的概念，他们基本都是成对出现并且需要进行比较异同的。这其中不光设计安卓的知识，也有关于Java和Kotlin语言特性的一些基本概念。在面试时很多成对的概念会同时出现并被问到异同，这篇文章也会持续更新碰到的各种易混淆概念。 Kotlin语言特性lateinit VS lazy首先来看一下使用lateinit的代码示例： 123456789101112class LateinitTest { private lateinit var manager: Manager fun setupManager(manager: Manager) { this.manager = manager } fun run() { manager.run() }} 然后是lazy的代码示例： 12345678class LazyTest { private val manager = lazy { ManagerProvider.provideManager() } fun run() { manager.value.run() }} 可以看出这两种初始化方式有一个非常明显的区别： lateinit用于可变量var， 而lazy用于不可变量val。 如果从他们的具体作用来看，这其实很容易理解：lateinit用于class initialization时延期加载一个property属性，它可以随时在这个class的其他方法中（除了primary constructor）通过赋值的方式进行初始化加载，所以这个property必须是可变的variable。lateinit的主要使用场景包括：dependency injection以及non-null property的推迟加载（懒加载）。 lazy的具体作用则是：通过接收一个lambda function给property属性进行加载，后续再次调用property的get()函数时则会使用lambda返回的对象而不会再次初始化，也就是说lambda只会执行一次但获得的结果会持续返回，所以需要使用不可变量来保证lambda结果的唯一。lazy的主要使用场景包括：单例模式（if-null-then-init-else-return）。 总体来说，lateinit比lazy的适用范围更大，可以用lazy的地方都可以用lateinit但是反之却不行。但是对于单例模式来说使用lazy可以大量节省初始化资源，所以当可以使用的时候还是应该优先考虑lazy。 Android SDK相关Serializable vs ParcelableSerializable是一个Java Interface，通过实现这个接口，可以轻松的将一个POJO（plain old java object）在Activity中进行传递。实现Serializable接口不需要Override任何方法，但是因为它使用了Java Reflection API所以在编译过程中会生成很多额外的文件，有时会触发垃圾回收（garbage collection），浪费系统资源以及设备电量。 Parcelable是Android SDK中的一个Android Interface，它不需要使用Java Reflection API 所以不存在冗余文件的问题，可以节省资源。但是实现Parcelable接口需要额外实现包括writeToParcel，describeContents以及Parcelable.Creator在内的几个方法，同时也会使得POJO中的代码难以理解和阅读。 总体来说，Serializable实现简单，代码易读；而Parcelable高效迅速，降低功耗。两者各有优劣，现在还有第三种方式，就是使用Serializable并实现writeObject()以及readObject()这两个方法来避免Reflection自动生成的多余文件，这相当于一种折中和妥协。只要根据具体使用场景来判断哪一种更好就可以了，具体问题，具体分析。 Java语言特性相关Overriding vs OverloadingTL,DR: Overloading occurs when two or more methods in one class have the same method name but different parameters. Overriding means having two methods with the same method name and parameters (i.e., method signature). One of the methods is in the parent class and the other is in the child class. 这是一个经常出现在面试中的经典问题，简单来说Overriding是指在同一个class内声明方法名相同但参数不同的多个方法（two or more methods in one class have the same method name but different parameters），而Overloading则是指在子类中声明一个和父类名称，参数均相同的方法，但却有不同的具体实现（two methods with the same method name and parameters， one is in the parent class and the other is in the child class）。代码实例如下： 123456789101112131415161718192021222324252627282930313233343536373839open class iPhone { // Overloading examples open fun start(password: String) { print(password) } open fun start(fingerPrint: FingerPrint) { print(fingerPrint) } open fun start(face: Face) { print(face) }}class iPhone8 : iPhone() { // Overriding examples override fun start(password: String) { print(\"iPhone8 $password\") } override fun start(fingerPrint: FingerPrint) { print(\"iPhone8 $fingerPrint\") }}class iPhone11 : iPhone() { // Overriding examples override fun start(password: String) { print(\"iPhone11 $password\") } override fun start(face: Face) { print(\"iPhone11 $face\") }} 代码中iPhone的三个不同参数的start()方法是Overloading，而iPhone8和iPhone11中的start()方法则是Overriding，且因为在各自内部方法名一样，参数不一样，所以也是Overloading。 除此以外，Overloading 和Overriding的区别还有以下几点要注意： Overloading发生在编译时（complie time），Overriding发生在运行时（runtime），所以从performance来说Overloading更高效； 静态方法（static method），final method 和 private method 均可以Overloading，但都不可以Overriding，因为子类不可以对父类的以上三种方法进行修改； Overloading属于静态绑定（static binding）而Overriding属于动态绑定（dynamic binding）； Overloading时返回值类型可以不同。 Volatile vs SynchronizedTL, DR: Use Volatile when you variables are going to get read by multiple threads, but written to by only one thread. Use Synchronized when your variables will get read and written to by multiple threads 这两个关键字的用法与Java虚拟机本身的操作特性有关。首先要知道，在Java中当多个CPU线程同时工作，每个CPU线程都可以从内存空间（main memory）获取需要的共享变量，存入当前线程的CPU缓存（CPU cache）中并使用。大致工作流程如下图： 所以这里就要先介绍一下关于工作流程中共享变量的两个特性：“可见性”和“原子性”: 可见性（memory visibility）：指当一个线程对共享变量进行修改的时候，会强制其在内存空间里进行更新以便其他线程使用更新后的值； 原子性（memory atomic）：指在线程修改共享变量到内存空间更新之间，其他线程不可以从内存空间内读取旧的，未经过更新的共享变量值（保证每个人拿到的都是最新值）； 在定义了这两个特性之后，我们可以来介绍一下Volatile和Synchronized这两个关键字的区别： Volatile可以保证每个线程中共享变量的“可见性”，但无法保证“原子性”。也就是说，使用Volatile的方法有可能会获取到旧的，未更新过的共享变量值。因为当前线程对于共享空间的更新操作和其他线程的读取操作会有Race Condition出现。所以一般Volatile适用于只需要读取，不需要写入内存空间的场景； Synchronized可以同时保证每个线程中共享变量的“可见性”与“原子性”，相比于Volatile， Synchronized更可靠，但同时开销也更高。它可以保证在同一时间片段内有且只有一个线程可以对内存空间的共享变量进行操作，包括读取，计算和更新。所以一般Synchronized更适用于需要同时进行读取和写入内存空间的场景。 参考文章：Learning Kotlin - lateinit vs lazy Overloading and overriding in java Parcelable vs Serializable Volatile vs Synchronized","link":"/2020/10/24/AndroidConfusion/"},{"title":"Clear Architecture - Programming Paradigms &amp; Design Principles","text":"Clean Architecture is one of the series book that written by “Uncle Bob”. In last post, I writed a summary of the Clean Code. It is super useful for begineers. But as we going deeper, we need take a step back and see the “big picture” – software architecture, which is all this book talk about. Part II Starting with the Bricks: Programming ParadigmsStructured Programming: direct transfer of controlConstructed from sequence, selection and iteration to replace old goto keyword. A typical structured programming example: 123456789101112131415// sequence executionval sum = 0val current = 1// iterationwhile (current &lt; 10) { sum += current current += 1}// selectionif (needNegative) { return sum *= -1} else { return sum}return sum All programs can be constructed from just these three structures: sequence, selection and iteration. Object-Oriented Programming: indirect transfer of controlThrough the use of polymorphism to gain absolute control over every source code dependency in the system.To better understnad about power of polymorphism. also check Dependency Inversion Principle below. A typical object-oriented programming example: 123456789101112131415161718192021222324252627282930313233343536// define Vehicle interfaceinterface Vehicle { fun alarm() fun turnOn() fun turnOff()}// different brand of car, should all implement the same interfaceclass BMW: Vehicle { override fun alarm() { makrSound(\"di~di~\") } override fun turnOn() { ... } override fun turnOff() { ... }}// but they can have diffrent implementation (such as differnt alram sound)class Ford: Vehicle { override fun alarm() { makrSound(\"do~do~\") } override fun turnOn() { ... } override fun turnOff() { ... }}// when client code is using them, they don't need to know the implementation detailsFord().turnOn()BMW().ring() Any source code dependency, no matter where it is, can be inverted. Functional Programming: variable assignmentVariables in functional languages do not vary, which will causing none of race condition, deadlock or concurrent update problems. A typical functional programming example: 123456789class Person constructor ( private val name: String) { fun getName(): String { return name }}// define a function to get person's nameval personName = fun(person: Person) = person.getName Concurrent problems can be eliminated by segregate the application into mutable and immutable components. Part III Design PrinciplesSingle Responsibility Principle (SRP) A module should have one, and only one reason to change A common way to impose this principle is: Separate shared functional code blocks from specific logic. For example, here is a Employee class from payroll application: 1234567891011121314class Employee { private val employeeDB = EmployeeDatabase() fun getWorkingHours(): Int { return employeeDB.queryWorkingHours() } fun calculatePayroll(): Int { val workingHours = getWorkingHours() val salaryRatePerHour = employeeDB.querySalaryRatePerHour() return workingHours * salaryRatePerHour } fun saveEmployee() { employeeDB.updateEmpployee(this) }} It’s clear that this Employee class has too many responsibilities including query working hour, query salary rate, calculate payroll, update employee info etc. And typical problem can be: It’s hard to extends, when introduce different ways to calculate payroll for example; Who wants to change ONLY working hours fetching may also touch payroll calculation accidentally; EmployeeDatabase is exposed to Employee class, which is dangerous for open visibility. To solve these issues, we can do: 1234567891011121314class Employee { private val hourReporter = HourReporter() private val payCalculator = PayCalculator() private val employeeSaver = EmployeeSaver() fun getWorkingHours(): Int { return hourReporter.reportHours() } fun calculatePayroll(): Int { return payCalculator.calculatePay() } fun saveEmployee() { employeeSaver.saveEmpployee(this) }} As we can see, after we create HourReporter, PayCalculator and EmployeeSaver, we separate different responsibilities to different class so: if we want to have diffrent ways to calculate payroll, it can be updated inside PayCalculator and no need to update Employee class; when working hours fetching need to change, no need to touch payroll calculation logic; no more database expose to Employee class since it’s handled by these three classes internally. Open-Closed Principle (OCP) A software artifact should be open for extension but closed for modification. This is a common case that sometimes we want to extends part of our code and extends without having to modify that artifact. To make this possible, we need to implement component hierarchy structure so code change in lower level component will not effect higher level component. In other word, higher level component is being protected from code change chain. Let’s continue on the Employee example: 1234567891011121314class Employee { private val hourReporter = HourReporter() private val payCalculator = PayCalculator() private val employeeSaver = EmployeeSaver() fun getWorkingHours(): Int { return hourReporter.reportHours() } fun calculatePayroll(): Int { return payCalculator.calculatePay() } fun saveEmployee() { employeeSaver.saveEmpployee(this) }} It’s easy to understand that HourReporter, PayCalculator, EmployeeSaver classes has higher prority then Employee class and we want to avoid code change on them when we need change Employee class. The UML of structure is like: Note that an arrow pointing from class A (Employee) to class B(HourReporter, PayCalculator, EmployeeSaver) means: the source code of class A mentionas the name of class B, but class B mentions nothing about class A. In this XML, Employee depends on these three classes, so those three classes is protected from changes in Employee. Liskov Substitution Principle (LSP) Subclass should be substitutable for their base class A typical example of this principle is square/rectangle problem, let’s briefly recall the problem first by UML: As common sense, a Square should be treated as a special Rectangle which means all operations or parameters for a rectangle object should also effect on a square object. Let’s see the code block below: 1234val rectangle = Rectangle()rectangle.setWidth(2)rectangle.setHeight(5)assert(rectangle.getArea() == 10) This should work fine and the assertion should pass as well, but when we do the same thing to a Square like: 1234val square= Square()square.setSide(2) // how can width and height change at same time???square.setSide(5)assert(rectangle.getArea() == 10) // this will failed and area will be 25 The core problem behind this case is : square has a feature which rectangle don't: need set both width and height always at same time with same value, they can't be changed separately. It may causing a lot problems becuase of this. Interface Segregation Principle (ISP) No client should be forced to implement methods it doesn’t use When we play with abstract interfaces and implementation, a common problem is we find there are extra methods that the implementation not used at all. The easiest way to handle it is just override it and make it empty. But by doing this, there is a risk that it might be touched by other maintainers or even yourself in future since you may not remember. A good fix on this should be separate it into multiple specific interfaces like: In my opinion this is a good way to minimum the risk and separate interface for different class if they not use all of them, but also note that this might causing a lot interfaces to be generated, this is the trade-off. Dependency Inversion Principle (DIP) High-level module shouldn’t depend on low-level, but both should only depend on abstraction, not on concretions This is the most information principle in my opinion and also the hardest one to understand. To understand this, first question is: what is abstraction and why we need it? To answer this, let’s see this example UML: This is the concrete implementation for an application with a simple service. Service is created by ServiceFactory by calling serviceFactory.createService(). It works fine but it has several problems: Application can access everthing inside Service and ServiceFactory, it including something they don’t use (violation of ISP); Both Service and ServiceFactory are dependencies of Application, which means when their code changed, Application will need to re-comple and re-generated everytime (violation of OCP); If we want to add new type of service in future, both Application and ServiceFactory need change the code and still hard to extends (violation of OCP again). So according to what we learned before, here is a better solution for all three points above: As you can see in the solution UML, we make both ServiceFactory and Service as Interface and give them implemnentations for each interface. Note that implementation is hided from Application so it only communicate with interfaces. Why? Look back into all three problems above and you will find all of them is successfully solved by using Interface! Now let’s understand the description of this principle with the example: consider Application as low-level module and ServiceFactory, Service as high-level module, Application should not depends on ServiceFactory and Service because of the violation of ISP, OCP and DIP, and they should all depends on the abstraction, which is Interface in this case. And by using interface, the control flow is successfully inverted from Application -&gt; ServiceFactory to ServiceFactoryImpl -&gt; Application, same for Service as well. This is how Inversion come from.","link":"/2020/05/11/ClearArchitecture1/"},{"title":"clearArchitecture - Desgin Principles &amp; Component Principles","text":"In last post we talked about programming paradigms and SOLID principles. This is far more than enough to understand about architecture, so today let’s continue on “Design Principles” and see more of them that need to follow when thinking like an architect. Part IV Components PrinciplesComponentsThe samllest entities that can be deployed as part of a system. In java, they are jar files; In Ruby, they are gem files and in complied languages, they are aggregation of binary files. It can be dynamically linked together at runtime, which can be used as plug-in. Components Internal PrinciplesReuse/Release Equivalence Principle(REP) To resue software components, it need to be tracked through a release process and are given release numbers. Because developer needs to know which cohesive group is the current compoent belong to. In another word, component cannot be easily plug-in or pull-out without version control, it will mess up the whole project without clearly knowing which version contains what feature. Common Closure Principle(CCP) Gather into components those classes that change for the same reasons and at the same times. Separate into different components those classes that changed for different reasons and at different times. This is component level of SRP *(single responsible principle), which means *a component should not have multiple reasons to change. If you find two components are always changed together, try merge them into one. Common Reuse Principle(CRP) Don’t force users of a component to depend on things they don’t need This is component level of ISP (Interface Segregation Principle) and a bit more generic. If there are not used dependencies exists in component, that means when anything changed in those dependency, the component is highly possibly to do corresponding changes and then recompiled, revalidated and redeployed. So be careful to only depend on the things you really need. Component Tension DiagramSo after known those three component principle above, we can draw a tension diagram like this: As we can see here, these three principle are balanced to each other and when you try to apply two of them, you will sacrifice the another. Normally we start from CCP and CRP, to make the component working and changing fast. As the component become more and more stable, we will start to move left and apply REP to make it easier to reuse and maintain until we find a perfect balance in middle. The final balance point are varied team by team. Components External Principle (Between Components)Acyclic Dependencies Principle (ASP) Allow no cycles in the componet dependency graph Dependency cycle can work, but very difficult to change because when new change apply to one componet, all other components need to change to be compatiable. The cycle itself performed like a “super big component” which a lot other component will depend on. Two ways to eliminate the cycle in component dependency graph: Apply Dependency Inversion Principle (DIP): create an interface inside the depender component (the one need depend on the other) so the dependee will implement this interface. This UML will explain more clearly: Create a new component that both depender and dependee should depend on. In this way the cycle will be break since the new component will not depend on any of them. The UML should looks like: Stable Dependencies Principle (SDP) Depend in the direction of stability. This principle is short and concise, but might not be easy to understand. A better description might be: Any component that we expect to be volatile should not be depended on by a component that is hard to change, which means stable. To measure the instabillity, we need use I-metric to meature. I-metric can be calulated by: I = Fan-out / (Fan-in + Fan-out), for example: In this UML, we can see that both component A, B, C has I-metric = 1, which makes them unstable and easy to change because their changes will not influence any other componets. For component E, since I-metric = 0, which means it’s hard to change because to change it, it might need to change all components depend on it such as B, C and D, which might need change A as well since A depends on D! For Componet D, I-metric=0.25 which means it’s still stable and hard to change, but the effort to change it is less than component E. So basically I-metric can give us a hint that how easily this component can be changed. To make a stable component easy to change, we need to create something called abstract component. It is the same concept as interface at class level. so we will create a new component which contains interfaces and make both component depends on it, like: As we can see before compoent Authorizer I-metric = 0 which is hard to change, and after we using abstract component Permissions, it has I-metric = 1 and as easy to change as component Entities. Before we finish this principle, there are two points need to mention: SDP suggests that, in dependency graph, the I metric of a component should be larger than the I metric of the component that it depends on, which means the I metric should keep decreasing in the direction of dependency chain; Abstract components are very stable (usually I-metric = 0), so they are ideal target for less stable components to depend on. Stable Abstraction Principle (SAP) A component should be as abstract as it is stable. This is also too “abstract” to understand. So a better explanation should be: A stable component should also be abstract so that it’s stability does not prevent it from being extended; An unstable component should be concrete since its instability allows the concrete code within it to be easily changed. Since we know that dependencies should run in the direction of stability, and stable component should be abstract, we can also know: dependencies should run in the direction of abstraction. For stability, we have I-metric to measure, so do we have similar measurement for abstraction? Of course yes! Come on, A-metric! A-metric can be calculated by: A = Na / Nc, Na is number of classes inside the component and Nc is number of abstract classes and interfaces in the component. For an abstract component like we said above, A-metric = 1 which means totally abstract; and for a componet without any abstract classes and interfaces, A-metric = 0 which means totally concrete, pretty straightforward👍. I-metric/A-metric GraphNow we can two metrics to describe a component’s stability and abstractness. But what’s the relation between them? How can we evaluate it? This is the time I-metric/A-metric Graph start to use: In this graph, we are using A-metric as vertical axis and I-metric as horizontal axis. In this way, each component wil fall into a point with coordinates in this graph. There are some points need to mention in this graph: Zone of Pain is a zone that not expected to put componets, because in this zone components are rigid,concrete and very hard to change. The only excluded case might be Databse schema or some utility libraries; Zone of Uselessness is also a not expected zone, because in this zone compoents are totally abstract and dependent which means might nobody using them and can be removed. The most desirable position for a component is at one of the two endpoints of the Main Sequence. They are stable and abstract, or flexible and concrete. Once the I/A graph is done, we can fill the components inside the graph and got this: By calculating the Distance between a point to Main Sequence: D = |I + A - 1|, we can get the result of how far away a component is from ideal. and then we can draw the standard deviation line(Z = 1) and focus on the component that beyond these lines and start refactor them. This is how these metrics can help us find the correct components to improve.","link":"/2020/07/06/ClearArchitecture2/"},{"title":"ClearArchitecture - Architecture","text":"After we known all principles in class level and component level, finally we reached Architecutre level. In this post, we will summarize all architecture level knowedge concepts quickly and finish this book for now, this book has much more useful stuffs that we are not covered, so we will come back and revisit someday after we have more understanding about software architecture. Part V ArchitecutreClear ArchitectureBy dividing the software into layers, the architecture has the following characteristics: Independent of frameworks: not depend on the existence of any library, use them like plug-in; Independent of the UI: not effected if UI changed, easy to replace with another UI; Independent of the database: not effected whatever DB is using like SQL or Mongo, CouchDB; Independent of any external agency: business rules don’t know anything about outside world; Testable: business rule can be tested without UI, DB or web server, etc. In this way, we have the diagram structure of a Clear Architecture like: From this diagram, we can see: Inner circles represent higher level components and outer is lower, in another word, the further in you go, the higher level the software becomes; Source code dependencies must point only inward, toward higher-level policies. Nothing in an inner circle can know anything at all about outer circle. Inner circle has higher abstraction and stability while outer circle are more concrete and easy to change; The lower right corner shown how to cross circle boundaries; This four circles model is not strict, sometimes you may find more than four layers which is totally make sense: what important is following the component rules we introduced in last post here; When you want to pass data crosses boundaries, keep it isolated, simple and easy to be used by inner circle, which means: always processing raw data in outer circle before pass it inward. Now let’s review this architecture model layer by layer: EntitesThis is the core layer of the model which contains enterprise-wide critical business rules. Usually this should be shared by all different applications in the enterprise, it can be business objects or a set of data structure. These are the least likely to change and shouldn’t be effected when something external changed. User CaseThis is the layer of application-specific business rules that should be different between applications like mobile apps or browser websites. Changes in this layer should not affect Entites layer and vice versa, but the operation of the application will affect logic inside this layer for sure. Interface AdaptersThis layer contains a set of adapters that convert data from the format most convenient for the use cases and entities to the format most convenient for some external agency such as database, web or UI. For example, all models, views and presenters of the MVP pattern should be inside this layer. Also adapters in this layer should be bi-directional converting which means is should also convert data from external agency to use cases and entities as well. Frameworks And DriversThis is the outermost layer of the model which contains all frameworks and tools such as database, web framework or UI, in general, this is all the details go. Usually you don’t need write much code in here, other than glue code that communicates to the next circle inward. Architecture DecouplingIndenpendenceA good architecture should support all the following: Use cases and opearation of the system (support the intent of the system) Maintenance of the system (support daily operations requirements) Developement of the system (support contributed by whole company without conflicts) Deployment of the system (immediate deployment) To achieve this, we need to decouple system into layers. Different layer should have different reason and rate to change. This decoupling mode can have three levels: Source Level: control the dependencies between source code modules so changes to one module do not force changes of others; Deployment Level: control dependencies between independently deployable units like jar failes or shared libraries; Service Level: control dependencies between each services so communicate solely through network packets. As always, it’ hard to know which mode is best during the early phase of a project. As the project grows, the optimal mode may change. BoundaryBoundaries is drawing a line to prevented each side of the line from knowing anything about the other side. Drawing the boundary lines helped delay and defer decisions and saved amount of time and troubles. To draw boundary lines in software architecture, we need follow these steps: Partition the system into components, some components are core business rules and others are plugins; Arrange code in those components such that arrows between them point in one direction to core business; Apply SRP(Single Responsibility Principle) and it should tell where to draw the boundary line. DetailsDatabaseThe database is a utility that provides acccess to the data, it is just a mechanism we use to move the data back and forth between the surface of the dask and RAM. The organizational structure of data, the data model, is architecturally significant and the technologies and systems that move data on and off are not. WebThe web is an I/O device, it is a GUI, and GUI is a detail which only matters input and output. Framework Don’t marry the framework! Frameworks are not architecture. You must make a huge commitment to the framework, but the framework author makes no commitment to you whatsoever. Use the framework but do not couple to it by deriveing proxies and keep those proxies in components that are plugins to business rules.","link":"/2020/07/09/ClearArchitecture3/"},{"title":"Dependency Injection","text":"Dependency Injection is a huge topic in Android development and it’s very important because it can give us a clean, well-designed, easy-to-change environment no matter we develop new features or implement any testing. So here is some thoughts about DI and an useful framework which helps you do all dirty jobs behind the scene. What is Dependency InjectionBefore answering this question, a better question to ask might be: What is dependencyTo answer this question, let’s take a look at this Kotlin code here: 12345678910111213class SimpleFeature constructor( val businessLogicDelegate: BusinessLogicDelegate, val validator: Validator, val listener: Listener) { fun doSomeThing() { val helper = Helper() if (validator.validate()) { businessLogicDelegate.doSomething(helper, listener) } }} This is a very common secenario in real life: I have a class and serveral parameters in its constructor, I need call some methods of those parameters inside this class. At the same time, I also need initialize a helper class inside and use it. In this case, both the parameters and helper class will be considered as the Dependency of SimplyFeature class. Cause this SimpleFeature needs “depend on“ something to finsh its own job. In another word, if any class’s method is called inside a class A, those class will be considered as A’s dependency. So now I know dependency, what is dependency injection?Let’s look back to this code again: 12345678910111213class SimpleFeature constructor( val businessLogicDelegate: BusinessLogicDelegate, val validator: Validator, val listener: Listener) { fun doSomeThing() { val helper = Helper() if (validator.validate()) { businessLogicDelegate.doSomething(helper, listener) } }} There are two main issues in this code block: Inside the doSomeThing(), we need to initialize a Helper class to help finishing business logic. This can work for sure, but if this helper needs to be a static class, or I need to using a Signleton helper class, here, how can I use it? When writing unit test with Mockito or Mockk, a common way is passing in a “mock“ instance and testing if the expected method of this mock is called with correct parameter. But how can we pass in the mock of Helper class if the new operator is called inside? To solve these problems, what can we do? Just simply pass a helper instance in the constructor so it can become the dependency of SimpleFeature as well! The constructor will look like this: 12345678910111213class SimpleFeature constructor( val businessLogicDelegate: BusinessLogicDelegate, val validator: Validator, val listener: Listener, val helper: Helper) { fun doSomeThing() { if (validator.validate()) { businessLogicDelegate.doSomething(helper, listener) } }} Now it looks great! I can pass in any Helper class and also mocking it and do the unit test! Nice! Now we can make a conclusion here: Dependency Injection means:Passing the dependency into the class and use it One thing need to mention here is: passing through class’s constructor is only one of the way to do DI. More details about this concept can be find here. How can I use dependencies injection?To use dependencies injection effectively, let me introduce this super-useful library here: This Dagger 2 library are powerful for android application dependency injection, by using this, all we need to do it’s define each class’s dependency list and the scope to use it. All other stuff will be handled by this library automatically and anonymously. So how to use it? First, we need to have a module class: 12345678910111213141516@Moduleinterface MainModule { @Binds fun providesBusinessLogicDelegate(businessLogicDelegateImpl: BusinessLogicDelegateImpl): BusinessLogicDelegate @Binds fun providesValidator(validatorImpl: ValidatorImpl): Validator @Binds fun providesListener(listenerImpl: ListenerImpl): Listener @Binds fun providesHelper(helperImpl: HelperImpl): Helper} What is this Module use for? Basically this is the place you want dagger helps you to initialize all your dependency. There are two ways to initial dependency in dagger, one is through @Bind annotation and another is @Provides. In here I’m using @Binds since it’s much simpler if all dependencies has implement an interface. Then we need another class which is called componenet class: 1234567@Component (modules = [MainModule::class])interface MainComponent { fun inject(activity: MainActivity) fun inject(feature: SimpleFeature)} Inside this Component, the inject() method defines “where those dependencies should be injected to”. And following the @Component annotation we can declare all modules that can be included, so we can inject multiple module’s dependencies inside one single class that called by inject() method. So far so good! After create these two classes above, we defined What is the dependency and Where should we inject into. Now the final step will be refactor our SimpleFeature class: 12345678910111213class SimpleFeature @Inject constructor( val businessLogicDelegate: BusinessLogicDelegate, val validator: Validator, val listener: Listener, val helper: Helper) { fun doSomeThing() { if (validator.validate()) { businessLogicDelegate.doSomething(helper, listener) } }} Since all parameters inside the constructor are initialized in module class and the injection of this feature class also declared in component class, the only change needed in here is add @Inject annotation before constructor, then dagger knows that all parameters can be find in module and injected by component magically. Done! Now enjoy inject any dependency you want! Now there are still some notes worth mention here: What we using here is just a very brief introduction of Dagger, it has a lot powerful methods and tools that worth to try and play with it. More detail should be found in here One of the very useful feature of Dagger is @Scope annotation. It can be used in complicated structured project to define different scope for different dependencies to access. This part will be added in future as a follow-up of our DI topic. The main purpose of DI is align with one of the basic SOLID principle in softwate development, which is know as Dependency Inversion Rules. This principle states: High-level Module should not depends on low-level module, both should depend on abstractions (interface); Abstractions should not depend on details. Details (concrete implementation) should depends on abstraction. We will cover all these principles one by one in future, they are very important in industrial software development world. Although there are tons of advantages in DI, but it has its limit or disadvantage for sure. For example, when dependency is missing, it’s hard to find out which dependency is missing by checking the build output. So at this time, log is very useful to check.","link":"/2020/02/28/DependencyInjection/"},{"title":"Lambda Expression Basic","text":"Lambda Expression is a very useful tool and it makes the code concise and elegant. It’s not a very hard concept to understand but still need some kind of conclusion or summary. So in this post I will have a brief introduction on what is lambda expression with several examples how to use it. My example are using Kotlin lanuage, but it has the same pattern or other languages like Java and C++. What is Lambda Expression Lambdas Expressions are essentially anonymous functions that we can treat as values That’s all, as simple as it is. The most important of this defination is: treat as values, what is that mean? Actually that means three things: You can assign lambda expression as a value to any variable like you do val a = 1; You can pass lambda expression as an argument in a method call; You can use lambda expression as a return value of method. A generic lambda expression structure looks like this: Only the body is required, all other parts can be optional in some cases: When we pass lambda as argument, no need lambda expression name; Return type can be inferred by Kotlin complier which is the last command within the body; Argument list also not needed when there is only one argument, we can use it in body which refer to the only argument. Type Declaration and InferenceWhen we define lambda expression, like all another type, we need to declare it’s type. Such as: 12345val square: (Int) -&gt; Int = {num: Int -&gt; num * num}val sum: (Int, Int) -&gt; Int = {num1: Int, num2: Int -&gt; num1 + num2}val printNumber: (Int) -&gt; Unit = {num: Int -&gt; println(num)} As we can see from above, lambda expression type pattern is Input -&gt; Output, need using braces if more than one input or output like `(String, Int) -&gt; (Double, Long) and Unit can be used if no return value. But it is too verbose sometime to have all parts of lambda expression, as we said above, a lot part of it can be optional. For example, we have square lambda expression like: 1val square: (Int) -&gt; Int = {num: Int -&gt; num * num} Since num is an Int, Kotlin complier can infer that num * num will be an Int as well. So return type can be optional like: 1val square = {num: Int -&gt; num * num} // This used a lot when pass the whole lambda as argument Another way to simplify is: since we know square will have a Int argument and return an Int, argument list can be skipped: 1val square: (Int) -&gt; Int = { it * it} // This used more like a defination of lambda Note that these two ways can’t do together, since Kotlin complier will have too less information to infer and complie. Pass Lambda as ArgumentNow after we know how to declare a lambda expression, next thing is pass it as an argument. In general we have f options to do it. Consider we have an invokeLambda function which needs pass in a lambda expression and an Int as arguments: 123fun invokeLambda(lambda: (Int) -&gt; Int, num: Int) : Int { return lambda(num)} Let’s see how these five options works and what’s the difference. 1. Pass as Lambda Object VariableIn this way, we assign the lambda into a variable and pass the variable as usual: 12val square: (Int) -&gt; Int = {num: Int -&gt; num * num}val result = invokeLambda(square, 4) // this will return 16 2. Pass as Lambda LiteralThis way we don’t need assign lambda to any variable, it can be passed directly and literally: 1val result = invokeLambda({ it * it}, 4) // this will return 16 3. Pass as Lambda Literal without BracketsThis is a bit tricky, to use this, we need make sure: Lambda argument is the last argument in high-order function; There only one lambda argument is this high-order function. So let’s do some refactor, invokeLambda will looks like: 123fun invokeLambda(num: Int, lambda: (Int) -&gt; Int) : Int { return lambda(num)} Then we can move the lambda expression out of the brackets like: 12val result1 = invokeLambda(4) { num -&gt; num * num } // no need return type, thanks to Kotlin Inferenceval result2 = invokeLambda(4) { it * it } // even no need argument list since only one argument 4. Kotlin Extension Method ReferenceThe last option is kind of more special case, it needs to use reference of Kotlin Extension Method as the argument. Consider the same invokeLambda as option 3, we need add a sqaure extension method: 1234// define a Int class extension methodfun Int.sqaure(): Int { return this * this} then we can pass the method reference of this extension as lambda: 1val result = invokeLambda(4, Int::sqaure) // this will return 16 The type of extension method reference Int::sqaure is KFunction1&lt;Int, Int&gt;, it can be treated as (Int) -&gt; Int type which is required. Even if the lambda needs more arguments, we can just add it in extension method arguments list. Annoymous Inner Class VS Lambda ExpressionTo be honest these two concepts doesn’t share much features, but since I saw people asking the diff so I want to add them here as a reference. To short, there are Anonymous Inner classes can be used in case of more than one abstract method while a lambda expression specifically used for functional interfaces. Anonymous Inner classes can use instance variables and thus can have state, lambdas cannot. Anonymous inner classes have support to access variables from the enclosing context. It has access to all final variables of its enclosing context. When use lambda expression as functional interface, two conditions need to meet: 1. it needs to be a Java interface (not a Kotlin one); 2. the number of method arguments need to have a limit. Useful LinkKotlin Lambda Expression Introduction to Kotlin Lambdas Getting Started Kotlin Offical Documents Lambda Expression VS Anonymous Inner Class","link":"/2020/11/01/Lambda/"},{"title":"ProGuard, D8, R8编译器介绍","text":"在编译代码，生成Android APK文件时，为了缩减生成安装包apk文件的大小，Google官方在Android Gradle插件中提供了几种不同的优化方式：Proguard，D8，R8。它们主要用于对生成的apk文件进行代码缩减（Code shrinking），资源缩减（Resource shrinking），混淆处理(Obfuscation)和优化(Optimization)。这篇文章会首先介绍一下这些编译器的产生顺序以及原因，然后再介绍一下proguard-rules.pro中规则的定义方法。 1. ProguardProguard是Google Android SDK中提供的优化代码和缩减apk文件的编译器，其工作流程是： 可以看到，首先.java文件会被Java编译器编译成.class文件，之后Proguard则会对.class文件进行缩减和优化，再通过Android运行环境中的Dalvik虚拟机将.class文件编译成可以运行的.dex文件。也就是： SourceCode(.java) — javac → Java Bytecode(.class) — Proguard → Optimized Java bytecode(.class) — Dex → Dalvik Optimized Bytecode(.dex) 在这之后，Google决定将这一系列的步骤合并成一步，于是推出了Jack &amp; Jill编译器，它可以将以上步骤缩减成一步，即： SourceCode(.java) — Jack &amp; Jill → Dalvik Optimized Bytecode(.dex) 然而Jack &amp; Jill的效果并不理想，于是2017年Google决定重新使用之前的这套Proguard工作流程，但这次，Google将dx编译器进行了优化，产生了一个新的编译器： D8。从Android Studio 3.1开始，D8成为了默认的dex编译器。 2. D8D8相对于Proguard而言，最大的变化就是Google优化了dx编译器，其工作流程是： 虽然工作流程得到了简化，但是此时由于新的编程语言：Kotlin的出现，使得Google不得不再次对于d8编译器进行改进和优化，于是就有了目前最主流常用的代码缩减优化编译器： R8。从Android Studio 3.4或Android Gradle 3.4.0开始，默认使用R8编译器进行缩减优化，其使用方法和proguard通用，都是通过proguard-rules.pro这个文件来声明编译规则并执行。 3. R8首先是R8的工作流程图： R8同时支持Java和Kotlin代码，通过Google提供的一系列测试（https://android-developers.googleblog.com/2018/11/r8-new-code-shrinker-from-google-is.html）可以看出，R8比不仅在编译时间上远快于Proguard将近一半，在生成的apk文件大小上也稍小于Proguard。这也就是为什么Google现在将R8作为默认的编译器的原因。下面我们就来看一下关于R8编译器在使用上的一些说明。 4. How to use R8 complier启用R8编译器首先启用R8编译器，需要在project根目录下的build.gradle加入： 123456789101112131415161718192021android { buildTypes { release { // Enables code shrinking, obfuscation, and optimization for only // your project's release build type. minifyEnabled true // Enables resource shrinking, which is performed by the // Android Gradle plugin. shrinkResources true // Includes the default ProGuard rules files that are packaged with // the Android Gradle plugin. To learn more, go to the section about // R8 configuration files. proguardFiles getDefaultProguardFile( 'proguard-android-optimize.txt'), 'proguard-rules.pro' } } ...} 其中minifyEnabled用于启用代码缩减，混淆处理和优化，shrinkResources用于启用资源缩减， proguard-android-optimize.txt是Gradle PlugIn里面默认的处理规则文件，而proguard-rules.pro则是项目根目录下在创建时Android Studio自动生成的自定义处理规则文件。当需要添加一系列自定义规则时，只需要在项目根目录下的proguard-rules.pro中添加即可。 添加单独模块的proguard规则文件对于一个多模块的项目，各个模块可以声明自己独立的proguard规则文件proguard-rules.pro在模块的根目录下，并在模块的build.gradle中加入如下内容： 123456789101112131415android { buildTypes { release { minifyEnabled true proguardFiles getDefaultProguardFile( 'proguard-android-optimize.txt'), 'proguard-rules.pro' // Using module ProGuard rules files and add it into any module which // is dependent on this module consumerProguardFiles 'proguard-rules.pro' } } ...} 简单来说，如果一个Library Module被App Module所依赖，那么通过在library module中声明consumerProguardFiles属性，app module就会将自己根目录下的proguard-rules.pro和library module的proguard-rules.pro合并作为代码缩减，混淆等处理的规则来运行。 自定义Proguard-rules.pro规则default默认（R8 complier已启用）在proguard-rules.pro文件中，最常用的是一系列-keep相关的规则。它主要是用于规定对于类（class）和类的成员（members）是否要进行缩减，混淆的操作。当没有自定义规则，也就是默认状态下，缩减和混淆都是开启的，也就是： 此时，R8会对这个类进行缩减（remove unused code）和混淆（rename things）操作。 -keep class当在proguard-rules.pro中声明：-keep class com.foo.library.** { *; }时，R8对类和类成员的所有操作都会被禁止。也就是： 要注意这种情况非常不推荐，因为它禁止了所有对于这个类的操作。事实上在实际情况中总是可以选择性的进行一些需要的操作的，而这些“选择性”就是由下面的特殊的-keep规则来实现的。 -keepclassmemberskeepclassmembers会禁止R8对类成员的操作，但允许对类本身进行缩减和混淆： 也就是说，如果这个类本身没有被使用，它会被删掉；如果它被使用了，则会将其重命名（混淆处理），而对于其中的类成员没有任何操作。 -keepnameskeepnames的逻辑很简单：只检查是否有没有被使用的类或类成员，如果有的话则删掉它们。但不进行任何重命名混淆操作。 -keepclassmembernameskeepclassmembernames的逻辑也很简单：检查没有被使用的类和类成员，删掉没有用的，然后对类名进行重命名，但保留类成员的名字不变。 其他常用规则命令-verbose：打印详细的混淆信息； -dontnote com.foo.bar.**：不打印foo.bar包内的notes信息**，例如typo或者missing useful options； -dontwarn com.foo.bar.**：不打印foo.bar包内的warning信息，轻易不推荐使用； -dontpreverify：不进行检查校验，主要针对使用Java Micro Edition或Java 6+版本的Java Library需要进行检查校验，对于安卓平台上运行的Library来说可以添加这个规则来加快编译速度； -keepclasseswithmembers：和-keep基本一致，唯一的区别就是它只作用于存在类成员的类，例如keep所有含有main method的Application Class； -keepclasseswithmembersnames：同理，和-keepnames的唯一区别也是它只作用于存在类成员的类； -printusage[filename]：在standard output或者文件中打印出所有被缩减的内容； -keepattributes[attribute_filter]：禁止重命名class中的参数（attributes），比如使用第三方library时要禁止混淆Exceptions， InnerClasses和Signature；打印stack trace的时候要禁止混淆SourceFiles和LineNumberTable等； -dontusemixedcaseclassnames：进行混淆时不同时使用大小写来重命名。 参考文章Proguard Offical Document 代码缩减Google官方说明文档 Android Journey: Proguard, D8, R8 what are they? Distinguishing between the different ProGuard “-keep” directives Proguard的使用","link":"/2020/11/04/ProGuard/"},{"title":"RxJava基础概念梳理","text":"Reactive programming这个概念我在最近的安卓开发中极其频繁的接触到，但是对于从没有接触过的我来说，很多概念还是有点抽象和难以理解。所以这篇博客就来梳理一下在进行了一些了解和学习后，关于所谓“响应式编程”的我自己的理解。这里的例子主要都是应用于RxJava中，但实际上在稍微接触了RxSwift以及RxCocoa之后，我认为它们的基本概念都是相同的，所以了解RxJava之后，RxSwift和RxCocoa就完全不在话下。 The 3 O’s如果你熟悉设计模式中的观察者模式， 那么简单来说，Rxactive programming就是一种更为复杂和多样的观察者模式的应用。首先要介绍的，就是在RxJava中出于最核心部分的三个概念： Observable， Observer和Operator，简称 the 3 O’s。 ObservableObservable直译就是”可被观察的“，我认为可以把它理解成一种”数据源“，就是源源不断的产生数据的”工厂“。通常当我们需要任何数据时，我们都可以创建一个Observable实例并在其中声明产生数据的方法，比如网络请求，进行复杂运算，或等待用户输入等等。当需要获取对应数据时，它会依次发送出需要的数据，形成数据流，并被Observer依次获取。 创建一个Observable的方法有很多，最基础的方法就是使用Observable.create()方法并传入一个Observable.OnSubscribe实例，例如： 12345678Observable&lt;Integer&gt; observable = Observable.create(new Observable.OnSubscribe&lt;Integer&gt;() { @Override public void call(Subscriber&lt;? super Integer&gt; subscriber) { subscriber.onNext(1); subscriber.onNext(2); subscriber.onNext(3); subscriber.onCompleted(); }}); 在这个例子中，observable会依次发送1，2，3三个值，然后声明自己完成发送并结束。这里需要注意的是，如果不执行onCompleted()方法，那么Observable就会被认定依旧运行，这个对象也不会被回收直至一个onCompleted()或者onError()方法被执行或者observable本身被销毁（会存在内存泄漏的问题）。并且Observable在没有任何observer订阅时，不会发送任何数据。 为了更加方便的创建observable，RxJava又为我们提供了一些快速创建的方法，比如创建一个和上边一样的observable，也可以使用如下代码： 1Observable.just(1,2,3); 通过这种方式，我们可以更加快速直观的创建一个Observable并且看到需要发送的数据，但是这仅适用于发送简单数据的情况。 Observer说完Observable，下面就是对应的“观察者”Observer了。顾名思义，observer就是数据的“接收方”，也就是对于接收数据进行响应的对象。相比于Observable，observer的使用方法更为简单，我们只需要创建一个继承Observer接口：onNext(), onComplete()和onError()的实例，然后执行observable.subscribe()订阅方法并将observer传入即可。例如： 1234567891011121314151617181920// 创建ObserverObserver&lt;Object&gt; observer = new Observer&lt;Object&gt;() { @Override public void onCompleted() { Log.d(\"Test\", \"In onCompleted()\"); } @Override public void onError(Throwable e) { Log.d(\"Test\", \"In onError()\"); } @Override public void onNext(Object s) { Log.d(\"Test\", \"In onNext():\" + integer); } };// Observable订阅Observerobservable.subscribe(observer); 通过subscribe()的方法进行订阅后，observer就可以直接接收到所有从observable发出的数据，不仅十分方便，代码也十分直观。 Operator相比于Observable和Observer，Operator更像一个辅助性的“中间商”。它负责处理observable传递过来的原始数据，将其转化（transform &amp; polish）成observer需要的数据类型，再传给订阅的observer。通过这种方式，可以让数据类型的转换更为方便快捷，整体的代码也更为清晰明了。常用的一些operator方法包括： map()：对于每个数据都执行一个对应的function，执行结果与原数据一一对应并输出； flatMap()：对于每个数据都执行一个对应的function，执行结果全部存入一个Observable并输出（flat意思就在于此），相当于一对多的对应关系； groupBy()：对于每个数据源按grouping rule进行mapping，结果按不同group存入不同observable，最终输出observable set； filter：顾名思义，按照某种条件对其进行筛选并将符合筛选条件的数据输出。 所有build-in operator可以在这里找到，里面也有十分详尽的对于每个operator作用的介绍，关于Operator更为详细的介绍，以后会专门在写一篇文章，这里不再赘述。 综合上面对于三个基本概念的介绍，我们可以知道，Reactive Programming主体逻辑的流程图大致就是： Multi-threading首先要说明的是，RxJava本身在不声明任何scheduler时是默认单线程运行的，但实际使用时很多时候我们都需要在不同线程上去进行数据的产生和传递，这是就需要用到它的多线程(Multi-threading)特性。RxJava的多线程控制主要由两个方法来决定：subscribeOn() 和observeOn()。 subscribeOn()subscribeOn()这个方法用于指定Emitter（Observable，Single，Flowable等等）在哪一个thread上运行并产生数据，它的具体声明位置对于代码的执行没有任何影响，无论声明的先后顺序。举个例子： 123456Observable.just(\"1\", \"2\", \"3\", \"4\", \"5\") .subscribeOn(Schedulers.computation()) .flatMap { value -&gt; Observable.just(value.toInt()) } .subscribe { print(it) } 123456Observable.just(\"1\", \"2\", \"3\", \"4\", \"5\") .flatMap { value -&gt; Observable.just(value.toInt()) } .subscribeOn(Schedulers.computation()) .subscribe { print(it) } 以上两段代码，它们在运行逻辑上没有任何区别，Observable都是在computation thread上运行。 obverseOn()observeOn()这个方法用于指定Observer在哪一个thread上去处理Observable传递出来的数据，它只对当前声明位置下方的代码产生影响，换个方式来说，当代码执行到obverseOn()时，会切换线程并继续执行后面的逻辑。例如： 12345678Observable.just(\"1\", \"2\", \"3\", \"4\", \"5\") .observeOn(Schedulers.computation()) // 切换到 computation thread .flatMap { value -&gt; Observable.just(value.toInt()) } // computation thread上执行 .observeOn(Schedulers.io()) // 切换到 io thread .map { value -&gt; value * value } // io thread上执行 .subscribe { print(it) // io thread上执行 } Scheduler从上面的例子可以看出，subscribeOn()和observeOn()这两个方法都是通过传入Scheduler的类型作为参数来保证数据的产生，处理和接收都发生在对应的thread里的。那么Scheduler的类型都有哪些呢？这里就列举了一些Android平台上最为常用的Scheduler类型以及对应的适用情况： Scheduler.io() 最常使用的一种scheduler，主要用于处理IO操作例如网络请求，文件读写操作； Scheduler.computation() 处理与计算相关的操作，数量上限等同于处理器内核的数量； Scheduler.newThread() 创建一个新的scheduler，要尽量避免创建过多scheduler，尽量多使用已经存在的线程； Scheduler.single() 在一个独立的单线程处理操作，类似于一个后台独立的main thread； Scheduler.trampoline() 用于即时处理操作，它会立刻开始并严格按顺序处理所有当前线程上的Observable； AndroidSchedulers.mainThread() 安卓的主UI thread，必须注意不要让它被费时间，有延时的操作block住，否则会ANR。 Emitter除了Observable这个“数据源工厂”，RxJava还有许多其他的类型，它们被统称为Emitter，也就是“发射器“。它们都是产生数据或者获得数据的来源，但是不同的类型又有一些不同的特性，在这里列出几种除了Observable以外常用的Emitter类型： FlowableFlowable和Observable的用法几乎一摸一样，唯一的区别在于Flowable可以处理Backpressure的情况。所谓Backpressure，就是当Emitter的数据产生的速度过快，而Observer接收端处理数据的速度过慢时，数据会堆积在Emitter的memory里等待发送，累积到一定程度时就会抛出OutOfMemoryException异常。 Flowable通过使用BackpressureStrategy.DROP的策略，也就是在memory即将存满时丢弃一些数据的方法，来处理backpressure的问题。Observable也可以通过observable.toFlowable(BackpressureStrategy.DROP)的方法转换为Flowable来进行使用。 SingleSingle是一个非常简单的发射器，顾名思义，它仅在获取并发射一个单独的数据实例之后便结束发送。如果数据获取并发送成功，运行onSuccess()；发送失败的话则运行onError()。这种类型在我们返回单个数据时十分实用。Single的示例代码： 12345Single.just(\"This is a single\") .subscribe( { v -&gt; print(\"value is $v\") }, { e -&gt; print(\"error is $e\") } ) MaybeMaybe和Single类似，其区别在于：Maybe有可能不发送任何数据就结束发送。这种类型主要用于获取一些optional的数据时使用，因为它可能存在，也可以不存在。如果数据获取并发送成功，运行onSuccess()；发送失败的话，运行onError()；而没有获得数据的话则运行onComplete()。这种类型在我们返回单个optional数据时十分实用。Maybe的示例代码： 123456Maybe.just(\"This is a single\") .subscribe( { v -&gt; print(\"value is $v\") }, { e -&gt; print(\"error is $e\") }, { print(\"Completed\") } ) Completable相比于其他所有的Emitter的最大区别就是：它不发射数据，而是仅关心操作是否成功完成。如果成功完成，运行onComplete()，如果失败，则运行onError()。Completable就像是RxJava版的Runnable，可以通过addThen()方法进行连接并执行。同时，上面列举出的所有发射器类型，都可以通过例如Completable.fromSingle(Single.just(&quot;this is single&quot;))的方式转换为Completable并串联其他Completable进行运行。Completable示例代码： 1234567891011Completable.create { emitter -&gt; emitter.onComplete() emitter.onError(Exception())}Completable .fromSingle(Single.just(\"This is a single\")) .subscribe( { print(\"complete!\") }, { print(\"error!\") } ) Subject前面说到，Operator主要用于对传送数据进行处理和转化。但是对于一些实际使用场景来说，operator还是不够灵活。于是RxJava又提供了Subject这个类型来让我们更近灵活地进行数据的传输。 A Subject is a sort of bridge or proxy that is available in some implementations of ReactiveX that acts both as an observer and as an Observable. 上面是官方文档关于Subject的解释，简单来说Subject就像是一个连接不同Observable和Observer的”桥梁“。它既可以作为Observable来发送数据，也可以作为Observer来接收数据。通过Subject，我们可以将任意Observable的数据进行接收，处理，并再次发送给其他Observer。关于Subject，其实RxJava里还有许多其他的类型。这里只列举最为常用的四种类型，其余类型会在以后碰到时补充更新在这里： PublishSubject比较简单的一种Subject类型，会在subscription之后将所有数据依次发送。值得注意的是：PublishSubject会在初始化后立刻开始发送数据，而不是有Observer subscribe之后发送，所以会存在observer接收数据不完整的情况。对于这种情况，ReactiveX给出了两种方式解决：1. 使用Create()方法并在初始化前确认observer已经完成订阅；2.使用下面要介绍到的ReplaySubject。 BehaviourSubject相比于PublishSubject，BehaviourSubject最大的特点就是：它会发送Subscription之前的最后一个数据（last emitted data）以及Subscription之后将所有数据。除此之外，它和PublishSubject的特点基本一致。 ReplaySubjectReplaySubject会发送Observable产生的全部数据，无论是subscription之前还是之后。其内部就是用一个List动态存储所有接收的数据，并在subscription时发送给Observer。这也就是上面说到的为什么可以使用ReplaySubject来确保Observer接收数据的完整性。 AsyncSubjectAsyncSubject仅会发送Observable产生的最后一个数据，无论是subscription之前还是之后。 总结这是关于RxJava的第一篇总结文章，主要介绍了一些比较基础的概念。之后会继续写一些没有涉及到的概念比如Subject，更多Operator的具体用法，以及比较RxJava和RxSwift的一些异同等等。Reactive programming是非常强大的工具，可以让我们更轻松的管理数据流并实现多线程的同步，希望这篇文章中的概念可以对于响应式编程有一个更清晰的理解，happy coding!。 参考文章ReactiveX 官方文档 Meet RxJava: The Missing Reactive Programming Library for Android Fundamentals of RxJava with Kotlin for absolute beginners Reactive X: RxJava Data Flows: Observable, Flowable, Single, Maybe and Completable RxJava/RxAndroid使用实践实例","link":"/2020/08/06/RxJava/"},{"title":"常用摄影构图总结","text":"刚开始接触摄影，在这里总结一下常用的九种简单易学的摄影构图方法，每一种都有不同的适用场景和范围，也会使照片产生不同的意境。这仅是一个总结归纳，做为日常摄影练习时的构图思路参考。 1. 三分构图 三分法是最常用的构图方法，要注意一下几点： 被摄主体占总画面的 1/3 或 2/3； 被摄主体处于四条分割线的交点（趣味中心点），右上 &gt; 右下 &gt; 左边两点； 风光摄影时，一般天空或地面其中一方 1/3，另一方 2/3 （看拍摄主体在哪儿）； 另一种容易混淆的三分法是指：前景，中景，远景的三分，与这里的三分法不同。 2. 引导线构图 引导线构图主要是利用画面中线条引导观众的目光，让目光汇聚到画面焦点。引导线包括水平线，竖直线，对角线，曲线，汇聚线，隐藏线，常用道路，墙壁，桥梁，河流，山谷等，通过使用引导线，可以增加场景深度和透视感，使场景感觉更真实和立体。 3. 框架型构图 框架型构图的主要思路就是：利用前景作为框架，引导观众视线至画面焦点，明确主体，同时通过框架可以过滤掉无关元素，使画面更有层次感。但使用框架构图时要注意被摄主体和框架间的比例，框架为主体服务，不要太复杂。一般来说树叶间隙、门框窗框、山石缝隙，高光暗影等都可以当做框架进行使用。 4. 中心构图 中心构图可以用来制造视觉中心点，使得画面主体清晰明确，体现视觉张力。对于建筑类拍摄来说，中心构图可以体现平衡性和建筑的稳定性，常用于正方形图片比例。 5. 对称构图 对称构图常用于方正的建筑或有水面倒影时，也可以用于双人的拍摄以展现势均力敌的感觉，形成一定程度的对称冲击感。更高阶的对称构图可以主动去寻找“大对称下的小不对称”，使画面更生动自然。 6. 三角构图 三角构图是将三个视觉中心连成一个三角形，可以是正三角，倒三角或者斜三角。因为三角形给人的感觉较为稳定，所以常用于建筑摄影和人像摄影。其中正三角，斜三角多用于古典，对称建筑，灵活的同时不失趣味感；而倒三角则多用于人像，运动，呈现比较动感的效果。 7. 对角线构图 对角线构图会将被摄主体放在尽可能靠近照片对角线的位置，从而引导观众的视线在对角线游移，使其更具有延伸感，更加活泼生动，富有动感，视角也更加开阔。常用于建筑，桥梁，道路等线条型主体。 8. 曲线构图 曲线构图常用于被摄主体呈S形曲线时，如河流，曲径，小溪，道路，楼梯等，从而表现出延伸感和空间感。在拍摄人像时则可以来体现女性的曲线美。 9. 垂直线构图 垂直线构图会将画面用竖直的线分割开来，常用于表现景物的高大和深度，如摩天大楼，瀑布，高大的树木等。竖直线的延伸感可以使画面紧凑且富有节奏感，同时画面有规律感，使人感觉整齐稳定。 参考资料九种最常用的构图法","link":"/2020/10/31/%E6%91%84%E5%BD%B1%E6%9E%84%E5%9B%BE/"},{"title":"Java Relection","text":"Java Reflection is a process of examining the runtime behavior of a class. This feature is also known as dynamic programming since all attributes, interfaces, constructors, fields and methods of a class can be inspecting and verifying during runtime. Futhurmore, we can instantiate new objects, invoke methods, and get or set field values using reflection as well. So let’s see what is reflection and how to use it in this post. What is Java Reflection Java reflection is the ability for a program to manipulate the values, metadata, properties, and functions of an object at runtime. When we creating a class in Java, it gives us an option to do introspection, which means the ability of a program to examine the type or properties of an object at runtime. A simple example of introspection is instanceof like: 1234Person p = new Student(); // at complie time, type of p is Person; at run time, type of p is Student!if (p instanceof Student) { p.study();} But introspection is only a way to kind of “check“ or “verify“ object type. Java reflection is something one step furthur: it can manipulate the object at runtime. How to use Java ReflectionNow let’s see how to use Java Reflection API with a sample case. Here we have a Studying inferface: 123public interface Studying { String study();} then we have an abstract class Student which implement this Studying interface： 1234567891011121314151617public abstract class Student implements Studying { public static String GENDER = \"male\"; private String name; public Student(String name) { this.name = name; } public String getName() { return name; } public void setName(String name) { this.name = name; }} and we have another interface Person: 123public interface Person { String walk();} Finally, we create a Master class which extends abstract class Student and implements interface Person: 123456789101112131415public class Master extends Student implements Person { public Master(String name) { super(name); } @Override public String walk() { return \"I'm walking!\"; } @Override public String study() { return \"I'm studying!\"; }} Now we are ready to ask Java reflection’s help to inspecting classes, constructor, fields and methods separately! Inspecting ClassesClass/Package NameTo inspect class name or package name, we can: use getClass() from the object; call Class.forName() and pass the full class name string; after get the Class object, call class.getPackage() to get the pakcage and then call package.getName(). 12345678910111213141516171819202122232425262728293031@Testpublic void givenObject_whenGetsClassName_thenCorrect() { Object master = new Master(\"arctos\"); Class&lt;?&gt; clazz = master.getClass(); assertEquals(\"Master\", clazz.getSimpleName()); assertEquals(\"com.arctos.sample.reflection.Master\", clazz.getName()); assertEquals(\"com.arctos.sample.reflection.Master\", clazz.getCanonicalName());}@Testpublic void givenClassName_whenCreatesObject_thenCorrect() { Class&lt;?&gt; clazz = null; try { clazz = Class.forName(\"com.arctos.sample.reflection.Master\"); assertEquals(\"Master\", clazz.getSimpleName()); assertEquals(\"com.arctos.sample.reflection.Master\", clazz.getName()); assertEquals(\"com.arctos.sample.reflection.Master\", clazz.getCanonicalName()); } catch (ClassNotFoundException e) { e.printStackTrace(); }}@Testpublic void givenClass_whenGetsPackageInfo_thenCorrect() { Object master = new Master(\"arctos\"); Class&lt;?&gt; masterClass = master.getClass(); Package pkg = masterClass.getPackage(); assertEquals(\"com.arctos.sample.reflection\", pkg.getName());} Note: getSimpleName() will return the basic name of class, getName() and getCanonicalName() will return the fully qualified name including package name; Class.forName(&quot;your_full_class_name&quot;) needs the full class name including package name, and it may throw ClassNotFoundException if the given class name is not found. Class ModifiersTo inspect class modifiers like public, final, volatile, abstract, we can use class.getModifiers() which returns an int flag and pass it to Modifier.isXXX() as an argument: 1234567891011121314151617@Testpublic void givenClass_whenRecognisesModifiers_thenCorrect() { try { Class&lt;?&gt; masterClass = Class.forName(\"com.arctos.sample.reflection.Master\"); Class&lt;?&gt; studentClass = Class.forName(\"com.arctos.sample.reflection.Student\"); int masterModifiers = masterClass.getModifiers(); int studentModifiers = studentClass.getModifiers(); assertTrue(Modifier.isPublic(masterModifiers)); assertFalse(Modifier.isFinal(masterModifiers)); assertTrue(Modifier.isAbstract(studentModifiers)); assertTrue(Modifier.isPublic(studentModifiers)); } catch (ClassNotFoundException e) { e.printStackTrace(); }} Note: getModifiers() will return an int flag which including all infos of this class’ modifier. Check the code inside java.lang.Modifier class and we can found all modifier checking is performed like (modifiers &amp; PUBLIC) != 0 which PUBLIC is just another static int constant. Super ClassWhen we have the class object, we can get the superclass by calling class.getSuperclass() 1234567891011121314@Testpublic void givenClass_whenGetsSuperClass_thenCorrect() { Master master = new Master(\"arctos\"); String str = \"any string\"; Class&lt;?&gt; masterClass = master.getClass(); Class&lt;?&gt; masterSuperClass = masterClass.getSuperclass(); assertEquals(\"Student\", masterSuperClass.getSimpleName()); assertEquals(\"com.arctos.sample.reflection.Student\", masterSuperClass.getCanonicalName()); assertEquals(\"String\", str.getClass().getSimpleName()); assertEquals(\"Object\", str.getClass().getSuperclass().getSimpleName()); assertNull(str.getClass().getSuperclass().getSuperclass());} Note: getSuperclass() will return a Class object, same as when we call object.getClass() or Class.forName(&quot;your_class_name&quot;); If there is no super class (such as Object class), null will be returned. Implemented InterfacesWe also can use getInterfaces() to retriece a list of classes that current class implements as interface: 1234567891011121314151617@Testpublic void givenClass_whenGetsImplementedInterfaces_thenCorrect() { try { Class&lt;?&gt; masterClass = Class.forName(\"com.arctos.sample.reflection.Master\"); Class&lt;?&gt; studentClass = Class.forName(\"com.arctos.sample.reflection.Student\"); Class&lt;?&gt;[] masterInterfaces = masterClass.getInterfaces(); Class&lt;?&gt;[] studentInterfaces = studentClass.getInterfaces(); assertEquals(1, masterInterfaces.length); assertEquals(1, studentInterfaces.length); assertEquals(\"Person\", masterInterfaces[0].getSimpleName()); assertEquals(\"Studying\", studentInterfaces[0].getSimpleName()); } catch (ClassNotFoundException e) { e.printStackTrace(); }} Note: getInterfaces() will only return all interfaces directly implements by this class. In code snippt above, Master class extends Student abstract class which implements Studying interface. But only studentClass.getInterfaces() will return Studying interface even if Master class also need to implement methods of that interface. In another word, it only returns interfaces that directly declared with implements keyword. Inspecting ConstructorAbove inspection are all class-level or class-related, now let’s go to constructor. Since Java only allow single constructor with same signature in one class, we will create a Bachelor class and adding three different constructors like: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public class Bachelor extends Student { private boolean graduated; /********************** * Constructor **********************/ public Bachelor() { super(\"unknown\"); } public Bachelor(String name) { super(name); } public Bachelor(String name, boolean graduated) { super(name); setGraduated(graduated); } /********************** * Static methods **********************/ private static boolean isBachelor() { return true; } private static String degreeName() { return \"Bachelor\"; } /********************** * Setter and Getter **********************/ public boolean isGraduated() { return graduated; } public void setGraduated(boolean graduated) { this.graduated = graduated; } /********************** * Implemented methods **********************/ @Override public String study() { return getStudyString(); } private String getStudyString() { return \"I'm \" + \"studying!\"; }} Now let’s first ensure it will gives use all three constructors: 123456789101112131415@Testpublic void givenClass_whenGetsAllConstructors_thenCorrect() { try { Class&lt;?&gt; bachelorClass = Class.forName(\"com.arctos.sample.reflection.Bachelor\"); Constructor&lt;?&gt;[] constructors = bachelorClass.getConstructors(); assertEquals(3, constructors.length); assertEquals(\"com.arctos.sample.reflection.Bachelor\", constructors[0].getName()); assertEquals(\"com.arctos.sample.reflection.Bachelor\", constructors[1].getName()); assertEquals(\"com.arctos.sample.reflection.Bachelor\", constructors[2].getName()); } catch (ClassNotFoundException e) { e.printStackTrace(); }} Then we can retrieve each of constructor by parameter types in order like: 123456789101112@Testpublic void givenClass_whenGetsEachConstructorByParamTypes_thenCorrect() { try { Class&lt;?&gt; bachelorClass = Class.forName(\"com.arctos.sample.reflection.Bachelor\"); Constructor&lt;?&gt; cons1 = bachelorClass.getConstructor(); Constructor&lt;?&gt; cons2 = bachelorClass.getConstructor(String.class); Constructor&lt;?&gt; cons3 = bachelorClass.getConstructor(String.class, boolean.class); } catch (ClassNotFoundException | NoSuchMethodException e) { e.printStackTrace(); }} Finally, we can use the constructor retrieved to instanciate new objects: 12345678910111213141516171819202122@Testpublic void givenClass_whenInstantiatesObjectsAtRuntime_thenCorrect() { try { Class&lt;?&gt; bachelorClass = Class.forName(\"com.arctos.sample.reflection.Bachelor\"); Constructor&lt;?&gt; cons1 = bachelorClass.getConstructor(); Constructor&lt;?&gt; cons2 = bachelorClass.getConstructor(String.class); Constructor&lt;?&gt; cons3 = bachelorClass.getConstructor(String.class, boolean.class); Bachelor bachelor1 = (Bachelor) cons1.newInstance(); // casting is required here Bachelor bachelor2 = (Bachelor) cons2.newInstance(\"arctos\"); // casting is required here Bachelor bachelor3 = (Bachelor) cons3.newInstance(\"arctos li\", true); // casting is required here assertEquals(\"unknown\", bachelor1.getName()); assertFalse(bachelor1.isGraduated()); assertEquals(\"arctos\", bachelor2.getName()); assertFalse(bachelor2.isGraduated()); assertEquals(\"arctos li\", bachelor3.getName()); assertTrue(bachelor3.isGraduated()); } catch (ClassNotFoundException | NoSuchMethodException | IllegalAccessException | InstantiationException | InvocationTargetException e) { e.printStackTrace(); }} Note: constructor.getName() will return fully qualified name including package name together; class.getConstructor() will throw NoSuchMethodException if parameters are not matching, the order of parameters also need to be correct; since getConstructor() will return a ? type of constructor, type casting is required to instanciate new objects, otherwise it will be Object at complie time (in this case it still will be Bachelor at runtime, but casting still required). constructor.newInstance() will throw IllegalAccessException, InstantiationException, and InvocationTargetException. They all needs to be handled. Inspecting FieldsFor class fields, we can retrieve it, check the name, type, and even modify the value. Now let’s see how to do this. To get all available public fields of a class or search a public field by field name, we can use getFields() or getField({field_name_string}): 123456789101112131415161718192021222324@Testpublic void givenClass_whenGetsPublicFields_thenCorrect() { try { Class&lt;?&gt; bachelorClass = Class.forName(\"com.arctos.sample.reflection.Bachelor\"); Field[] fields = bachelorClass.getFields(); assertEquals(1, fields.length); assertEquals(\"GENDER\", fields[0].getName()); } catch (ClassNotFoundException e) { e.printStackTrace(); }}@Testpublic void givenClass_whenGetsPublicFieldByName_thenCorrect() { try { Class&lt;?&gt; bachelorClass = Class.forName(\"com.arctos.sample.reflection.Bachelor\"); Field field = bachelorClass.getField(\"GENDER\"); assertEquals(\"GENDER\", field.getName()); } catch (ClassNotFoundException | NoSuchFieldException e) { e.printStackTrace(); }} To get private fields with the class, we can use getDeclaredFields() or getDevlaredField({field_name_string}): 123456789101112131415161718192021222324@Testpublic void givenClass_whenGetsDeclaredFields_thenCorrect() { try { Class&lt;?&gt; bachelorClass = Class.forName(\"com.arctos.sample.reflection.Bachelor\"); Field[] fields = bachelorClass.getDeclaredFields(); assertEquals(1, fields.length); assertEquals(\"graduated\", fields[0].getName()); } catch (ClassNotFoundException e) { e.printStackTrace(); }}@Testpublic void givenClass_whenGetsDeclaredFieldByName_thenCorrect() { try { Class&lt;?&gt; bachelorClass = Class.forName(\"com.arctos.sample.reflection.Bachelor\"); Field field = bachelorClass.getDeclaredField(\"graduated\"); assertEquals(\"graduated\", field.getName()); } catch (ClassNotFoundException | NoSuchFieldException e) { e.printStackTrace(); }} Then when we have the Field object, we can use getType() to get the class of field type like: 123456789101112@Testpublic void givenClass_whenGetsFieldType_thenCorrect() { try { Class&lt;?&gt; bachelorClass = Class.forName(\"com.arctos.sample.reflection.Bachelor\"); Field field = bachelorClass.getDeclaredField(\"graduated\"); Class&lt;?&gt; fieldClass = field.getType(); assertEquals(\"boolean\", fieldClass.getName()); } catch (ClassNotFoundException | NoSuchFieldException e) { e.printStackTrace(); }} Finally let’s see how can we modify fields inside the class or public in superclass: 123456789101112131415161718192021222324252627282930313233343536373839@Testpublic void givenClassField_whenSetsAndGetsValue_thenCorrect() { try { Class&lt;?&gt; bachelorClass = Class.forName(\"com.arctos.sample.reflection.Bachelor\"); Bachelor bachelor = (Bachelor) bachelorClass.getConstructor().newInstance(); Field field = bachelorClass.getDeclaredField(\"graduated\"); field.setAccessible(true); // set it to be accessible so we can modify it in below assertEquals(false, field.get(bachelor)); // pass object to get() method to retrieve the value assertFalse(field.getBoolean(bachelor)); assertFalse(bachelor.isGraduated()); field.set(bachelor, true); // to set value of field, we need pass object and the new value assertEquals(true, field.get(bachelor)); assertTrue(field.getBoolean(bachelor)); assertTrue(bachelor.isGraduated()); } catch (ClassNotFoundException | NoSuchMethodException | IllegalAccessException | InstantiationException | InvocationTargetException | NoSuchFieldException e) { e.printStackTrace(); }}@Testpublic void givenClassField_whenGetsAndSetsWithNull_thenCorrect() { try { Class&lt;?&gt; bachelorClass = Class.forName(\"com.arctos.sample.reflection.Bachelor\"); Field field = bachelorClass.getField(\"GENDER\"); field.setAccessible(true); // set it to be accessible so we can modify it in below assertEquals(\"male\", field.get(null)); // pass null as instance of class parameter field.set(null, \"female\"); assertEquals(\"female\", field.get(null)); } catch (ClassNotFoundException | IllegalAccessException | NoSuchFieldException e) { e.printStackTrace(); }} Note: getFields() or getField({field_name_string}) will retrieve all public fields defined in the class and all superclasses; getDeclaredFields() or getDevlaredField({field_name_string}) will retrieve all public and private fields defined in the class, nothing from superclass; both getField({field_name_string}) and getDevlaredField({field_name_string}) will throw NoSuchFieldException if given field name is wrong or not found; field.setAccessible(true) needs to be called before modify any private field; field.getBoolean(object) will return a boolean object but field.get(obj) will return a generic object, that’s the only difference; for static fields, only need pass null as the instance of class parameter will be fine. Inspecting MethodsThe last thing we want to inspecting is class methods, by using Java reflection, we can retrieve all methods of a class or invoke it with parameters at runtime. So let’s start from retrieve all public methods or declared methods: 1234567891011121314151617181920212223242526272829@Testpublic void givenClass_whenGetsAllPublicMethods_thenCorrect() { try { Class&lt;?&gt; bachelorClass = Class.forName(\"com.arctos.sample.reflection.Bachelor\"); Method[] methods = bachelorClass.getMethods(); List&lt;String&gt; methodNames = getMethodNames(methods); assertTrue(methodNames.containsAll(Arrays .asList(\"equals\", \"notify\", \"notifyAll\", \"hashCode\", \"toString\", \"getClass\", \"study\", \"isGraduated\", \"setGraduated\", \"getName\", \"setName\"))); } catch (ClassNotFoundException e) { e.printStackTrace(); }}@Testpublic void givenClass_whenGetsOnlyDeclaredMethods_thenCorrect() { try { Class&lt;?&gt; bachelorClass = Class.forName(\"com.arctos.sample.reflection.Bachelor\"); List&lt;String&gt; actualMethodNames = getMethodNames(bachelorClass.getDeclaredMethods()); List&lt;String&gt; expectedMethodNames = Arrays.asList(\"study\", \"isGraduated\", \"setGraduated\", \"getStudyString\", \"isBachelor\", \"degreeName\"); assertEquals(expectedMethodNames.size(), actualMethodNames.size()); assertTrue(expectedMethodNames.containsAll(actualMethodNames)); assertTrue(actualMethodNames.containsAll(expectedMethodNames)); } catch (ClassNotFoundException e) { e.printStackTrace(); }} Similar to fields, private methods need to set accessible flag to true before invoke: 123456789101112@Testpublic void givenMethodName_whenGetsMethod_thenCorrect() throws Exception { Bachelor bachelor = new Bachelor(); Method getStudyStringMethod = bachelor.getClass().getDeclaredMethod(\"getStudyString\"); assertFalse(getStudyStringMethod.isAccessible()); getStudyStringMethod.setAccessible(true); // set it to be accessible so we can invoke it in below assertTrue(getStudyStringMethod.isAccessible()); assertEquals(\"I'm studying!\", getStudyStringMethod.invoke(bachelor));} Finally, we can pass parameter in invoke method as well: 123456789101112131415161718192021222324252627282930313233343536373839@Testpublic void givenMethod_whenInvokes_thenCorrect() { try { Class&lt;?&gt; bachelorClass = Class.forName(\"com.arctos.sample.reflection.Bachelor\"); Bachelor bachelor = (Bachelor) bachelorClass.getConstructor().newInstance(); Method isGraduatedMethod = bachelor.getClass().getDeclaredMethod(\"isGraduated\"); Method setGraduatedMethod = bachelor.getClass().getDeclaredMethod(\"setGraduated\", boolean.class); boolean graduated = (boolean) isGraduatedMethod.invoke(bachelor); assertFalse(graduated); assertFalse(bachelor.isGraduated()); setGraduatedMethod.invoke(bachelor, true); boolean graduated2 = (boolean) isGraduatedMethod.invoke(bachelor); assertTrue(graduated2); assertTrue(bachelor.isGraduated()); } catch (ClassNotFoundException | NoSuchMethodException | IllegalAccessException | InstantiationException | InvocationTargetException e) { e.printStackTrace(); }}@Testpublic void givenMethod_whenInvokesWithNull_thenCorrect() { try { Class&lt;?&gt; bachelorClass = Class.forName(\"com.arctos.sample.reflection.Bachelor\"); Bachelor bachelor = (Bachelor) bachelorClass.getConstructor().newInstance(); Method isBachelorMethod = bachelor.getClass().getDeclaredMethod(\"isBachelor\"); Method degreeNameMethod = bachelor.getClass().getDeclaredMethod(\"degreeName\"); isBachelorMethod.setAccessible(true); // set it to be accessible so we can invoke it in below degreeNameMethod.setAccessible(true); // set it to be accessible so we can invoke it in below assertTrue((boolean)isBachelorMethod.invoke(null)); assertEquals(\"Bachelor\", degreeNameMethod.invoke(null)); } catch (ClassNotFoundException | NoSuchMethodException | IllegalAccessException | InstantiationException | InvocationTargetException e) { e.printStackTrace(); }} Note: class.getMethods() will retrieve all public methods defined in the class and all superclasses; class.getDeclaredMethods() will retrieve all public and private methods defined in the class, nothing from superclass; method.setAccessible(true) needs to be called before invoke any private methods; for static methods, just same as static field, pass a null object as parameter to invoke will be fine. Useful linkAll codes snippets in this post can be find in here Guide to Java Reflection Type Introspection Wikipedia 关于Java中的反射","link":"/2020/11/15/JavaReflection/"}],"tags":[{"name":"Kotlin","slug":"Kotlin","link":"/tags/Kotlin/"},{"name":"Android Architecture","slug":"Android-Architecture","link":"/tags/Android-Architecture/"},{"name":"English","slug":"English","link":"/tags/English/"},{"name":"Chinese","slug":"Chinese","link":"/tags/Chinese/"},{"name":"Multi-thread","slug":"Multi-thread","link":"/tags/Multi-thread/"},{"name":"Android UI","slug":"Android-UI","link":"/tags/Android-UI/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"Clean Code","slug":"Clean-Code","link":"/tags/Clean-Code/"},{"name":"Gradle","slug":"Gradle","link":"/tags/Gradle/"},{"name":"SDK","slug":"SDK","link":"/tags/SDK/"},{"name":"Clean Architecture","slug":"Clean-Architecture","link":"/tags/Clean-Architecture/"},{"name":"Dagger","slug":"Dagger","link":"/tags/Dagger/"},{"name":"Lambda","slug":"Lambda","link":"/tags/Lambda/"},{"name":"Proguard","slug":"Proguard","link":"/tags/Proguard/"},{"name":"RxJava","slug":"RxJava","link":"/tags/RxJava/"},{"name":"摄影构图","slug":"摄影构图","link":"/tags/%E6%91%84%E5%BD%B1%E6%9E%84%E5%9B%BE/"},{"name":"Java Reflection","slug":"Java-Reflection","link":"/tags/Java-Reflection/"}],"categories":[{"name":"Technical","slug":"Technical","link":"/categories/Technical/"},{"name":"Android","slug":"Technical/Android","link":"/categories/Technical/Android/"},{"name":"Reading","slug":"Technical/Reading","link":"/categories/Technical/Reading/"},{"name":"Kotlin","slug":"Technical/Kotlin","link":"/categories/Technical/Kotlin/"},{"name":"摄影","slug":"摄影","link":"/categories/%E6%91%84%E5%BD%B1/"},{"name":"Java","slug":"Technical/Java","link":"/categories/Technical/Java/"},{"name":"构图","slug":"摄影/构图","link":"/categories/%E6%91%84%E5%BD%B1/%E6%9E%84%E5%9B%BE/"}]}