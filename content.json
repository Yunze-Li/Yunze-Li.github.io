{"pages":[{"title":"tags","text":"","link":"/tags/index.html"}],"posts":[{"title":"Android开发笔记之基础篇（一）","text":"因为最近开始系统地学习Android开发，所以在这里记录一下所学到的Android内容做一个整理。既算是对已学到知识的总结和梳理，也可以检查自己理解中出现的问题，和大家共同讨论一下。因为是第一次写东西，所以有什么不详细，不清楚，不准确的地方，还希望可以指正，我们共同讨论，共同进步。 本篇文章大部分的内容都是基于自己通过Google官方说明文档，StackoverFlow, CSDN等网站的阅读获得的，希望通过我个人的理解，让这些知识更容易被读者所理解和接受。 Application Components进入Andorid的第一个需要理解的知识，也是我个人认为最为重要的基础知识之一，就是了解Android app的架构。构成一个完整安卓APP的，是各种各样不同的Component（组件），这些Component分别承担着不同的工作和职责，比如负责与用户进行交互的Activity，负责后台相关工作的Service，以及负责监听传递信息的BoardcastReceiver等等。我们用一个简单的例子来解释一下：如果说现在需要做一个负责计算汇率转换的Android应用，首先Application指的就是这个App本身；要实现汇率转换的功能，我们就需要一个让用户输入金额大小，选择转换货币类别的界面，这就是CurrencyConvertActivity，在其中定义了一切关于UI的逻辑；如果我们想在后台服务器存储当前的汇率数据信息，那么就需要一个NetworkService来随时向服务器发送请求获取当前最新的汇率信息并交给CurrencyConvertActivity来计算并显示；如果我们想加入一个自动识别当前国家并显示该国家货币的功能，就需要建立一个CountryChangeReceiver来监听一个叫做TIMEZONE_CHANGED的event（系统事件）并在监听到切换国家/时区时进行识别。现在整个Application的架构大致就是这样： 123456789101112131415161718192021222324252627&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; package=&quot;com.yunze.myapplication&quot;&gt; &lt;application android:allowBackup=&quot;true&quot; android:icon=&quot;@mipmap/ic_launcher&quot; android:label=&quot;@string/app_name&quot; android:roundIcon=&quot;@mipmap/ic_launcher_round&quot; android:supportsRtl=&quot;true&quot; android:theme=&quot;@style/AppTheme&quot;&gt; &lt;activity android:name=&quot;com.yunze.myapplication.CurrencyActivity&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt; &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;service android:name=&quot;.BackendService&quot;&gt; &lt;intent-filter /&gt; &lt;/service&gt; &lt;receiver android:name=&quot;.CountryChangeReceiver&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.TIMEZONE_CHANGED&quot; /&gt; &lt;/intent-filter&gt; &lt;/receiver&gt; &lt;/application&gt;&lt;/manifest&gt; 上面显示的这个AndroidManifest.xml，可以理解为一个Android Application的“骨架”。正如我们之前所说，Activity，Service以及Broadcast Receiver可以算是Android Application的三个“组件”，而Manifest.xml文件则正是申明这个App所使用的所有组件的地方，所以当我们开始深入的看一个安卓项目时，应该要从AndroidManifest.xml开始看起，才能比较详尽全面地了解这个App。 Activity vs BoardcastReceiver vs Service下面具体来比较一下不同的Component之间的关系，让我们有更进一步的了解。 Activity：整个Android开发中最为重要的一个概念。Acitivity中定义了App与用户的交互逻辑，例如当用户点击当前这个按钮，应该发生什么事，是显示一个文本框，更改图片的颜色，或者关闭当前界面回到上一个界面等等。可以说：所有关于用户交互的逻辑全部都只能定义和存在与Activity之中。 Service：如果我们的APP中需要一个长时间运行在后台来处理业务的功能，比如频繁向服务器发送请求，或者需要等待服务器随时返回请求，或者要长时间从服务器加载大型文件（比如在线浏览视频），此时就需要用到我们的Service组件。Service组件最重要的特征就是：可以长时间的运行在后台进行服务，直到完成任务后将自己结束，并且其中不能定义任何与用户UI有关的内容。 Broadcast Receiver: 这可能是三个组件中比较不常用的一个，也是不太好理解的一个。为了方便理解，可以把它想象成：APP的一根“天线”，它的功能就是主动接受其他APP传来的特定“信号”。比如我们之前说的TIMEZONE_CHANGED这个event，当安卓系统检测到用户手机切换了时区时，就会向全系统内广播这个TIMEZONE_CHANGED event，此时如果我们的APP中含有一个注册了TIMEZONE_CHANGED的BroadcastReceiver，那么这个receiver就会被触发并完成一系列我们定义好的逻辑。 这里要稍微说一下BroadcastReceiver与Service的区别，它们都是运行在后台，不带有任何UI的组件。但是Service作为消息的接收方是只能被单独触发的，而不同的BoardcastReceiver却是可以被一起触发的，前提就是它们都注册了同一个event。下面是在看他人的总结介绍时看到的一张很有意思的图： 从这张图上来看，有几点值得我们特别注意的： 只有Activity才可以启动一个新的Activity（理论上讲其实是有其他办法可以从Service和BoardcastReceiver中启动的，但是这里说的不是“能不能”，而是“是否应该”），当我们创建一个新的Android项目时，都会自动生成一个MainActivity，所有关于APP的行为和逻辑都应该在这个或者几个Activity内来完成，项目也会有一个Application类，这个类一般是作为各种Activity的容器来使用，不要轻易将代码逻辑写在Application里； 只有Activity才可以Layout Inflation。这个也比较好理解，因为前面说过，只有Activity才能处理和用户的交互，显示所有的UI和Layout（其实所有的UI都只能run在UI Thread，也就是Main Thread上，而只有Activity可以access到Main Thread，所以当然只有它可以处理UI的部分）。当然也是有Tricky way来做的，比如call runOnUiThread()之类的，这些也是留给之后再讲吧。 Broadcast Receiver所监听的Event一般来说是向全系统广播的一些事件，比如手机连接好了WIFI，手机外接了电源等等。当然也可以监听自定义的event，但是根据我们前面说的用途，自定义的情况比较少，毕竟没有必要只向自己的一个service或者activity进行广播。 这其中还提到了另一个组件：ContentProvider，这个还是之后讲，个人认为相比起其他三个，这个要稍微用得少一些，使用方法也相对简单一些。","link":"/2018/09/22/AndroidBasic1/"},{"title":"Android开发笔记之基础篇（二）","text":"在之前的基础篇(一)中主要讲到了一些关于Activity，Service，BoardcastRecevier的基本概念以及它们的异同。今天就来讲解一下关于Activity中UI部分的一些架构：主要就是Activity，Fragment，Dialog这三个不同的Component。 Activity在前面我们说到过，在Activity中定义了与用户交互的所有逻辑（Presentation Layer Logic）。举个例子，我们想做一个电话本管理的App，那么就需要设计当用户点击某个按钮时会发生什么，这些定义都包含在Activity中。那么，一个Application中可以包含多个Activity么？答案是可以的，而且是几乎必须的！想象一下在这个电话本管理的App中，我们可能会有基本的浏览电话本页面（Dashboard），当选中一个电话时，要显示一个详细联系人的页面；点击电话号码时，要弹出一个拨打电话的界面；在dashboard里要有一个“编辑”按钮，点击后弹出一个新建联系人界面等等。。。为了让我们的APP结构清晰易懂，我们一般会设计多个Activity来执行不同的功能，比如负责显示dashboard的DashboardAcitivity，显示详细联系人的ContactActivity，拨打电话界面的CallingAcitivitiy，已经添加联系人的AddContactActivity。正是因为多个Activity的存在，才使整个安卓App的架构变得十分清晰，也更有利于我们阅读，重构以及debug。 一般来说，在一个Activity中，我们会采用MVP（Model-View-Presenter）来设计代码（MVP是一个我个人非常喜欢的design pattern，在Android Development中也十分常见，会在以后讲到它的具体概念和实现）。对于不同的Activity，出于解耦（De-coupling）的考虑，通常将它们放入不同的package中，方便对它们分别进行重构或调用。像如上我们举例的电话App，它的结构大致就是这样： 在上一次我们说到，AndroidManifest这个文件里定义了所有App所需要的Activity，Service，BoardcastReceiver等等，所以不要忘记在创建完Activity之后，一定要在Manifest里面把它声明好，不然编译时是一定会报错的。 Fragment在说完Activity之后，我们要说一下Fragment这个重要的component。在各种Android的档案定义里，都会反复出现对于Fragment的定义：A Fragment represents a behavior or a portion of user interface in a FragmentActivity. You can combine multiple fragments in a single activity to build a multi-pane UI and reuse a fragment in multiple activities. 但是我一直就觉得这个解释非常不明确，为什么我们需要用Fragment呢？我个人的理解是：当在一个Activity内有多个单独显示的页面，并且每个页面与用户交互的逻辑都各不相同时，Fragment可以帮助我们减少很多麻烦，将整个Activity的架构变得十分清晰。还是以前面的MyPhoneActivity为例，在这个打电话场景中，可能会分为三个阶段：接收到来电（InComingCall），电话被接通（Calling），通话结束（CallEnded）。根据需求不同，这三个阶段可能会有完全不同的布局，按钮，每个按钮也会有不同的功能，但是它们同属于一个打电话的功能之中（DialingActivity），并且一般来说这三个界面的风格，背景也都基本相同。此时如果我们使用Activity，当然是可以的，这不仅意味着我们需要在各个activity之间传递各种各样的参数，而且整个DialingActivity会变得完全无法使用（因为Activity是不能有inner activity的）。此时就轮到Fragment出场了，我们可以在DialingActivity里定义三个Fragment：InComingCallFragment，CallingFragment以及CallEndedFragment，每个Fragment都可以有自己的model和presenter（也就是都可以使用MVP pattern）而在DialingActivity里，我们可以定义所有包含在其中的Fragment的共同行为。整个的结构大概是这样： Activity和Fragment都是关于UI部分的重要组件。一般来说对于比较大型的App来说，是需要多个Activity和多个Fragment来展示用户界面的。所以还是要多多设计和使用这些组件来熟悉。","link":"/2018/10/13/AndroidBasic2/"},{"title":"Android开发笔记之基础篇（三）","text":"今天的内容是这周工作中出现的一个相关内容的学习：都说在Android的开发中，多线程（Multi-thread）是非常重要的一环，那么我们就来看看和Android OS相关的Thread, Looper, Handler这几个组件各自的概念和实例。 ThreadThread(线程)本身是java.lang.Thread这个包里的非常基本的一个Class，它定义了一个java的线程。在Android的环境里，一个线程可以理解为一群任务的有序集合。当这个线程的任务全部执行结束时，线程就会被终止。那么，对于多线程来说，如何可以让一个线程不被中止，而是持续等待新的任务呢？我们可以在线程内这样： 123456789101112131415package com.example.yunzeli.testapplicationpublic class MyThread extends Thread { private boolean isRunning; @Override public void run() { isRunning = ture; while (isRunning) { // do some tasks here... // after finish the job isRunning = false; } }} 上面的代码很清晰，我们通过设置一个flag，可以用loop的方式来block住这个thread，然后等待新的任务到来。但是，Java代码库里给我们提供了一个更加简单清晰，并且可靠的工具，这就是Looper。 Looper从上面的内容我们知道，要想将一个线程block住，我们需要一个执行一个loop并不停的等待新的任务。在Android的开发包里，就有一个设计好的Looper类供我们使用。这个Looper一直在不停的循环并监听新来的task，每个Looper都有一个messageQueue用来存放分配的task，也叫做Message。关于MessageQueue的内容我们下面会讲到。Looper的使用有两个基本原则： 每一个Thread有且只能有一个Looper； 当想让某一个Thread执行某个任务时，就将message传送给对应Looper的messageQueue。 Looper在thread的具体使用方法如下： 12345678910111213141516package com.example.yunzeli.testapplicationimport android.os.Looperpublic class MyLooperThread extends Thread { @Override public void run() { // prepare the loop Looper.prepare(); // start looping Looper.loop(); // do your staff here... }} Looper.prepare()方法主要是检查当前这个thread是否已经分配好looper，如果没有，则新建一个looper来监听这个thread，而Looper.loop()则是当前的looper开始监听线程，之后就可以处理相应的message了。简而言之，Looper的作用就是一直looping并且keep thread alive。值得注意的是，MainThread，也就是UIThread，是已经初始化了MainLooper的。所以不需要对于MainThread进行任何的操作。 MessageQueue &amp; Handler说完了Looper，现在我们来说说Looper里面的一个重要组成部分：MessageQueue。当我们想向一个thread里派送一个新的task时，Java规定了我们只能派送如下两种类型：Message和Runnable。那么，我们如何将这两种类型的实例“派送”到thread的messageQueue里呢？这时就用到了Handler。Handler的功能相当于一个“配装器”，它可以将任意的Message或者Runnable放入其监听的Looper的messageQueue里，例如： 12345678910111213141516171819202122232425262728293031323334353637383940public class MyLooperThread extends Thread { private static final int MSG_1 = 1; private static final int MSG_2 = 2; @Override public void run() { // prepare the loop Looper.prepare(); // start looping Looper.loop(); // send message here Handler handler = new MyHandler(); handler.obtainMessage(MSG_1).sendToTarget(); handler.post(new Runnable() { @Override public void run() { // do something here... } }); } class MyHandler extends Handler { @Override public void handleMessage(Message message) { // switch your message type here switch(message.what) { case MSG_1: // do something here... break; case MSG_2： // do something here... break; default: } } }} 由上面例子可见，Hanlder通过obtainMessage(Message msg)的方法来传送message类型，用post(Runnable runable)的方法来传Runnable类型。那么，Handler如何知道所要传的Looper呢？其实Android官方文档里写的很清楚，Handler有两个default的constructor，如果使用new Handler()的话，则当前call这个constructor的thread的looper，就会成为这个handler的looper；如果使用new Handler(Looper looper)的话，则可以使用传入的looper作为handler的target。总结一下，Hanlder的作用主要就是两点： 从任意thread中将message或者runnable传入其对应的looper的message queue中； 获取其对应looper的message queue中的下一个task（message或runnable）并执行对应的操作。 需要强调的一点是：虽然一个thread只能有一个对应的looper，但是一个looper却可以同时被多个Handler所引用（允许将同一个Looper传入多个Handler的构造器）以便指定给同一thread的不同handler分别处理不同的message或者runnable。这样的设计也方便了我们对于多个task的处理。 Message &amp; Runnable最后关于Message和Runnable再简单介绍一下，当我们希望在一个thread里执行一段代码（task）时，Android OS 规定了这两种类型作为传入的参数。Message的使用方式在于：我们预先在Handler里定义好了如何处理这个MESSAGE_TYPE的逻辑，然后将对应的MESSAGE_TYPE传入。个人理解比较像是pre-define了一个处理逻辑，然后只需要传入对应message就可以trigger这个task；而Runnable是一个Interface，当我们传入时，则需要重写它的run()方法并将我们想执行的代码逻辑写在里面。所以关于这两种方式的区别，个人认为主要取决于这段逻辑是否需要重复执行并且有不用的参数：比如，如果是执行“显示一个文本框并高亮”，那么可以用message的方法，因为这段逻辑是重复执行的；但如果执行“根据用户选择不同来显示不同布局”，需要传入用户选择数据，则runnable的方法或更好些。 总结这一篇只是对于Android OS一个非常简单的介绍。希望通过我的简单介绍能让读者对于Android OS的组件有一个简单直观的认识。AndroidOS的世界还有许多许多复杂的内容，都是基于我们今天介绍的这几个概念产生的。以后我会在慢慢碰到并解决之后，一一在这里介绍给大家的。让我们共同学习，共同进步，谢谢！ 参考文章：Understanding Android Core: Looper, Handler, and HandlerThread A journey on the Android Main Thread — PSVM Android Handler Internals Understanding Activity.runOnUiThread()","link":"/2018/10/13/AndroidBasic3/"},{"title":"Android开发笔记之基础篇（四）","text":"在Android开发的绝大部分场景里，我们都需要构建至少一个以上的UI界面用于与user的交互。UI界面本身其实只是静态的图片或者框架，但是通过对其的控制，可以实现几乎所有的用户使用效果，例如点击后高亮，点击后消失，左划删除单个条目等等。那么今天就来看看Android中关于UI布局的一些概念和知识。 四种常见的Android Layout布局在Android开发环境中，一个UI layout布局页面以xml文件的格式存于：你的工程路径/main/res/layout里面。xml文件的具体格式这里不再赘述，但是要具体对于不同种类的Layout稍微解释一下： LinearLayout第一种是LinearLayout，这种布局一般来说是最简单，直接，快速的一种，当新建一个layout布局文件时，Android Studio默认的布局文件即为这种LinearLayout。顾名思义，这种布局最适用于线性的UI呈现方式，比如如下的布局： 对于这种只需要横向(Horizontal)或纵向(Vertical)排列的布局，LinearLayout可以说是最适合不过的选择了，它减少了很多处理各部件之前位置关系的参数声明，只需按需调整当前部件和上一个部件之间的位置关系，直到完成布局即可。简单来说，LinearLayout就像堆积木，你只需要沿某一个方向不断堆砌你的subview，并给每个subview规定好边距等参数即可。 RelativeLayout第二种是RelativeLayout，这种布局的特点在于：各部件之间的位置关系主要靠定义与其同布局的其他部件(Sibling)的位置关系来决定。比如我们在定义下面这样一个页面： 类似如上的界面 一般会出现在列表的界面中，对于这种布局我们希望view 1和view 3的左边界对齐，而view 2和view 3的右边界对齐。至于整体布局的高度我们并不是十分介意（一般这种布局会采用上滑显示更多的RecyclerListView，这个以后会继续讲到）。所以此时RelativeLayout就可以通过声明 android:layout_toLeftOf 以及 android:layout_toRightOf 来限制组件间位置关系，从而达到我们想要的效果。RelativeLayout在定义同一块subview内的不同组件间位置关系时非常有效，但是问题是需要处理好位置关系间的冲突，一般需要花费比较多的时间用于调整相对的位置关系。这种布局的使用方法更灵活，能较快速地完成一些更为复杂的布局关系。 FrameLayout第三种是FrameLayout，这种布局一般应用于多层嵌套的视图布局。其实上面介绍的两种视图也可以用于层叠（Overlap）效果，对于到底使用哪种布局在一些特定的应用场景下也会有所不同。但我的理解是: FrameLayout对于层叠场景会有更好的表现和处理方式，在FrameLayout中也会有更多不同的声明方式来进行布局，而一般的RelativeLayout来定义层叠的位置关系会变得很复杂。所以不妨分离出所设计的页面中的层叠部分，来用FrameLayout完成，而其他的部分则采用RelativeLayout。 将你的页面进行分离，使用不同的UI布局框架来定义不同的子页面，也是UI设计布局中十分重要的一步。决定好使用的框架会让你的UI设计变得简单易懂，并且易于改动。相信很多人都遇到过改UI的时候一改就要动到所有的框架这种十分痛苦的事情。 ConstraintLayout最后一个，也是我认为最为重要，功能最为强大的一个，就是ConstraintLayout。ConstraintLayout和其它布局方式最明显的区别在于，它需要对于每一个组件声明布局的constraint，而这些constraint必须声明得比较完备，才能获得想要呈现的效果（也正是因为需要声明的constraint比较多，所以ConstraintLayout可以比较好的大部分在App中我们想要呈现的布局效果）。 在ConstraintLayout中，当定义一个组件的时候，可以通过声明“app:layout_constraintXX_toXXOf”来定义其相对于另一个组建的位置，同时也可以通过声明“android:layout_marginXX”来定义其相对边距，其用法是十分灵活的。ConstranitLayout在进行诸如边缘对齐，居中，各子视图(subview)平均分配等功能时十分有效，目前可以说是我最喜欢使用，也最经常使用的一种布局框架。 总结以上这四种就是UI布局中最常见的Layou，熟悉了解这四种框架之后，通过嵌套的方式可以构造出目前Android应用的绝大部分UI场景和内容，让我们一起慢慢掌握。","link":"/2018/12/15/AndroidBasic4/"},{"title":"Clean Code Summary","text":"Recently I read this book written by Robert C. Martin also known as “Uncle Bob”. In this book it talked about general coding principles to make your code “clean“ and easy to understand. And here is some useful tips and summaries I extracted. Chapter 2 Meangingful Names Use Intention-Revealing Names: avoid nonsense naming Avoid Disinformation: using FULLNAME, avoid abbrevation accountList &gt; accounts &gt; List Make Meaningful Distinctions: ProductInfo and ProductData, Customer and CustomerObject has no difference at all! Use Pronounceable, Searchable Names: the length of a name should correspond to the size of its scope Interface and Implementtations: avoid passing IShapeFactory as interface, using ShapeFactoryImpl in implementation Class Name: Avoid using Manager, Processor, Info, Dataas class name, using noun or noun phrase word One Word Per Concept: Don’t use retrieve, fetchr, get all at same time! It’s horrible! Chapter 3 Functions Small!: Funtions should be very small Avoid nested structures and each block should be one line Function should do one thing can’t extract another function from it witha nmae that is not merely a restatement of its implementation Switch statements: using polymorphism with abstract factory pattern Common Monadic Forms Ask question about argument like boolean isFileExist(File file) Operating on argument, transforming it into something and return like InputStream fileOpen(File file) Interpret function call as event and use argument to alter state of system without output argument like void passwordAttemptFailedNtimes(int attempts) Try to avoid any other form besides those three above Dyadic Forms Sometime reasonable if it’s a natural cohesion or ordering like new Point(0, 0) or assertEquals(expected, actual) It itn’s evil, but it has cost and there always a way to at least convert it to Monadic, just depends on whether it worth or not Argument Objects Using wrapper to wrap into a class of their own see these two following declarations: 12Circle makeCircle(double x, double y, double radius);Circle makeCircle(Point center, double radius); Output Arguments Try not using output argument, if must change state of something, make it change inside it’s own Prefer Exception to Returning Error Codes Error code always force caller to deal with it immediately using using try-catch block, the code to deal with succeed or error will be separated extract try and catch block to its own method should be more clear Chapter 4 Comments Comment should be no need at all It’s always the compensate for failure to express in code Programmer always forget to maintain, which makes them misleading Save the energy to write better and clearer code Chapter 6 Objects and Data Structures Data Abstraction Expose abstract interfaces to allow user manipulate data without knowing its implementation Consider serious which data should be exposed Data/Object Anti-Symmetry Objects: Hide data behind abstractions and expose funtions that operate their data Data: Expose data and have no meaningful functions Procedural code: Easy to add new functions, hard to change data structure Object Oriented code Easy to add new classes, hard to add new functions Need to use both of them properly to make clean code, but not in one class (hybird is the worst!) Chapter 7 Error Handling Use Exceptions Rather Than Return Codes Error code needs to be returned every single case, make the code very complicated and cultter caller Separate detection logic with handle logic Define Exception Classes in Terms of Caller’s Needs Wrapping third-party API is a best practice, easy testing, easy migration and less dependencies Define your own exception type inside wrapper to make handling logic easier outside the wrapper(only one type outside) Null Handling Don’t Return Null: throw an exception or using Special Case Pattern Don’t Pass Null: never pass null in methods Chapter 8 Boundaries Using Third-Party Code Hide the interface inside a class that we can control Avoid when change comes, we need change everywhere Make a Wrapper or Adapter to hide thrid-party interface Learning Test / Boundary Test It’s free and can be used to learning thrid-party code It can be used to detect breaking changes Chapter 10 Classes Class Organization Public static constants Private static constants Public instance variables (if any) Private instance variables Public functions Private function should directly after their caller Class should be small The more ambiguous the class name, the more likely it has too many responsibilities Avoid weasel words like Manager, Processor or Super which will aggregate responsibilities Single Responsibility Principle A class or module should have one and only one reason to change Identity reason to change often helps for better abstraction of our code A system composed of many small , well-structured classes is always better than a few large, multipurpose classes Chapter 11 System (Need revisit in future) Separate Constructing a System from Use it System should not know or care about startup logic, it assume everything should be constructed correctly when start running Using Dynamic Factory pattern to hide the building logic and allow application to decide when and what to build during runtime Dependency Injection: a way to achieve IOC (Inversion of Control) principle: the responsibility of instantiating dependencies will delegate to another “authoritative” mechanism","link":"/2020/04/28/CleanCode/"},{"title":"Clear Architecture - Programming Paradigms &amp; Design Principles","text":"Clean Architecture is one of the series book that written by “Uncle Bob”. In last post, I writed a summary of the Clean Code. It is super useful for begineers. But as we going deeper, we need take a step back and see the “big picture” – software architecture, which is all this book talk about. Part II Starting with the Bricks: Programming ParadigmsStructured Programming: direct transfer of controlConstructed from sequence, selection and iteration to replace old goto keyword. A typical structured programming example: 123456789101112131415// sequence executionval sum = 0val current = 1// iterationwhile (current &lt; 10) { sum += current current += 1}// selectionif (needNegative) { return sum *= -1} else { return sum}return sum All programs can be constructed from just these three structures: sequence, selection and iteration. Object-Oriented Programming: indirect transfer of controlThrough the use of polymorphism to gain absolute control over every source code dependency in the system.To better understnad about power of polymorphism. also check Dependency Inversion Principle below. A typical object-oriented programming example: 123456789101112131415161718192021222324252627282930313233343536// define Vehicle interfaceinterface Vehicle { fun alarm() fun turnOn() fun turnOff()}// different brand of car, should all implement the same interfaceclass BMW: Vehicle { override fun alarm() { makrSound(\"di~di~\") } override fun turnOn() { ... } override fun turnOff() { ... }}// but they can have diffrent implementation (such as differnt alram sound)class Ford: Vehicle { override fun alarm() { makrSound(\"do~do~\") } override fun turnOn() { ... } override fun turnOff() { ... }}// when client code is using them, they don't need to know the implementation detailsFord().turnOn()BMW().ring() Any source code dependency, no matter where it is, can be inverted. Functional Programming: variable assignmentVariables in functional languages do not vary, which will causing none of race condition, deadlock or concurrent update problems. A typical functional programming example: 123456789class Person constructor ( private val name: String) { fun getName(): String { return name }}// define a function to get person's nameval personName = fun(person: Person) = person.getName Concurrent problems can be eliminated by segregate the application into mutable and immutable components. Part III Design PrinciplesSingle Responsibility Principle (SRP) A module should have one, and only one reason to change A common way to impose this principle is: Separate shared functional code blocks from specific logic. For example, here is a Employee class from payroll application: 1234567891011121314class Employee { private val employeeDB = EmployeeDatabase() fun getWorkingHours(): Int { return employeeDB.queryWorkingHours() } fun calculatePayroll(): Int { val workingHours = getWorkingHours() val salaryRatePerHour = employeeDB.querySalaryRatePerHour() return workingHours * salaryRatePerHour } fun saveEmployee() { employeeDB.updateEmpployee(this) }} It’s clear that this Employee class has too many responsibilities including query working hour, query salary rate, calculate payroll, update employee info etc. And typical problem can be: It’s hard to extends, when introduce different ways to calculate payroll for example; Who wants to change ONLY working hours fetching may also touch payroll calculation accidentally; EmployeeDatabase is exposed to Employee class, which is dangerous for open visibility. To solve these issues, we can do: 1234567891011121314class Employee { private val hourReporter = HourReporter() private val payCalculator = PayCalculator() private val employeeSaver = EmployeeSaver() fun getWorkingHours(): Int { return hourReporter.reportHours() } fun calculatePayroll(): Int { return payCalculator.calculatePay() } fun saveEmployee() { employeeSaver.saveEmpployee(this) }} As we can see, after we create HourReporter, PayCalculator and EmployeeSaver, we separate different responsibilities to different class so: if we want to have diffrent ways to calculate payroll, it can be updated inside PayCalculator and no need to update Employee class; when working hours fetching need to change, no need to touch payroll calculation logic; no more database expose to Employee class since it’s handled by these three classes internally. Open-Closed Principle (OCP) A software artifact should be open for extension but closed for modification. This is a common case that sometimes we want to extends part of our code and extends without having to modify that artifact. To make this possible, we need to implement component hierarchy structure so code change in lower level component will not effect higher level component. In other word, higher level component is being protected from code change chain. Let’s continue on the Employee example: 1234567891011121314class Employee { private val hourReporter = HourReporter() private val payCalculator = PayCalculator() private val employeeSaver = EmployeeSaver() fun getWorkingHours(): Int { return hourReporter.reportHours() } fun calculatePayroll(): Int { return payCalculator.calculatePay() } fun saveEmployee() { employeeSaver.saveEmpployee(this) }} It’s easy to understand that HourReporter, PayCalculator, EmployeeSaver classes has higher prority then Employee class and we want to avoid code change on them when we need change Employee class. The UML of structure is like: Note that an arrow pointing from class A (Employee) to class B(HourReporter, PayCalculator, EmployeeSaver) means: the source code of class A mentionas the name of class B, but class B mentions nothing about class A. In this XML, Employee depends on these three classes, so those three classes is protected from changes in Employee. Liskov Substitution Principle (LSP) Subclass should be substitutable for their base class A typical example of this principle is square/rectangle problem, let’s briefly recall the problem first by UML: As common sense, a Square should be treated as a special Rectangle which means all operations or parameters for a rectangle object should also effect on a square object. Let’s see the code block below: 1234val rectangle = Rectangle()rectangle.setWidth(2)rectangle.setHeight(5)assert(rectangle.getArea() == 10) This should work fine and the assertion should pass as well, but when we do the same thing to a Square like: 1234val square= Square()square.setSide(2) // how can width and height change at same time???square.setSide(5)assert(rectangle.getArea() == 10) // this will failed and area will be 25 The core problem behind this case is : square has a feature which rectangle don't: need set both width and height always at same time with same value, they can't be changed separately. It may causing a lot problems becuase of this. Interface Segregation Principle (ISP) No client should be forced to implement methods it doesn’t use When we play with abstract interfaces and implementation, a common problem is we find there are extra methods that the implementation not used at all. The easiest way to handle it is just override it and make it empty. But by doing this, there is a risk that it might be touched by other maintainers or even yourself in future since you may not remember. A good fix on this should be separate it into multiple specific interfaces like: In my opinion this is a good way to minimum the risk and separate interface for different class if they not use all of them, but also note that this might causing a lot interfaces to be generated, this is the trade-off. Dependency Inversion Principle (DIP) High-level module shouldn’t depend on low-level, but both should only depend on abstraction, not on concretions This is the most information principle in my opinion and also the hardest one to understand. To understand this, first question is: what is abstraction and why we need it? To answer this, let’s see this example UML: This is the concrete implementation for an application with a simple service. Service is created by ServiceFactory by calling serviceFactory.createService(). It works fine but it has several problems: Application can access everthing inside Service and ServiceFactory, it including something they don’t use (violation of ISP); Both Service and ServiceFactory are dependencies of Application, which means when their code changed, Application will need to re-comple and re-generated everytime (violation of OCP); If we want to add new type of service in future, both Application and ServiceFactory need change the code and still hard to extends (violation of OCP again). So according to what we learned before, here is a better solution for all three points above: As you can see in the solution UML, we make both ServiceFactory and Service as Interface and give them implemnentations for each interface. Note that implementation is hided from Application so it only communicate with interfaces. Why? Look back into all three problems above and you will find all of them is successfully solved by using Interface! Now let’s understand the description of this principle with the example: consider Application as low-level module and ServiceFactory, Service as high-level module, Application should not depends on ServiceFactory and Service because of the violation of ISP, OCP and DIP, and they should all depends on the abstraction, which is Interface in this case. And by using interface, the control flow is successfully inverted from Application -&gt; ServiceFactory to ServiceFactoryImpl -&gt; Application, same for Service as well. This is how Inversion come from.","link":"/2020/05/11/ClearArchitecture1/"},{"title":"Dependency Injection","text":"Dependency Injection is a huge topic in Android development and it’s very important because it can give us a clean, well-designed, easy-to-change environment no matter we develop new features or implement any testing. So here is some thoughts about DI and an useful framework which helps you do all dirty jobs behind the scene. What is Dependency InjectionBefore answering this question, a better question to ask might be: What is dependencyTo answer this question, let’s take a look at this Kotlin code here: 12345678910111213class SimpleFeature constructor( val businessLogicDelegate: BusinessLogicDelegate, val validator: Validator, val listener: Listener) { fun doSomeThing() { val helper = Helper() if (validator.validate()) { businessLogicDelegate.doSomething(helper, listener) } }} This is a very common secenario in real life: I have a class and serveral parameters in its constructor, I need call some methods of those parameters inside this class. At the same time, I also need initialize a helper class inside and use it. In this case, both the parameters and helper class will be considered as the Dependency of SimplyFeature class. Cause this SimpleFeature needs “depend on“ something to finsh its own job. In another word, if any class’s method is called inside a class A, those class will be considered as A’s dependency. So now I know dependency, what is dependency injection?Let’s look back to this code again: 12345678910111213class SimpleFeature constructor( val businessLogicDelegate: BusinessLogicDelegate, val validator: Validator, val listener: Listener) { fun doSomeThing() { val helper = Helper() if (validator.validate()) { businessLogicDelegate.doSomething(helper, listener) } }} There are two main issues in this code block: Inside the doSomeThing(), we need to initialize a Helper class to help finishing business logic. This can work for sure, but if this helper needs to be a static class, or I need to using a Signleton helper class, here, how can I use it? When writing unit test with Mockito or Mockk, a common way is passing in a “mock“ instance and testing if the expected method of this mock is called with correct parameter. But how can we pass in the mock of Helper class if the new operator is called inside? To solve these problems, what can we do? Just simply pass a helper instance in the constructor so it can become the dependency of SimpleFeature as well! The constructor will look like this: 12345678910111213class SimpleFeature constructor( val businessLogicDelegate: BusinessLogicDelegate, val validator: Validator, val listener: Listener, val helper: Helper) { fun doSomeThing() { if (validator.validate()) { businessLogicDelegate.doSomething(helper, listener) } }} Now it looks great! I can pass in any Helper class and also mocking it and do the unit test! Nice! Now we can make a conclusion here: Dependency Injection means:Passing the dependency into the class and use it One thing need to mention here is: passing through class’s constructor is only one of the way to do DI. More details about this concept can be find here. How can I use dependencies injection?To use dependencies injection effectively, let me introduce this super-useful library here: This Dagger 2 library are powerful for android application dependency injection, by using this, all we need to do it’s define each class’s dependency list and the scope to use it. All other stuff will be handled by this library automatically and anonymously. So how to use it? First, we need to have a module class: 12345678910111213141516@Moduleinterface MainModule { @Binds fun providesBusinessLogicDelegate(businessLogicDelegateImpl: BusinessLogicDelegateImpl): BusinessLogicDelegate @Binds fun providesValidator(validatorImpl: ValidatorImpl): Validator @Binds fun providesListener(listenerImpl: ListenerImpl): Listener @Binds fun providesHelper(helperImpl: HelperImpl): Helper} What is this Module use for? Basically this is the place you want dagger helps you to initialize all your dependency. There are two ways to initial dependency in dagger, one is through @Bind annotation and another is @Provides. In here I’m using @Binds since it’s much simpler if all dependencies has implement an interface. Then we need another class which is called componenet class: 1234567@Component (modules = [MainModule::class])interface MainComponent { fun inject(activity: MainActivity) fun inject(feature: SimpleFeature)} Inside this Component, the inject() method defines “where those dependencies should be injected to”. And following the @Component annotation we can declare all modules that can be included, so we can inject multiple module’s dependencies inside one single class that called by inject() method. So far so good! After create these two classes above, we defined What is the dependency and Where should we inject into. Now the final step will be refactor our SimpleFeature class: 12345678910111213class SimpleFeature @Inject constructor( val businessLogicDelegate: BusinessLogicDelegate, val validator: Validator, val listener: Listener, val helper: Helper) { fun doSomeThing() { if (validator.validate()) { businessLogicDelegate.doSomething(helper, listener) } }} Since all parameters inside the constructor are initialized in module class and the injection of this feature class also declared in component class, the only change needed in here is add @Inject annotation before constructor, then dagger knows that all parameters can be find in module and injected by component magically. Done! Now enjoy inject any dependency you want! Now there are still some notes worth mention here: What we using here is just a very brief introduction of Dagger, it has a lot powerful methods and tools that worth to try and play with it. More detail should be found in here One of the very useful feature of Dagger is @Scope annotation. It can be used in complicated structured project to define different scope for different dependencies to access. This part will be added in future as a follow-up of our DI topic. The main purpose of DI is align with one of the basic SOLID principle in softwate development, which is know as Dependency Inversion Rules. This principle states: High-level Module should not depends on low-level module, both should depend on abstractions (interface); Abstractions should not depend on details. Details (concrete implementation) should depends on abstraction. We will cover all these principles one by one in future, they are very important in industrial software development world. Although there are tons of advantages in DI, but it has its limit or disadvantage for sure. For example, when dependency is missing, it’s hard to find out which dependency is missing by checking the build output. So at this time, log is very useful to check.","link":"/2020/02/28/DependencyInjection/"}],"tags":[{"name":"Android","slug":"Android","link":"/tags/Android/"},{"name":"Clean Code","slug":"Clean-Code","link":"/tags/Clean-Code/"},{"name":"Reading","slug":"Reading","link":"/tags/Reading/"},{"name":"Clean Architecture","slug":"Clean-Architecture","link":"/tags/Clean-Architecture/"}],"categories":[]}