{"pages":[{"title":"tags","text":"","link":"/tags/index.html"}],"posts":[{"title":"Android开发笔记之基础篇（一）","text":"因为最近开始系统地学习Android开发，所以在这里记录一下所学到的Android内容做一个整理。既算是对已学到知识的总结和梳理，也可以检查自己理解中出现的问题，和大家共同讨论一下。因为是第一次写东西，所以有什么不详细，不清楚，不准确的地方，还希望可以指正，我们共同讨论，共同进步。 本篇文章大部分的内容都是基于自己通过Google官方说明文档，StackoverFlow, CSDN等网站的阅读获得的，希望通过我个人的理解，让这些知识更容易被读者所理解和接受。 Application Structure进入Andorid的第一个需要理解的知识，也是我个人认为最为重要的基础知识之一，就是了解Android application的架构。构成一个完整安卓APP的，是各种各样不同的Component（组件），这些Component分别承担着不同的工作和职责，比如负责与用户进行交互的Activity，负责后台相关工作的Service，负责监听传递信息的BoardcastReceiver， 以及存储读取数据的ContentProvider等等。 我们用一个简单的例子来解释一下：如果说现在需要做一个负责计算汇率转换的Android应用，那么其对应的组件功能分别为： 首先要实现汇率转换的功能，我们就需要一个让用户输入金额大小，选择转换货币类别的界面，这就是CurrencyConvertActivity，在其中定义了一切UI与用户进行交互的逻辑； 接着我们想在后台服务器实时获取当前的汇率数据信息，那么就需要一个BoardcastReceiver来随时向服务器发送请求获取当前最新的汇率信息并传送给CurrencyConvertActivity，用来计算金额； 如果我们想在App启动时根据系统中用户设定的当前国家来显示对应的国家货币，并且在用户切换国家/时区时在APP内进行实时更新，就需要建立一个CountryChangeReceiver来监听TIMEZONE_CHANGED系统事件并在监听到切换国家/时区时进行识别； 如果我们想将实时获得的汇率进行缓存，以便在网络环境恶劣的情况下获得最近一次实时汇率表，那么就可以使用ExchangeRateContentProvider将汇率数据进行保存和处理 现在整个Application的架构大致就是这样: 123456789101112131415161718192021222324252627282930313233&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; package=&quot;com.yunze.myapplication&quot;&gt; &lt;application android:allowBackup=&quot;true&quot; android:icon=&quot;@mipmap/ic_launcher&quot; android:label=&quot;@string/app_name&quot; android:roundIcon=&quot;@mipmap/ic_launcher_round&quot; android:supportsRtl=&quot;true&quot; android:theme=&quot;@style/AppTheme&quot;&gt; &lt;activity android:name=&quot;com.yunze.myapplication.CurrencyActivity&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt; &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;service android:name=&quot;.BackendService&quot;&gt; &lt;intent-filter /&gt; &lt;/service&gt; &lt;receiver android:name=&quot;.CountryChangeReceiver&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.TIMEZONE_CHANGED&quot; /&gt; &lt;/intent-filter&gt; &lt;/receiver&gt; &lt;provider android:name=&quot;.ExchangeRateContentProvider&quot; android:authorities=&quot;.ExchangeRateDB&quot;&gt; &lt;/provider&gt; &lt;/application&gt;&lt;/manifest&gt; 上面显示的这个AndroidManifest.xml，可以理解为一个Android Application的“骨架”。正如我们之前所说，Activity，Service，BroadcastReceiver和ContentProvider可以算是Android Application的四大“组件”。而AndroidManifest.xml文件则正是申明这个App所使用的所有组件的地方，所以当我们开始上手一个新的安卓项目时，应该要从AndroidManifest.xml开始看起，才能比较详尽全面地了解这个App。 Android Components下面具体来比较一下不同的组件之间的关系，让我们有更进一步的了解。 Activity：整个Android开发中最为重要的一个概念。Acitivity中定义了App与用户的交互逻辑，例如当用户点击当前这个按钮，应该发生什么事，是显示一个文本框，更改图片的颜色，或者关闭当前界面回到上一个界面等等。可以说：所有关于用户交互的逻辑全部都只能定义和存在与Activity之中。 Service：如果我们的APP中需要一个长时间运行在后台来处理业务的功能，比如频繁向服务器发送请求，或者需要等待服务器随时返回请求，或者要长时间从服务器加载大型文件（比如在线浏览视频），此时就需要用到我们的Service组件。Service组件最重要的特征就是：可以长时间的运行在后台进行服务，直到完成任务后将自己结束，并且其中不能定义任何与用户UI有关的内容。 BroadcastReceiver: 这可能是四个组件中比较不好理解的一个，其实可以把它想象成APP的一根“天线”，它的功能就是主动接受其他APP传来的特定“信号”。比如我们之前说的TIMEZONE_CHANGED这个event，当安卓系统检测到用户手机切换了时区时，就会向整个系统内广播这个TIMEZONE_CHANGED event，此时如果我们的APP中含有一个注册了TIMEZONE_CHANGED的BroadcastReceiver，那么这个receiver就会被触发并完成一系列我们定义好的逻辑。 ContentProvider：这个组件一般为存储和获取数据提供统一的接口，可以在不同的应用程序之间共享数据。通过这个接口，其他应用看不到数据是如何存储的, 但通过ContentResolver可以对其进行包括：添加(insert), 删除(delete), 获取(query), 修改(update) &amp; 返回MIME类型(getType)等一系列的操作。在这个组件中，所有文件都是通过URI来识别，结构为: content://授权信息/表名/记录。 这里要稍微说一下BroadcastReceiver与Service的区别，它们都是运行在后台，不带有任何UI的组件。但是Service作为消息的接收方是只能被单独触发的，而不同的BoardcastReceiver却是可以被一起触发的，前提就是它们都注册了同一个event。下面是在看他人的总结介绍时看到的一张很有意思的图： 从这张图上来看，有几点值得我们特别注意的： 只有Activity才可以启动一个新的Activity（理论上讲其实是有其他办法可以从Service和BoardcastReceiver中启动的，但是这里说的不是“能不能”，而是“是否应该”），当我们创建一个新的Android项目时，都会自动生成一个MainActivity，所有关于APP的行为和逻辑都应该在这个或者几个Activity内来完成，项目也会有一个Application类，这个类一般是作为各种Activity的容器来使用，不要轻易将代码逻辑写在Application里；而启动新的Activity的方式就是在StartActivity()方法中传递一个Intent类，这个下面会讲到。 只有Activity才可以Layout Inflation。这个也比较好理解，因为前面说过，只有Activity才能处理和用户的交互，显示所有的UI和Layout（其实所有的UI都只能run在UI Thread，也就是Main Thread上，而只有Activity可以access到Main Thread，所以当然只有它可以处理UI的部分）。当然也是有Tricky way来做的，比如call runOnUiThread()之类的，之后等到写multi-thread的时候会涉及这部分。 Broadcast Receiver所监听的Event一般来说是向全系统广播的一些事件，比如手机连接好了WIFI，手机外接了电源等等。当然也可以监听自定义的event，但是根据我们前面说的用途，自定义的情况比较少，毕竟没有必要只向自己的一个service或者activity进行广播。 Communication between Components下面我们来了解一下各组件间的通信方式，所谓“通信”，其实就是指：1. 从一个组件向另一个组件传递参数；2. 从一个组件生成另一个新组件。传递参数的方式有很多，但是生成组件的方式却很有限： Activity启动一个新的Activity的方式主要就是通过 startActivity() 或startActivityForResult() 方法并传递一个Intent实例。这两个方法的主要区别在于是否需要从新的activity返回一个结果，比如通过新的activity选择一张本地存储的图片，或者通过新的activity确定一个文件是否已经发送完毕等等。Intent中包含了新的Activity的类名以及一些初始化需要的数据(Extra)。 通过putExtra()方法可以将这些数据传入Intent，从而传递给新的Activity。 Service启动一个Service的方法大致有三种： 直接开启：通过startService()方法并传递一个Intent实例，这个方法和Activity基本一致； 绑定开启：通过bindService()方法并传递一个Intent实例，绑定开启与直接开启的一个最大的区别就是：绑定开启的service会在开启它的组件生命周期结束时随之结束，而直接开启则不会。实际上，直接开启的service会一直运行，直到stopService()被执行，或者App被卸载。 JobScheduler调度：在Android 5.0+中，可以通过JobScheduler中的schedule()方法来启动一个service，这个方式目前我还没有用到过，以后如果涉及到再单独写一篇吧。 BroadcastReceiver启动BroadcastReceiver的方式和Activity基本一致，区别在于可使用的方法更多，其中包括：sendBroadCast()，sendOrderedBroadcast()以及sendStickyBroadcast()，也都需要传递Intent实例到各个方法中。Broadcast有一个不同点在于静态注册/动态注册，之后会专门写一篇讲它。 ContentProvider这个组件和其他组件不同，因为它只是一个接口，所以其不需要进行启动或者初始化。而使用ContentProvider的一般步骤包括： 创建一个实现ContentProvider接口的类，并实现接口中的各个方法（insert()， delete()， query()等）; 在AndroidManifest.xml中进行注册； 通过getContentResolver().query(URI)方法就可以直接获得定义的ContentProvider中的数据。 参考链接Application Fundamentals - Google Android 官方说明文档","link":"/2020/06/10/AndroidBasic1/"},{"title":"Android开发笔记之基础篇（三）","text":"今天的内容是这周工作中出现的一个相关内容的学习：多线程（Multi-thread）。多线程可以极大地减少程序在并发执行时所付出的时空开销，提高操作系统的并发性能。在Android的开发中，多线程是非常重要的一环，而相信很多人也在面试中被问到过不止一次进程（Process）与线程（Thread）的区别。那么我们就来看看和Android相关的多线程组件Process，Thread，Looper，Handler各自的概念和实例。 Process vs Thread进程（Process）是多线程的第一个概念。简单来说，进程是指计算机中已经运行的程序，而对于安卓系统，一般一个Android应用程序就是一个进程，其中包含多个线程协同工作。 线程（Thread）是一种轻量级的子进程，是一个基本的CPU执行单元 &amp; 程序执行流的最小单元，也是独立运行和独立调度的基本单位。在Android的环境里，一个线程可以理解为一群任务的有序集合，所有线程共享进程所拥有的系统资源和存储资源，各线程之间通信快速高效。当这个线程的任务全部执行结束时，线程就会被终止。 Android Multi-threadAndroid系统中的线程分为两类：主线程（Main Thread）和其他子线程。 主线程也叫UI线程，在Android APP启动时会自动生成，主要负责处理Android四大组件（可以看这篇中关于四大组件的介绍）与用户进行交互的事件响应与逻辑，所以也叫主线程也叫UI线程。要注意的是，因为用户随时会与界面发生交互，因此主线程任何时候都必须保持很高的响应速度，所以主线程不允许进行耗时操作，否则会出现ANR（ApplicationNotResponding）异常。 子线程就是APP的工作线程，子线程都是APP运行过程中手动创建的线程，可以在其中处理一些耗时的操作例如网络请求、I/O操作等。可以通过使用RxJava等函数库来创建用于不同操作的特定子线程。 在Android官方声明中，对于多线程编程时有两大原则： 不要阻塞UI线程（即主线程）：主线程被阻塞超过5s则会出现ANR错误； 不要在UI线程之外更新UI组件。 那么现在我们来看看如何在代码中创建一个子线程吧。代码如下： 123456789package com.example.yunzeli.testapplicationpublic class MyWorkingThread extends Thread { private boolean isRunning; @Override public void run() { // 开始线程的工作 }} 可以看到，我们真正需要做的，就是继承Thread这个类，并实现run()方法。将我们需要做的工作在run()里完成即可，这个方法简单方便，但是却有一个问题：上面我们说过，当这个线程的任务全部执行结束时，线程就会被终止，那么如果我们需要在工作线程完成当前工作后不被中止，而是继续等待新的任务到来呢？那么就可以这样： 123456789101112131415package com.example.yunzeli.testapplicationpublic class MyWorkingThread extends Thread { private boolean isRunning; @Override public void run() { isRunning = ture; while (isRunning) { // 开始线程的工作 // 线程的工作完成后 isRunning = false; } }} 上面的代码中，我们通过设置一个isRunning的flag，可以用循环的方式来block住这个线程，然后等待新的任务到来。很好，现在我们有了一个独立运行的，随时可以使用的工作线程。但事实上，Java代码库里给我们提供了一个更加简单清晰，并且可靠的类，这就是Looper。 Looper从上面的内容我们知道，要想将一个线程block住，我们需要用looping将其不断循环并等待新的任务。在Android的开发包里，就有一个设计好的Looper类供我们使用。这个Looper一直在不停的循环并监听新来的task，每个Looper都有一个messageQueue用来存放分配的task，也叫做Message。Looper的使用有两个基本原则： 每一个Thread有且只能有一个Looper； 当想让某一个Thread执行某个任务时，就将message传送给对应Looper的messageQueue。 Looper在thread的具体使用方法如下： 12345678910111213141516package com.example.yunzeli.testapplicationimport android.os.Looperpublic class MyLooperThread extends Thread { @Override public void run() { // prepare the loop Looper.prepare(); // start looping Looper.loop(); // do your staff here... }} Looper.prepare()：检查当前这个thread是否已经分配好looper，如果没有，则新建一个looper来监听这个thread； Looper.loop()：looper开始监听当前线程，开始处理收到的message； 简而言之，Looper的作用就是一直looping and keep thread alive。值得注意的是，Main Thread也就是UI线程，是已经初始化了MainLooper的。所以不需要对于Main Thread进行任何的操作，Android系统已经帮我们都处理好了。 MessageQueue &amp; Handler说完了Looper，现在我们来说说Looper里面的一个重要概念：MessageQueue。当我们想向一个thread里派送一个新的task时，Java规定了我们只能派送如下两种类型：Message和Runnable。那么，我们如何将这两种类型的实例派送到目标线程的messageQueue里呢？这里就用到了另一个重要概念：Handler。Handler的功能相当于一个装配器，它可以将任意继承了Message或者Runnable类的实例放入其监听的Looper的messageQueue里，例如： 12345678910111213141516171819202122232425262728293031323334353637383940public class MyLooperThread extends Thread { private static final int MSG_1 = 1; private static final int MSG_2 = 2; @Override public void run() { // prepare the loop Looper.prepare(); // start looping Looper.loop(); // send message here Handler handler = new MyHandler(); handler.obtainMessage(MSG_1).sendToTarget(); handler.post(new Runnable() { @Override public void run() { // do something here... } }); } class MyHandler extends Handler { @Override public void handleMessage(Message message) { // switch your message type here switch(message.what) { case MSG_1: // do something here... break; case MSG_2： // do something here... break; default: } } }} 由上面例子可见，Handler通过obtainMessage(Message msg)的方法来传送message实例，用post(Runnable runable)的方法来传送Runnable实例。那么，Handler如何知道所要传送的目标thread呢？Android官方文档里写的很清楚，Handler有两个默认的构造器（constructor），如果使用new Handler()的话，则当前线程就会成为创建的Handler的目标线程；而如果使用new Handler(Looper looper)的话，则传入的looper对应的线程就会作为创建的Handler的目标线程。总结一下，Hanlder的作用主要就是两点： 从任意thread中将message或者runnable传入其对应的looper的message queue中； 获取其对应looper的message queue中的下一个task（message或runnable）并执行对应的操作。 需要强调的一点是：虽然一个thread只能有一个对应的looper，但是一个looper却可以同时被多个Handler所引用（允许将同一个Looper传入多个Handler的构造器）以便指定给同一thread的不同handler分别处理不同的message或者runnable。这样的设计也方便了我们对于多个task的处理。 Message &amp; Runnable最后关于Message和Runnable再简单介绍一下： 当我们希望在一个thread里执行一段代码（task）时，Android OS 规定了这两种类型作为传入的参数。Message的使用方式在于：我们预先在Handler里定义好了如何处理这个MESSAGE_TYPE的逻辑，然后将对应的MESSAGE_TYPE传入。个人理解比较像是pre-define了一个处理逻辑，然后只需要传入对应message就可以trigger这个task；而Runnable是一个Interface，当我们传入时，则需要重写它的run()方法并将我们想执行的代码逻辑写在里面。 关于这两种方式的区别，个人认为主要取决于这段逻辑是否需要传入动态变化的参数：比如，如果是执行例如显示一个文本框并高亮这种固定的，静态的逻辑，那么message的方法是比较好的选择。但如果执行根据用户输入值来显示字体大小这种需要参数的逻辑，则runnable的方法或更好些。 总结这一篇只是对于Android多线程一个非常简单的介绍。希望通过我的简单介绍能让读者对于多线程有一个简单直观的认识。Android多线程还有着许多许多复杂的内容，以后会在碰到并解决之后，一一在这里介绍给大家的。让我们共同学习，共同进步，谢谢！ 参考文章：Understanding Android Core: Looper, Handler, and HandlerThread A journey on the Android Main Thread — PSVM Android Handler Internals Android多线程 Multithreading Interview Question","link":"/2020/06/22/AndroidBasic3/"},{"title":"Android开发笔记之基础篇（四）","text":"在Android开发的大部分场景里，我们需要构建各种各样的UI界面用于与用户进行交互。很多UI设计看起来很简单也很清晰，但一旦开始上手设计，就会发现：设计师轻松画出的各个UI组件，它们的排列，间隔，对齐，大小，其实没有那么容易摆放正确。再加上对于安卓系统的手机，屏幕大小尺寸更是多种多样。这是我们就需要用到页面布局（UI Layout）这个工具。那么今天就来看看Android中关于页面布局的一些概念和知识。 四种常见的Android Layout布局在Android开发环境中，一个UI layout布局页面以xml文件的格式存于：你的工程路径/main/res/layout里面。xml文件的具体格式这里不再赘述，但是要具体对于不同种类的Layout稍微解释一下： LinearLayout第一种是LinearLayout，这种布局一般来说是最简单，直接，快速的一种，当新建一个layout布局文件时，Android Studio默认的布局文件即为这种LinearLayout。顾名思义，这种布局最适用于线性的UI呈现方式，比如如下的布局： 对于这种只需要横向(Horizontal)或纵向(Vertical)排列的布局，LinearLayout可以说是最适合不过的选择了，它减少了很多处理各部件之前位置关系的参数声明，只需按需调整当前部件和上一个部件之间的位置关系，直到完成布局即可。简单来说，LinearLayout就像堆积木，你只需要沿某一个方向不断堆砌你的subview，并给每个subview规定好边距等参数即可。但是需要注意的是：这种Layout类型不允许在同一层内堆多个subview。如果需要的话，要使用下面的RelativeLayout。 RelativeLayout第二种是RelativeLayout，这种布局的特点在于：各部件之间的位置关系主要靠定义与其同布局的其他部件(Sibling)的位置关系来决定。比如我们在定义下面这样一个页面： 类似如上的界面一般会出现在列表（List）中，对于这种布局我们希望view 1和view 3的左边界对齐，而view 2和view 3的右边界对齐。至于整体布局的高度我们并不是十分介意（一般这种布局会采用上滑显示更多的RecyclerListView，这个以后会继续讲到）。所以此时RelativeLayout就可以通过声明 android:layout_toLeftOf 以及 android:layout_toRightOf 来限制组件间位置关系，从而达到我们想要的效果。 RelativeLayout顾名思义，在定义同一个subview内的不同组件间相对位置关系时非常有效。但在使用时需要处理好相对位置关系间的冲突，一般需要花费一些时间用于调整相对的位置关系。这种布局的使用方法在面对稍微复杂一点的UI界面时相比LinearLayout更灵活，更高效。 FrameLayout第三种是FrameLayout，这种布局一般应用于多层嵌套的视图布局。其实上面介绍的两种视图也可以用于层叠（Overlap）效果，对于到底使用哪种布局在一些特定的应用场景下也会有所不同。但我的理解是: FrameLayout对于层叠场景会有更好的表现和处理方式，在FrameLayout中也会有更多不同的声明方式来进行布局，而一般的RelativeLayout来定义层叠的位置关系会变得很复杂。所以不妨分离出所设计的页面中的层叠部分，来用FrameLayout完成，而其他的部分则采用RelativeLayout。 将你的页面进行分离，使用不同的UI布局框架来定义不同的子页面，也是UI设计布局中十分重要的一步。决定好使用的框架会让你的UI设计变得简单易懂，并且易于改动。相信很多人都遇到过改UI的时候一改就要动到所有的框架这种十分痛苦的事情。 ConstraintLayout最后一个，也是我认为最为重要，功能最为强大的一个，就是ConstraintLayout。ConstraintLayout和其它布局方式最明显的区别在于，它需要对于每一个组件声明布局的constraint，这些constraints会按照优先级被执行并布局。但是必须声明得比较完备，才能获得想要呈现的效果（也正是因为需要声明的constraint比较多，所以ConstraintLayout可以比较好的大部分在App中我们想要呈现的布局效果）。 在ConstraintLayout中，当定义一个组件的时候，可以通过声明app:layout_constraintXX_toXXOf来定义其相对于另一个组建的位置，同时也可以通过声明android:layout_marginXX来定义其相对边距，其用法是十分灵活的。ConstranitLayout在进行诸如边缘对齐，居中，各子视图(subview)平均分配等功能时十分有效，目前可以说是我最喜欢使用，也最经常使用的一种布局框架。","link":"/2020/07/02/AndroidBasic4/"},{"title":"Android开发笔记之基础篇（二）","text":"之前的Android开发笔记之基础篇(一)中主要讲到了一些关于Android Components的基本概念以及它们的异同。今天就来讲解一下关于Activity中涉及UI部分的三个核心组件：Activity，Fragment和Dialog。它们基本承担起了APP中所有的图形界面和交互逻辑，也是面向用户最直观的展现。 Activity前面我们说到过，在Activity中定义了与用户交互的所有逻辑（Presentation Layer Logic）。举个例子，我们想做一个电话本App，那么就需要设计当用户点击某个按钮时，其背后发生的一切逻辑，而这些定义都包含在Activity中。那么，一个Application中可以包含多个Activity么？答案当然是可以的，而且是几乎必须的！想象一下在这个Application中可能会出现的界面包括： 基本的浏览电话本页面（DashboardActivity），显示一个联系人的列表； 当选中一个电话时，要显示一个详细联系人的页面（ContactActivity）； 点击电话号码时，弹出一个拨打电话的界面(DialingActivity)； Dashboard里要有一个“编辑”按钮，点击后弹出一个新建联系人界面（NewContactActivity） 可以看出，这每一个单独的界面，都是一个专门的Activity。也正是因为一个APP中有多个Activity的存在，才使整个安卓App的架构变得更加清晰，也更有利于我们阅读，重构以及debug。 对于一个Activity来说，可以采用多种不同的设计模式（Design Pattern）比如MVC，MVVM以及MVP。这其中我个人非常喜欢MVP（Model-View-Presenter）来设计代码。对于不同的Activity，出于解耦（De-coupling）的考虑，通常将它们放入不同的package中，方便区分以及日后对它们分别进行重构。像如上我们举例的电话App，它的结构大致就是这样： 在上一次我们说到，AndroidManifest这个文件里定义了所有App所需要的Activity，Service，BoardcastReceiver, ContentProvider等等，所以不要忘记在创建完Activity之后，一定要在Manifest里面把它声明好。 Activity Lifecycle关于生命周期（Lifecycle），我们只需要知道它定义了一个组件什么时候被初始化，什么时候对应什么状态，以及应该在何时进行何种操作即可。Activity的生命周期如下图所示： 让我们来一步步说明一下各生命周期方法的作用： onCreate()：必须实现，主要用于初始化activity以及设定各种参数； onRestart()：onStop()后如果没有被kill，会从这里唤醒，早于onStart()； onStart()：系统正在启动，UI已显示，但无法交互； onResume()：UI已显示，用户可以进行交互，而如果在Acitivity内部初始化其他Dialog或Fragment时，不论activity是否全屏，它都会保持在此状态； onPause()：最好在此释放CPU，保存数据； onStop()：activity完全从前台结束，看不见时进入此状态； onDestory()：activity被完全销毁，可以做回收和最终释放。 另外值得注意的一点就是：当设备进行横竖屏切换时：acitivity会销毁并重新初始化。如不销毁，需在manifest对应的activity内部声明configChange=“orientation | screenSize”, 此时onConfigurationChanged()会被call。 Fragment在说完Activity之后，下面我们要说一下Fragment这个重要的component。在各种Android的档案定义里，都会反复出现对于Fragment的定义：A Fragment represents a behavior or a portion of user interface in a FragmentActivity. You can combine multiple fragments in a single activity to build a multi-pane UI and reuse a fragment in multiple activities. 但是我一直就觉得这个解释非常不明确，为什么我们需要用Fragment呢？我个人的理解是：当在一个Activity内有多个单独显示的页面，并且每个页面与用户交互的逻辑都各不相同时，Fragment可以帮助我们减少很多麻烦，将整个Activity的架构变得十分清晰。这是我认为Fragment最为有用的一点。 还是以前面的电话本App为例，在拨打电话的界面DialingActivity中，可能会分为三个阶段： 接收到来电（InComingCall） 电话被接通（Calling） 通话结束（CallEnded） 根据需求不同，这三个阶段的界面可能会有完全不同的UI布局，每个按钮也可能会有不同的功能，但是它们同属于一个打电话的功能之中（DialingActivity）。此时如果我们使用三个不同的Activity，当然是可以的，这不仅意味着我们需要在各个activity之间传递各种各样的参数，而且处理不同Activity之间的沟通会变得十分麻烦，也不利于我们之后对于代码的维护。 此时就轮到Fragment出场了，我们可以在DialingActivity里定义三个Fragment：InComingCallFragment，CallingFragment以及CallEndedFragment，每个Fragment都可以有自己的model和presenter（MVP pattern）而在DialingActivity里，我们可以定义三个Fragment的共同行为逻辑。通过这种方式，可以使整个Activity结构清晰，分工明确，它的结构大概是这样： Activity和Fragment都是关于UI部分的重要组件。一般来说对于一个比较成熟的App来说，其包含的Activity和Fragment可能是成百上千的，所以熟练掌握它们的使用方法是极为重要的。 Fragment LifecycleFragment的生命周期相比于Activity要简单不少，下面分别简单介绍一下各生命周期方法下的作用： onAttach(Context context)：与调用的Activity发生联系，可以通过getActivity()获取调用它的Activity实例； onCreate(Bundle savedInstanceState)：从bundle中获取从Acitivity传来的数据，可用于初始化； onCreateView(LayoutInflater, ViewGroup, Bundle)：创建视图，inflater用于装载局部文件，viewGroup是父标签对象； onViewCreated(View, Bundle)：此时View创建完成，但还没有显示， View就是之前创建的对象； onActivityCreated(Bundle)：窗口初始化已完成，可以通过findViewById()来找到Activity中的view； onStart()：此时UI已经显示在屏幕上，但无法交互； onResume()：可以与用户开始进行交互了； onPause()：可以保存一些临时性的暂定工作，比如播放器的保存音乐播放进度，以便在OnResume里恢复； onStop()：fragment从屏幕上消失； onDestroyView()：移除所有视图，所有在onCreateView中的视图都将被移除； onDestroy()：此时Activity还是和Fragment保持联系的，可以获得Fragment对象，无法进行任何操作； onDetach()：最后一步,执行过后Activity与Fragment不再有任何关联。 此外，关于Fragment生命周期还有几点值得说明： Fragment的引入，主要是为了在大屏幕上显示更加灵活的界面设计，比如在平板电脑上，可以同时并排显示两个Fragment； Fragment必须始终托管在 Activity 中，其生命周期直接受宿主 Activity 生命周期的影响，当Activity暂停时，其所有Fragmenty也会暂停，Activity被销毁时，其所有Fragment也会被销毁。 Dialog相比于Activity和Fragment，Dialog就简单一些。Dialog主要应用于一些临时的对话框，比如向用户询问是否允许开启一些权限AlertDialog，让用户选择一个时间TimePickerDialog，或者自定义界面进行选择DialogFragment。初始化一个简单的Dialog的语法是： 123456789101112131415// 使用Builder class来定义AlertDialog的属性val builder = AlertDialog.Builder(this)builder.setMessage(R.string.your_dialog_message) .setPositiveButton( R.string.ok, DialogInterface.OnClickListener { dialog, id -&gt; // 定义用户按下OK按钮后的行为 }) .setNegativeButton( R.string.cancel, DialogInterface.OnClickListener { dialog, id -&gt; // 定义用户按下CANCEL按钮后的行为 })// 创建一个AlertDIalog实例builder.create() 上面的代码会创建出一个带有两个按钮的对话框，并且根据用户的选择来运行相对应的逻辑。 Dialog LifecycleDialog由于其特殊性，并不存在复杂的生命周期，它在初始化之后显示在用户界面上，随着用户的交互获得结果后被销毁。唯一的例外就是DialogFragment，因为它是Fragment的子类，所以其生命周期遵从于其父类Fragment，这里也就不再赘述了。 参考链接Activity - Google Android 官方说明文档 Fragment - Google Android 官方说明文档 Dialog - Google Android 官方说明文档","link":"/2020/06/16/AndroidBasic2/"},{"title":"Clean Code Summary","text":"Recently I read this book written by Robert C. Martin also known as “Uncle Bob”. In this book it talked about general coding principles to make your code “clean“ and easy to understand. And here is some useful tips and summaries I extracted. Chapter 2 Meangingful Names Use Intention-Revealing Names: avoid nonsense naming Avoid Disinformation: using FULLNAME, avoid abbrevation accountList &gt; accounts &gt; List Make Meaningful Distinctions: ProductInfo and ProductData, Customer and CustomerObject has no difference at all! Use Pronounceable, Searchable Names: the length of a name should correspond to the size of its scope Interface and Implementtations: avoid passing IShapeFactory as interface, using ShapeFactoryImpl in implementation Class Name: Avoid using Manager, Processor, Info, Dataas class name, using noun or noun phrase word One Word Per Concept: Don’t use retrieve, fetchr, get all at same time! It’s horrible! Chapter 3 Functions Small!: Funtions should be very small Avoid nested structures and each block should be one line Function should do one thing can’t extract another function from it witha nmae that is not merely a restatement of its implementation Switch statements: using polymorphism with abstract factory pattern Common Monadic Forms Ask question about argument like boolean isFileExist(File file) Operating on argument, transforming it into something and return like InputStream fileOpen(File file) Interpret function call as event and use argument to alter state of system without output argument like void passwordAttemptFailedNtimes(int attempts) Try to avoid any other form besides those three above Dyadic Forms Sometime reasonable if it’s a natural cohesion or ordering like new Point(0, 0) or assertEquals(expected, actual) It itn’s evil, but it has cost and there always a way to at least convert it to Monadic, just depends on whether it worth or not Argument Objects Using wrapper to wrap into a class of their own see these two following declarations: 12Circle makeCircle(double x, double y, double radius);Circle makeCircle(Point center, double radius); Output Arguments Try not using output argument, if must change state of something, make it change inside it’s own Prefer Exception to Returning Error Codes Error code always force caller to deal with it immediately using using try-catch block, the code to deal with succeed or error will be separated extract try and catch block to its own method should be more clear Chapter 4 Comments Comment should be no need at all It’s always the compensate for failure to express in code Programmer always forget to maintain, which makes them misleading Save the energy to write better and clearer code Chapter 6 Objects and Data Structures Data Abstraction Expose abstract interfaces to allow user manipulate data without knowing its implementation Consider serious which data should be exposed Data/Object Anti-Symmetry Objects: Hide data behind abstractions and expose funtions that operate their data Data: Expose data and have no meaningful functions Procedural code: Easy to add new functions, hard to change data structure Object Oriented code Easy to add new classes, hard to add new functions Need to use both of them properly to make clean code, but not in one class (hybird is the worst!) Chapter 7 Error Handling Use Exceptions Rather Than Return Codes Error code needs to be returned every single case, make the code very complicated and cultter caller Separate detection logic with handle logic Define Exception Classes in Terms of Caller’s Needs Wrapping third-party API is a best practice, easy testing, easy migration and less dependencies Define your own exception type inside wrapper to make handling logic easier outside the wrapper(only one type outside) Null Handling Don’t Return Null: throw an exception or using Special Case Pattern Don’t Pass Null: never pass null in methods Chapter 8 Boundaries Using Third-Party Code Hide the interface inside a class that we can control Avoid when change comes, we need change everywhere Make a Wrapper or Adapter to hide thrid-party interface Learning Test / Boundary Test It’s free and can be used to learning thrid-party code It can be used to detect breaking changes Chapter 10 Classes Class Organization Public static constants Private static constants Public instance variables (if any) Private instance variables Public functions Private function should directly after their caller Class should be small The more ambiguous the class name, the more likely it has too many responsibilities Avoid weasel words like Manager, Processor or Super which will aggregate responsibilities Single Responsibility Principle A class or module should have one and only one reason to change Identity reason to change often helps for better abstraction of our code A system composed of many small , well-structured classes is always better than a few large, multipurpose classes Chapter 11 System (Need revisit in future) Separate Constructing a System from Use it System should not know or care about startup logic, it assume everything should be constructed correctly when start running Using Dynamic Factory pattern to hide the building logic and allow application to decide when and what to build during runtime Dependency Injection: a way to achieve IOC (Inversion of Control) principle: the responsibility of instantiating dependencies will delegate to another “authoritative” mechanism","link":"/2020/04/28/CleanCode/"},{"title":"Clear Architecture - Programming Paradigms &amp; Design Principles","text":"Clean Architecture is one of the series book that written by “Uncle Bob”. In last post, I writed a summary of the Clean Code. It is super useful for begineers. But as we going deeper, we need take a step back and see the “big picture” – software architecture, which is all this book talk about. Part II Starting with the Bricks: Programming ParadigmsStructured Programming: direct transfer of controlConstructed from sequence, selection and iteration to replace old goto keyword. A typical structured programming example: 123456789101112131415// sequence executionval sum = 0val current = 1// iterationwhile (current &lt; 10) { sum += current current += 1}// selectionif (needNegative) { return sum *= -1} else { return sum}return sum All programs can be constructed from just these three structures: sequence, selection and iteration. Object-Oriented Programming: indirect transfer of controlThrough the use of polymorphism to gain absolute control over every source code dependency in the system.To better understnad about power of polymorphism. also check Dependency Inversion Principle below. A typical object-oriented programming example: 123456789101112131415161718192021222324252627282930313233343536// define Vehicle interfaceinterface Vehicle { fun alarm() fun turnOn() fun turnOff()}// different brand of car, should all implement the same interfaceclass BMW: Vehicle { override fun alarm() { makrSound(\"di~di~\") } override fun turnOn() { ... } override fun turnOff() { ... }}// but they can have diffrent implementation (such as differnt alram sound)class Ford: Vehicle { override fun alarm() { makrSound(\"do~do~\") } override fun turnOn() { ... } override fun turnOff() { ... }}// when client code is using them, they don't need to know the implementation detailsFord().turnOn()BMW().ring() Any source code dependency, no matter where it is, can be inverted. Functional Programming: variable assignmentVariables in functional languages do not vary, which will causing none of race condition, deadlock or concurrent update problems. A typical functional programming example: 123456789class Person constructor ( private val name: String) { fun getName(): String { return name }}// define a function to get person's nameval personName = fun(person: Person) = person.getName Concurrent problems can be eliminated by segregate the application into mutable and immutable components. Part III Design PrinciplesSingle Responsibility Principle (SRP) A module should have one, and only one reason to change A common way to impose this principle is: Separate shared functional code blocks from specific logic. For example, here is a Employee class from payroll application: 1234567891011121314class Employee { private val employeeDB = EmployeeDatabase() fun getWorkingHours(): Int { return employeeDB.queryWorkingHours() } fun calculatePayroll(): Int { val workingHours = getWorkingHours() val salaryRatePerHour = employeeDB.querySalaryRatePerHour() return workingHours * salaryRatePerHour } fun saveEmployee() { employeeDB.updateEmpployee(this) }} It’s clear that this Employee class has too many responsibilities including query working hour, query salary rate, calculate payroll, update employee info etc. And typical problem can be: It’s hard to extends, when introduce different ways to calculate payroll for example; Who wants to change ONLY working hours fetching may also touch payroll calculation accidentally; EmployeeDatabase is exposed to Employee class, which is dangerous for open visibility. To solve these issues, we can do: 1234567891011121314class Employee { private val hourReporter = HourReporter() private val payCalculator = PayCalculator() private val employeeSaver = EmployeeSaver() fun getWorkingHours(): Int { return hourReporter.reportHours() } fun calculatePayroll(): Int { return payCalculator.calculatePay() } fun saveEmployee() { employeeSaver.saveEmpployee(this) }} As we can see, after we create HourReporter, PayCalculator and EmployeeSaver, we separate different responsibilities to different class so: if we want to have diffrent ways to calculate payroll, it can be updated inside PayCalculator and no need to update Employee class; when working hours fetching need to change, no need to touch payroll calculation logic; no more database expose to Employee class since it’s handled by these three classes internally. Open-Closed Principle (OCP) A software artifact should be open for extension but closed for modification. This is a common case that sometimes we want to extends part of our code and extends without having to modify that artifact. To make this possible, we need to implement component hierarchy structure so code change in lower level component will not effect higher level component. In other word, higher level component is being protected from code change chain. Let’s continue on the Employee example: 1234567891011121314class Employee { private val hourReporter = HourReporter() private val payCalculator = PayCalculator() private val employeeSaver = EmployeeSaver() fun getWorkingHours(): Int { return hourReporter.reportHours() } fun calculatePayroll(): Int { return payCalculator.calculatePay() } fun saveEmployee() { employeeSaver.saveEmpployee(this) }} It’s easy to understand that HourReporter, PayCalculator, EmployeeSaver classes has higher prority then Employee class and we want to avoid code change on them when we need change Employee class. The UML of structure is like: Note that an arrow pointing from class A (Employee) to class B(HourReporter, PayCalculator, EmployeeSaver) means: the source code of class A mentionas the name of class B, but class B mentions nothing about class A. In this XML, Employee depends on these three classes, so those three classes is protected from changes in Employee. Liskov Substitution Principle (LSP) Subclass should be substitutable for their base class A typical example of this principle is square/rectangle problem, let’s briefly recall the problem first by UML: As common sense, a Square should be treated as a special Rectangle which means all operations or parameters for a rectangle object should also effect on a square object. Let’s see the code block below: 1234val rectangle = Rectangle()rectangle.setWidth(2)rectangle.setHeight(5)assert(rectangle.getArea() == 10) This should work fine and the assertion should pass as well, but when we do the same thing to a Square like: 1234val square= Square()square.setSide(2) // how can width and height change at same time???square.setSide(5)assert(rectangle.getArea() == 10) // this will failed and area will be 25 The core problem behind this case is : square has a feature which rectangle don't: need set both width and height always at same time with same value, they can't be changed separately. It may causing a lot problems becuase of this. Interface Segregation Principle (ISP) No client should be forced to implement methods it doesn’t use When we play with abstract interfaces and implementation, a common problem is we find there are extra methods that the implementation not used at all. The easiest way to handle it is just override it and make it empty. But by doing this, there is a risk that it might be touched by other maintainers or even yourself in future since you may not remember. A good fix on this should be separate it into multiple specific interfaces like: In my opinion this is a good way to minimum the risk and separate interface for different class if they not use all of them, but also note that this might causing a lot interfaces to be generated, this is the trade-off. Dependency Inversion Principle (DIP) High-level module shouldn’t depend on low-level, but both should only depend on abstraction, not on concretions This is the most information principle in my opinion and also the hardest one to understand. To understand this, first question is: what is abstraction and why we need it? To answer this, let’s see this example UML: This is the concrete implementation for an application with a simple service. Service is created by ServiceFactory by calling serviceFactory.createService(). It works fine but it has several problems: Application can access everthing inside Service and ServiceFactory, it including something they don’t use (violation of ISP); Both Service and ServiceFactory are dependencies of Application, which means when their code changed, Application will need to re-comple and re-generated everytime (violation of OCP); If we want to add new type of service in future, both Application and ServiceFactory need change the code and still hard to extends (violation of OCP again). So according to what we learned before, here is a better solution for all three points above: As you can see in the solution UML, we make both ServiceFactory and Service as Interface and give them implemnentations for each interface. Note that implementation is hided from Application so it only communicate with interfaces. Why? Look back into all three problems above and you will find all of them is successfully solved by using Interface! Now let’s understand the description of this principle with the example: consider Application as low-level module and ServiceFactory, Service as high-level module, Application should not depends on ServiceFactory and Service because of the violation of ISP, OCP and DIP, and they should all depends on the abstraction, which is Interface in this case. And by using interface, the control flow is successfully inverted from Application -&gt; ServiceFactory to ServiceFactoryImpl -&gt; Application, same for Service as well. This is how Inversion come from.","link":"/2020/05/11/ClearArchitecture1/"},{"title":"clearArchitecture - Desgin Principles &amp; Component Principles","text":"In last post we talked about programming paradigms and SOLID principles. This is far more than enough to understand about architecture, so today let’s continue on “Design Principles” and see more of them that need to follow when thining like an architect. Part III Design Principles","link":"/2020/06/06/ClearArchitecture2/"},{"title":"Dependency Injection","text":"Dependency Injection is a huge topic in Android development and it’s very important because it can give us a clean, well-designed, easy-to-change environment no matter we develop new features or implement any testing. So here is some thoughts about DI and an useful framework which helps you do all dirty jobs behind the scene. What is Dependency InjectionBefore answering this question, a better question to ask might be: What is dependencyTo answer this question, let’s take a look at this Kotlin code here: 12345678910111213class SimpleFeature constructor( val businessLogicDelegate: BusinessLogicDelegate, val validator: Validator, val listener: Listener) { fun doSomeThing() { val helper = Helper() if (validator.validate()) { businessLogicDelegate.doSomething(helper, listener) } }} This is a very common secenario in real life: I have a class and serveral parameters in its constructor, I need call some methods of those parameters inside this class. At the same time, I also need initialize a helper class inside and use it. In this case, both the parameters and helper class will be considered as the Dependency of SimplyFeature class. Cause this SimpleFeature needs “depend on“ something to finsh its own job. In another word, if any class’s method is called inside a class A, those class will be considered as A’s dependency. So now I know dependency, what is dependency injection?Let’s look back to this code again: 12345678910111213class SimpleFeature constructor( val businessLogicDelegate: BusinessLogicDelegate, val validator: Validator, val listener: Listener) { fun doSomeThing() { val helper = Helper() if (validator.validate()) { businessLogicDelegate.doSomething(helper, listener) } }} There are two main issues in this code block: Inside the doSomeThing(), we need to initialize a Helper class to help finishing business logic. This can work for sure, but if this helper needs to be a static class, or I need to using a Signleton helper class, here, how can I use it? When writing unit test with Mockito or Mockk, a common way is passing in a “mock“ instance and testing if the expected method of this mock is called with correct parameter. But how can we pass in the mock of Helper class if the new operator is called inside? To solve these problems, what can we do? Just simply pass a helper instance in the constructor so it can become the dependency of SimpleFeature as well! The constructor will look like this: 12345678910111213class SimpleFeature constructor( val businessLogicDelegate: BusinessLogicDelegate, val validator: Validator, val listener: Listener, val helper: Helper) { fun doSomeThing() { if (validator.validate()) { businessLogicDelegate.doSomething(helper, listener) } }} Now it looks great! I can pass in any Helper class and also mocking it and do the unit test! Nice! Now we can make a conclusion here: Dependency Injection means:Passing the dependency into the class and use it One thing need to mention here is: passing through class’s constructor is only one of the way to do DI. More details about this concept can be find here. How can I use dependencies injection?To use dependencies injection effectively, let me introduce this super-useful library here: This Dagger 2 library are powerful for android application dependency injection, by using this, all we need to do it’s define each class’s dependency list and the scope to use it. All other stuff will be handled by this library automatically and anonymously. So how to use it? First, we need to have a module class: 12345678910111213141516@Moduleinterface MainModule { @Binds fun providesBusinessLogicDelegate(businessLogicDelegateImpl: BusinessLogicDelegateImpl): BusinessLogicDelegate @Binds fun providesValidator(validatorImpl: ValidatorImpl): Validator @Binds fun providesListener(listenerImpl: ListenerImpl): Listener @Binds fun providesHelper(helperImpl: HelperImpl): Helper} What is this Module use for? Basically this is the place you want dagger helps you to initialize all your dependency. There are two ways to initial dependency in dagger, one is through @Bind annotation and another is @Provides. In here I’m using @Binds since it’s much simpler if all dependencies has implement an interface. Then we need another class which is called componenet class: 1234567@Component (modules = [MainModule::class])interface MainComponent { fun inject(activity: MainActivity) fun inject(feature: SimpleFeature)} Inside this Component, the inject() method defines “where those dependencies should be injected to”. And following the @Component annotation we can declare all modules that can be included, so we can inject multiple module’s dependencies inside one single class that called by inject() method. So far so good! After create these two classes above, we defined What is the dependency and Where should we inject into. Now the final step will be refactor our SimpleFeature class: 12345678910111213class SimpleFeature @Inject constructor( val businessLogicDelegate: BusinessLogicDelegate, val validator: Validator, val listener: Listener, val helper: Helper) { fun doSomeThing() { if (validator.validate()) { businessLogicDelegate.doSomething(helper, listener) } }} Since all parameters inside the constructor are initialized in module class and the injection of this feature class also declared in component class, the only change needed in here is add @Inject annotation before constructor, then dagger knows that all parameters can be find in module and injected by component magically. Done! Now enjoy inject any dependency you want! Now there are still some notes worth mention here: What we using here is just a very brief introduction of Dagger, it has a lot powerful methods and tools that worth to try and play with it. More detail should be found in here One of the very useful feature of Dagger is @Scope annotation. It can be used in complicated structured project to define different scope for different dependencies to access. This part will be added in future as a follow-up of our DI topic. The main purpose of DI is align with one of the basic SOLID principle in softwate development, which is know as Dependency Inversion Rules. This principle states: High-level Module should not depends on low-level module, both should depend on abstractions (interface); Abstractions should not depend on details. Details (concrete implementation) should depends on abstraction. We will cover all these principles one by one in future, they are very important in industrial software development world. Although there are tons of advantages in DI, but it has its limit or disadvantage for sure. For example, when dependency is missing, it’s hard to find out which dependency is missing by checking the build output. So at this time, log is very useful to check.","link":"/2020/02/28/DependencyInjection/"}],"tags":[{"name":"Android","slug":"Android","link":"/tags/Android/"},{"name":"Chinese","slug":"Chinese","link":"/tags/Chinese/"},{"name":"Clean Code","slug":"Clean-Code","link":"/tags/Clean-Code/"},{"name":"Reading","slug":"Reading","link":"/tags/Reading/"},{"name":"English","slug":"English","link":"/tags/English/"},{"name":"Clean Architecture","slug":"Clean-Architecture","link":"/tags/Clean-Architecture/"}],"categories":[]}