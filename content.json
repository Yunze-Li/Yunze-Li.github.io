{"pages":[{"title":"your name","text":"导语 正文 ###参考文章 链接link","link":"/template.html"},{"title":"categories","text":"","link":"/categories/index.html"},{"title":"tags","text":"","link":"/tags/index.html"}],"posts":[{"title":"Android开发笔记（二）- UI Components","text":"之前的Android开发笔记之基础篇(一)中主要讲到了一些关于Android Components的基本概念以及它们的异同。今天就来讲解一下关于Activity中涉及UI部分的三个核心组件：Activity，Fragment和Dialog。它们基本承担起了APP中所有的图形界面和交互逻辑，也是面向用户最直观的展现。 Activity前面我们说到过，在Activity中定义了与用户交互的所有逻辑（Presentation Layer Logic）。举个例子，我们想做一个电话本App，那么就需要设计当用户点击某个按钮时，其背后发生的一切逻辑，而这些定义都包含在Activity中。那么，一个Application中可以包含多个Activity么？答案当然是可以的，而且是几乎必须的！想象一下在这个Application中可能会出现的界面包括： 基本的浏览电话本页面（DashboardActivity），显示一个联系人的列表； 当选中一个电话时，要显示一个详细联系人的页面（ContactActivity）； 点击电话号码时，弹出一个拨打电话的界面(DialingActivity)； Dashboard里要有一个“编辑”按钮，点击后弹出一个新建联系人界面（NewContactActivity） 可以看出，这每一个单独的界面，都是一个专门的Activity。也正是因为一个APP中有多个Activity的存在，才使整个安卓App的架构变得更加清晰，也更有利于我们阅读，重构以及debug。 对于一个Activity来说，可以采用多种不同的设计模式（Design Pattern）比如MVC，MVVM以及MVP。这其中我个人非常喜欢MVP（Model-View-Presenter）来设计代码。对于不同的Activity，出于解耦（De-coupling）的考虑，通常将它们放入不同的package中，方便区分以及日后对它们分别进行重构。像如上我们举例的电话App，它的结构大致就是这样： 在上一次我们说到，AndroidManifest这个文件里定义了所有App所需要的Activity，Service，BoardcastReceiver, ContentProvider等等，所以不要忘记在创建完Activity之后，一定要在Manifest里面把它声明好。 Activity Lifecycle关于生命周期（Lifecycle），我们只需要知道它定义了一个组件什么时候被初始化，什么时候对应什么状态，以及应该在何时进行何种操作即可。Activity的生命周期如下图所示： 让我们来一步步说明一下各生命周期方法的作用： onCreate()：必须实现，主要用于初始化activity以及设定各种参数； onRestart()：onStop()后如果没有被kill，会从这里唤醒，早于onStart()； onStart()：系统正在启动，UI已显示，但无法交互； onResume()：UI已显示，用户可以进行交互，而如果在Acitivity内部初始化其他Dialog或Fragment时，不论activity是否全屏，它都会保持在此状态； onPause()：最好在此释放CPU，保存数据； onStop()：activity完全从前台结束，看不见时进入此状态； onDestory()：activity被完全销毁，可以做回收和最终释放。 另外值得注意的一点就是：当设备进行横竖屏切换时：acitivity会销毁并重新初始化。如不销毁，需在manifest对应的activity内部声明configChange=“orientation | screenSize”, 此时onConfigurationChanged()会被call。 Fragment在说完Activity之后，下面我们要说一下Fragment这个重要的component。在各种Android的档案定义里，都会反复出现对于Fragment的定义：A Fragment represents a behavior or a portion of user interface in a FragmentActivity. You can combine multiple fragments in a single activity to build a multi-pane UI and reuse a fragment in multiple activities. 但是我一直就觉得这个解释非常不明确，为什么我们需要用Fragment呢？我个人的理解是：当在一个Activity内有多个单独显示的页面，并且每个页面与用户交互的逻辑都各不相同时，Fragment可以帮助我们减少很多麻烦，将整个Activity的架构变得十分清晰。这是我认为Fragment最为有用的一点。 还是以前面的电话本App为例，在拨打电话的界面DialingActivity中，可能会分为三个阶段： 接收到来电（InComingCall） 电话被接通（Calling） 通话结束（CallEnded） 根据需求不同，这三个阶段的界面可能会有完全不同的UI布局，每个按钮也可能会有不同的功能，但是它们同属于一个打电话的功能之中（DialingActivity）。此时如果我们使用三个不同的Activity，当然是可以的，这不仅意味着我们需要在各个activity之间传递各种各样的参数，而且处理不同Activity之间的沟通会变得十分麻烦，也不利于我们之后对于代码的维护。 此时就轮到Fragment出场了，我们可以在DialingActivity里定义三个Fragment：InComingCallFragment，CallingFragment以及CallEndedFragment，每个Fragment都可以有自己的model和presenter（MVP pattern）而在DialingActivity里，我们可以定义三个Fragment的共同行为逻辑。通过这种方式，可以使整个Activity结构清晰，分工明确，它的结构大概是这样： Activity和Fragment都是关于UI部分的重要组件。一般来说对于一个比较成熟的App来说，其包含的Activity和Fragment可能是成百上千的，所以熟练掌握它们的使用方法是极为重要的。 Fragment LifecycleFragment的生命周期相比于Activity要简单不少，下面分别简单介绍一下各生命周期方法下的作用： onAttach(Context context)：与调用的Activity发生联系，可以通过getActivity()获取调用它的Activity实例； onCreate(Bundle savedInstanceState)：从bundle中获取从Acitivity传来的数据，可用于初始化； onCreateView(LayoutInflater, ViewGroup, Bundle)：创建视图，inflater用于装载局部文件，viewGroup是父标签对象； onViewCreated(View, Bundle)：此时View创建完成，但还没有显示， View就是之前创建的对象； onActivityCreated(Bundle)：窗口初始化已完成，可以通过findViewById()来找到Activity中的view； onStart()：此时UI已经显示在屏幕上，但无法交互； onResume()：可以与用户开始进行交互了； onPause()：可以保存一些临时性的暂定工作，比如播放器的保存音乐播放进度，以便在OnResume里恢复； onStop()：fragment从屏幕上消失； onDestroyView()：移除所有视图，所有在onCreateView中的视图都将被移除； onDestroy()：此时Activity还是和Fragment保持联系的，可以获得Fragment对象，无法进行任何操作； onDetach()：最后一步,执行过后Activity与Fragment不再有任何关联。 此外，关于Fragment生命周期还有几点值得说明： Fragment的引入，主要是为了在大屏幕上显示更加灵活的界面设计，比如在平板电脑上，可以同时并排显示两个Fragment； Fragment必须始终托管在 Activity 中，其生命周期直接受宿主 Activity 生命周期的影响，当Activity暂停时，其所有Fragmenty也会暂停，Activity被销毁时，其所有Fragment也会被销毁。 Dialog相比于Activity和Fragment，Dialog就简单一些。Dialog主要应用于一些临时的对话框，比如向用户询问是否允许开启一些权限AlertDialog，让用户选择一个时间TimePickerDialog，或者自定义界面进行选择DialogFragment。初始化一个简单的Dialog的语法是： 123456789101112131415// 使用Builder class来定义AlertDialog的属性val builder = AlertDialog.Builder(this)builder.setMessage(R.string.your_dialog_message) .setPositiveButton( R.string.ok, DialogInterface.OnClickListener { dialog, id -&gt; // 定义用户按下OK按钮后的行为 }) .setNegativeButton( R.string.cancel, DialogInterface.OnClickListener { dialog, id -&gt; // 定义用户按下CANCEL按钮后的行为 })// 创建一个AlertDIalog实例builder.create() 上面的代码会创建出一个带有两个按钮的对话框，并且根据用户的选择来运行相对应的逻辑。 Dialog LifecycleDialog由于其特殊性，并不存在复杂的生命周期，它在初始化之后显示在用户界面上，随着用户的交互获得结果后被销毁。唯一的例外就是DialogFragment，因为它是Fragment的子类，所以其生命周期遵从于其父类Fragment，这里也就不再赘述了。 参考链接Activity - Google Android 官方说明文档 Fragment - Google Android 官方说明文档 Dialog - Google Android 官方说明文档","link":"/2020/06/16/AndroidBasic2/"},{"title":"Android开发笔记（一）- 四大组件","text":"因为最近开始系统地学习Android开发，所以在这里记录一下所学到的Android内容做一个整理。既算是对已学到知识的总结和梳理，也可以检查自己理解中出现的问题，和大家共同讨论一下。因为是第一次写东西，所以有什么不详细，不清楚，不准确的地方，还希望可以指正，我们共同讨论，共同进步。 本篇文章大部分的内容都是基于自己通过Google官方说明文档，StackoverFlow, CSDN等网站的阅读获得的，希望通过我个人的理解，让这些知识更容易被读者所理解和接受。 Application Structure进入Andorid的第一个需要理解的知识，也是我个人认为最为重要的基础知识之一，就是了解Android application的架构。构成一个完整安卓APP的，是各种各样不同的Component（组件），这些Component分别承担着不同的工作和职责，比如负责与用户进行交互的Activity，负责后台相关工作的Service，负责监听传递信息的BoardcastReceiver， 以及存储读取数据的ContentProvider等等。 我们用一个简单的例子来解释一下：如果说现在需要做一个负责计算汇率转换的Android应用，那么其对应的组件功能分别为： 首先要实现汇率转换的功能，我们就需要一个让用户输入金额大小，选择转换货币类别的界面，这就是CurrencyConvertActivity，在其中定义了一切UI与用户进行交互的逻辑； 接着我们想在后台服务器实时获取当前的汇率数据信息，那么就需要一个BoardcastReceiver来随时向服务器发送请求获取当前最新的汇率信息并传送给CurrencyConvertActivity，用来计算金额； 如果我们想在App启动时根据系统中用户设定的当前国家来显示对应的国家货币，并且在用户切换国家/时区时在APP内进行实时更新，就需要建立一个CountryChangeReceiver来监听TIMEZONE_CHANGED系统事件并在监听到切换国家/时区时进行识别； 如果我们想将实时获得的汇率进行缓存，以便在网络环境恶劣的情况下获得最近一次实时汇率表，那么就可以使用ExchangeRateContentProvider将汇率数据进行保存和处理 现在整个Application的架构大致就是这样: 123456789101112131415161718192021222324252627282930313233&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; package=&quot;com.yunze.myapplication&quot;&gt; &lt;application android:allowBackup=&quot;true&quot; android:icon=&quot;@mipmap/ic_launcher&quot; android:label=&quot;@string/app_name&quot; android:roundIcon=&quot;@mipmap/ic_launcher_round&quot; android:supportsRtl=&quot;true&quot; android:theme=&quot;@style/AppTheme&quot;&gt; &lt;activity android:name=&quot;com.yunze.myapplication.CurrencyActivity&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt; &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;service android:name=&quot;.BackendService&quot;&gt; &lt;intent-filter /&gt; &lt;/service&gt; &lt;receiver android:name=&quot;.CountryChangeReceiver&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.TIMEZONE_CHANGED&quot; /&gt; &lt;/intent-filter&gt; &lt;/receiver&gt; &lt;provider android:name=&quot;.ExchangeRateContentProvider&quot; android:authorities=&quot;.ExchangeRateDB&quot;&gt; &lt;/provider&gt; &lt;/application&gt;&lt;/manifest&gt; 上面显示的这个AndroidManifest.xml，可以理解为一个Android Application的“骨架”。正如我们之前所说，Activity，Service，BroadcastReceiver和ContentProvider可以算是Android Application的四大“组件”。而AndroidManifest.xml文件则正是申明这个App所使用的所有组件的地方，所以当我们开始上手一个新的安卓项目时，应该要从AndroidManifest.xml开始看起，才能比较详尽全面地了解这个App。 Android Components下面具体来比较一下不同的组件之间的关系，让我们有更进一步的了解。 Activity：整个Android开发中最为重要的一个概念。Acitivity中定义了App与用户的交互逻辑，例如当用户点击当前这个按钮，应该发生什么事，是显示一个文本框，更改图片的颜色，或者关闭当前界面回到上一个界面等等。可以说：所有关于用户交互的逻辑全部都只能定义和存在与Activity之中。 Service：如果我们的APP中需要一个长时间运行在后台来处理业务的功能，比如频繁向服务器发送请求，或者需要等待服务器随时返回请求，或者要长时间从服务器加载大型文件（比如在线浏览视频），此时就需要用到我们的Service组件。Service组件最重要的特征就是：可以长时间的运行在后台进行服务，直到完成任务后将自己结束，并且其中不能定义任何与用户UI有关的内容。 BroadcastReceiver: 这可能是四个组件中比较不好理解的一个，其实可以把它想象成APP的一根“天线”，它的功能就是主动接受其他APP传来的特定“信号”。比如我们之前说的TIMEZONE_CHANGED这个event，当安卓系统检测到用户手机切换了时区时，就会向整个系统内广播这个TIMEZONE_CHANGED event，此时如果我们的APP中含有一个注册了TIMEZONE_CHANGED的BroadcastReceiver，那么这个receiver就会被触发并完成一系列我们定义好的逻辑。 ContentProvider：这个组件一般为存储和获取数据提供统一的接口，可以在不同的应用程序之间共享数据。通过这个接口，其他应用看不到数据是如何存储的, 但通过ContentResolver可以对其进行包括：添加(insert), 删除(delete), 获取(query), 修改(update) &amp; 返回MIME类型(getType)等一系列的操作。在这个组件中，所有文件都是通过URI来识别，结构为: content://授权信息/表名/记录。 这里要稍微说一下BroadcastReceiver与Service的区别，它们都是运行在后台，不带有任何UI的组件。但是Service作为消息的接收方是只能被单独触发的，而不同的BoardcastReceiver却是可以被一起触发的，前提就是它们都注册了同一个event。下面是在看他人的总结介绍时看到的一张很有意思的图： 从这张图上来看，有几点值得我们特别注意的： 只有Activity才可以启动一个新的Activity（理论上讲其实是有其他办法可以从Service和BoardcastReceiver中启动的，但是这里说的不是“能不能”，而是“是否应该”），当我们创建一个新的Android项目时，都会自动生成一个MainActivity，所有关于APP的行为和逻辑都应该在这个或者几个Activity内来完成，项目也会有一个Application类，这个类一般是作为各种Activity的容器来使用，不要轻易将代码逻辑写在Application里；而启动新的Activity的方式就是在StartActivity()方法中传递一个Intent类，这个下面会讲到。 只有Activity才可以Layout Inflation。这个也比较好理解，因为前面说过，只有Activity才能处理和用户的交互，显示所有的UI和Layout（其实所有的UI都只能run在UI Thread，也就是Main Thread上，而只有Activity可以access到Main Thread，所以当然只有它可以处理UI的部分）。当然也是有Tricky way来做的，比如call runOnUiThread()之类的，之后等到写multi-thread的时候会涉及这部分。 Broadcast Receiver所监听的Event一般来说是向全系统广播的一些事件，比如手机连接好了WIFI，手机外接了电源等等。当然也可以监听自定义的event，但是根据我们前面说的用途，自定义的情况比较少，毕竟没有必要只向自己的一个service或者activity进行广播。 Communication between Components下面我们来了解一下各组件间的通信方式，所谓“通信”，其实就是指：1. 从一个组件向另一个组件传递参数；2. 从一个组件生成另一个新组件。传递参数的方式有很多，但是生成组件的方式却很有限： Activity启动一个新的Activity的方式主要就是通过 startActivity() 或startActivityForResult() 方法并传递一个Intent实例。这两个方法的主要区别在于是否需要从新的activity返回一个结果，比如通过新的activity选择一张本地存储的图片，或者通过新的activity确定一个文件是否已经发送完毕等等。Intent中包含了新的Activity的类名以及一些初始化需要的数据(Extra)。 通过putExtra()方法可以将这些数据传入Intent，从而传递给新的Activity。 Service启动一个Service的方法大致有三种： 直接开启：通过startService()方法并传递一个Intent实例，这个方法和Activity基本一致； 绑定开启：通过bindService()方法并传递一个Intent实例，绑定开启与直接开启的一个最大的区别就是：绑定开启的service会在开启它的组件生命周期结束时随之结束，而直接开启则不会。实际上，直接开启的service会一直运行，直到stopService()被执行，或者App被卸载。 JobScheduler调度：在Android 5.0+中，可以通过JobScheduler中的schedule()方法来启动一个service，这个方式目前我还没有用到过，以后如果涉及到再单独写一篇吧。 BroadcastReceiver启动BroadcastReceiver的方式和Activity基本一致，区别在于可使用的方法更多，其中包括：sendBroadCast()，sendOrderedBroadcast()以及sendStickyBroadcast()，也都需要传递Intent实例到各个方法中。Broadcast有一个不同点在于静态注册/动态注册，之后会专门写一篇讲它。 ContentProvider这个组件和其他组件不同，因为它只是一个接口，所以其不需要进行启动或者初始化。而使用ContentProvider的一般步骤包括： 创建一个实现ContentProvider接口的类，并实现接口中的各个方法（insert()， delete()， query()等）; 在AndroidManifest.xml中进行注册； 通过getContentResolver().query(URI)方法就可以直接获得定义的ContentProvider中的数据。 参考链接Application Fundamentals - Google Android 官方说明文档","link":"/2020/06/10/AndroidBasic1/"},{"title":"Android开发笔记（四）- Layout布局","text":"在Android开发的大部分场景里，我们需要构建各种各样的UI界面用于与用户进行交互。很多UI设计看起来很简单也很清晰，但一旦开始上手设计，就会发现：设计师轻松画出的各个UI组件，它们的排列，间隔，对齐，大小，其实没有那么容易摆放正确。再加上对于安卓系统的手机，屏幕大小尺寸更是多种多样。这是我们就需要用到页面布局（UI Layout）这个工具。那么今天就来看看Android中关于页面布局的一些概念和知识。 四种常见的Android Layout布局在Android开发环境中，一个UI layout布局页面以xml文件的格式存于：你的工程路径/main/res/layout里面。xml文件的具体格式这里不再赘述，但是要具体对于不同种类的Layout稍微解释一下： LinearLayout第一种是LinearLayout，这种布局一般来说是最简单，直接，快速的一种，当新建一个layout布局文件时，Android Studio默认的布局文件即为这种LinearLayout。顾名思义，这种布局最适用于线性的UI呈现方式，比如如下的布局： 对于这种只需要横向(Horizontal)或纵向(Vertical)排列的布局，LinearLayout可以说是最适合不过的选择了，它减少了很多处理各部件之前位置关系的参数声明，只需按需调整当前部件和上一个部件之间的位置关系，直到完成布局即可。简单来说，LinearLayout就像堆积木，你只需要沿某一个方向不断堆砌你的subview，并给每个subview规定好边距等参数即可。但是需要注意的是：这种Layout类型不允许在同一层内堆多个subview。如果需要的话，要使用下面的RelativeLayout。 RelativeLayout第二种是RelativeLayout，这种布局的特点在于：各部件之间的位置关系主要靠定义与其同布局的其他部件(Sibling)的位置关系来决定。比如我们在定义下面这样一个页面： 类似如上的界面一般会出现在列表（List）中，对于这种布局我们希望view 1和view 3的左边界对齐，而view 2和view 3的右边界对齐。至于整体布局的高度我们并不是十分介意（一般这种布局会采用上滑显示更多的RecyclerListView，这个以后会继续讲到）。所以此时RelativeLayout就可以通过声明 android:layout_toLeftOf 以及 android:layout_toRightOf 来限制组件间位置关系，从而达到我们想要的效果。 RelativeLayout顾名思义，在定义同一个subview内的不同组件间相对位置关系时非常有效。但在使用时需要处理好相对位置关系间的冲突，一般需要花费一些时间用于调整相对的位置关系。这种布局的使用方法在面对稍微复杂一点的UI界面时相比LinearLayout更灵活，更高效。 FrameLayout第三种是FrameLayout，这种布局一般应用于多层嵌套的视图布局。其实上面介绍的两种视图也可以用于层叠（Overlap）效果，对于到底使用哪种布局在一些特定的应用场景下也会有所不同。但我的理解是: FrameLayout对于层叠场景会有更好的表现和处理方式，在FrameLayout中也会有更多不同的声明方式来进行布局，而一般的RelativeLayout来定义层叠的位置关系会变得很复杂。所以不妨分离出所设计的页面中的层叠部分，来用FrameLayout完成，而其他的部分则采用RelativeLayout。 将你的页面进行分离，使用不同的UI布局框架来定义不同的子页面，也是UI设计布局中十分重要的一步。决定好使用的框架会让你的UI设计变得简单易懂，并且易于改动。相信很多人都遇到过改UI的时候一改就要动到所有的框架这种十分痛苦的事情。 ConstraintLayout最后一个，也是我认为最为重要，功能最为强大的一个，就是ConstraintLayout。ConstraintLayout和其它布局方式最明显的区别在于，它需要对于每一个组件声明布局的constraint，这些constraints会按照优先级被执行并布局。但是必须声明得比较完备，才能获得想要呈现的效果（也正是因为需要声明的constraint比较多，所以ConstraintLayout可以比较好的大部分在App中我们想要呈现的布局效果）。 在ConstraintLayout中，当定义一个组件的时候，可以通过声明app:layout_constraintXX_toXXOf来定义其相对于另一个组建的位置，同时也可以通过声明android:layout_marginXX来定义其相对边距，其用法是十分灵活的。ConstranitLayout在进行诸如边缘对齐，居中，各子视图(subview)平均分配等功能时十分有效，目前可以说是我最喜欢使用，也最经常使用的一种布局框架。","link":"/2020/07/02/AndroidBasic4/"},{"title":"Android开发笔记（三）- Multi-thread","text":"今天的内容是这周工作中出现的一个相关内容的学习：多线程（Multi-thread）。多线程可以极大地减少程序在并发执行时所付出的时空开销，提高操作系统的并发性能。在Android的开发中，多线程是非常重要的一环，而相信很多人也在面试中被问到过不止一次进程（Process）与线程（Thread）的区别。那么我们就来看看和Android相关的多线程组件Process，Thread，Looper，Handler各自的概念和实例。 Process vs Thread进程（Process）是多线程的第一个概念。简单来说，进程是指计算机中已经运行的程序，而对于安卓系统，一般一个Android应用程序就是一个进程，其中包含多个线程协同工作。 线程（Thread）是一种轻量级的子进程，是一个基本的CPU执行单元 &amp; 程序执行流的最小单元，也是独立运行和独立调度的基本单位。在Android的环境里，一个线程可以理解为一群任务的有序集合，所有线程共享进程所拥有的系统资源和存储资源，各线程之间通信快速高效。当这个线程的任务全部执行结束时，线程就会被终止。 Android Multi-threadAndroid系统中的线程分为两类：主线程（Main Thread）和其他子线程。 主线程也叫UI线程，在Android APP启动时会自动生成，主要负责处理Android四大组件（可以看这篇中关于四大组件的介绍）与用户进行交互的事件响应与逻辑，所以也叫主线程也叫UI线程。要注意的是，因为用户随时会与界面发生交互，因此主线程任何时候都必须保持很高的响应速度，所以主线程不允许进行耗时操作，否则会出现ANR（ApplicationNotResponding）异常。 子线程就是APP的工作线程，子线程都是APP运行过程中手动创建的线程，可以在其中处理一些耗时的操作例如网络请求、I/O操作等。可以通过使用RxJava等函数库来创建用于不同操作的特定子线程。 在Android官方声明中，对于多线程编程时有两大原则： 不要阻塞UI线程（即主线程）：主线程被阻塞超过5s则会出现ANR错误； 不要在UI线程之外更新UI组件。 那么现在我们来看看如何在代码中创建一个子线程吧。代码如下： 123456789package com.example.yunzeli.testapplicationpublic class MyWorkingThread extends Thread { private boolean isRunning; @Override public void run() { // 开始线程的工作 }} 可以看到，我们真正需要做的，就是继承Thread这个类，并实现run()方法。将我们需要做的工作在run()里完成即可，这个方法简单方便，但是却有一个问题：上面我们说过，当这个线程的任务全部执行结束时，线程就会被终止，那么如果我们需要在工作线程完成当前工作后不被中止，而是继续等待新的任务到来呢？那么就可以这样： 123456789101112131415package com.example.yunzeli.testapplicationpublic class MyWorkingThread extends Thread { private boolean isRunning; @Override public void run() { isRunning = ture; while (isRunning) { // 开始线程的工作 // 线程的工作完成后 isRunning = false; } }} 上面的代码中，我们通过设置一个isRunning的flag，可以用循环的方式来block住这个线程，然后等待新的任务到来。很好，现在我们有了一个独立运行的，随时可以使用的工作线程。但事实上，Java代码库里给我们提供了一个更加简单清晰，并且可靠的类，这就是Looper。 Looper从上面的内容我们知道，要想将一个线程block住，我们需要用looping将其不断循环并等待新的任务。在Android的开发包里，就有一个设计好的Looper类供我们使用。这个Looper一直在不停的循环并监听新来的task，每个Looper都有一个messageQueue用来存放分配的task，也叫做Message。Looper的使用有两个基本原则： 每一个Thread有且只能有一个Looper； 当想让某一个Thread执行某个任务时，就将message传送给对应Looper的messageQueue。 Looper在thread的具体使用方法如下： 12345678910111213141516package com.example.yunzeli.testapplicationimport android.os.Looperpublic class MyLooperThread extends Thread { @Override public void run() { // prepare the loop Looper.prepare(); // start looping Looper.loop(); // do your staff here... }} Looper.prepare()：检查当前这个thread是否已经分配好looper，如果没有，则新建一个looper来监听这个thread； Looper.loop()：looper开始监听当前线程，开始处理收到的message； 简而言之，Looper的作用就是一直looping and keep thread alive。值得注意的是，Main Thread也就是UI线程，是已经初始化了MainLooper的。所以不需要对于Main Thread进行任何的操作，Android系统已经帮我们都处理好了。 MessageQueue &amp; Handler说完了Looper，现在我们来说说Looper里面的一个重要概念：MessageQueue。当我们想向一个thread里派送一个新的task时，Java规定了我们只能派送如下两种类型：Message和Runnable。那么，我们如何将这两种类型的实例派送到目标线程的messageQueue里呢？这里就用到了另一个重要概念：Handler。Handler的功能相当于一个装配器，它可以将任意继承了Message或者Runnable类的实例放入其监听的Looper的messageQueue里，例如： 12345678910111213141516171819202122232425262728293031323334353637383940public class MyLooperThread extends Thread { private static final int MSG_1 = 1; private static final int MSG_2 = 2; @Override public void run() { // prepare the loop Looper.prepare(); // start looping Looper.loop(); // send message here Handler handler = new MyHandler(); handler.obtainMessage(MSG_1).sendToTarget(); handler.post(new Runnable() { @Override public void run() { // do something here... } }); } class MyHandler extends Handler { @Override public void handleMessage(Message message) { // switch your message type here switch(message.what) { case MSG_1: // do something here... break; case MSG_2： // do something here... break; default: } } }} 由上面例子可见，Handler通过obtainMessage(Message msg)的方法来传送message实例，用post(Runnable runable)的方法来传送Runnable实例。那么，Handler如何知道所要传送的目标thread呢？Android官方文档里写的很清楚，Handler有两个默认的构造器（constructor），如果使用new Handler()的话，则当前线程就会成为创建的Handler的目标线程；而如果使用new Handler(Looper looper)的话，则传入的looper对应的线程就会作为创建的Handler的目标线程。总结一下，Hanlder的作用主要就是两点： 从任意thread中将message或者runnable传入其对应的looper的message queue中； 获取其对应looper的message queue中的下一个task（message或runnable）并执行对应的操作。 需要强调的一点是：虽然一个thread只能有一个对应的looper，但是一个looper却可以同时被多个Handler所引用（允许将同一个Looper传入多个Handler的构造器）以便指定给同一thread的不同handler分别处理不同的message或者runnable。这样的设计也方便了我们对于多个task的处理。 Message &amp; Runnable最后关于Message和Runnable再简单介绍一下： 当我们希望在一个thread里执行一段代码（task）时，Android OS 规定了这两种类型作为传入的参数。Message的使用方式在于：我们预先在Handler里定义好了如何处理这个MESSAGE_TYPE的逻辑，然后将对应的MESSAGE_TYPE传入。个人理解比较像是pre-define了一个处理逻辑，然后只需要传入对应message就可以trigger这个task；而Runnable是一个Interface，当我们传入时，则需要重写它的run()方法并将我们想执行的代码逻辑写在里面。 关于这两种方式的区别，个人认为主要取决于这段逻辑是否需要传入动态变化的参数：比如，如果是执行例如显示一个文本框并高亮这种固定的，静态的逻辑，那么message的方法是比较好的选择。但如果执行根据用户输入值来显示字体大小这种需要参数的逻辑，则runnable的方法或更好些。 总结这一篇只是对于Android多线程一个非常简单的介绍。希望通过我的简单介绍能让读者对于多线程有一个简单直观的认识。Android多线程还有着许多许多复杂的内容，以后会在碰到并解决之后，一一在这里介绍给大家的。让我们共同学习，共同进步，谢谢！ 参考文章：Understanding Android Core: Looper, Handler, and HandlerThread A journey on the Android Main Thread — PSVM Android Handler Internals Android多线程 Multithreading Interview Question","link":"/2020/06/22/AndroidBasic3/"},{"title":"Android开发笔记之基础篇（五）- 易混淆概念","text":"这篇文章中将会列出在Android开发中经常遇到并且容易混淆的概念，他们基本都是成对出现并且需要进行比较异同的。这其中不光设计安卓的知识，也有关于Java和Kotlin语言特性的一些基本概念。在面试时很多成对的概念会同时出现并被问到异同，这篇文章也会持续更新碰到的各种易混淆概念。 Kotlin语言特性###lateinit VS lazy 首先来看一下使用lateinit的代码示例： 123456789101112class LateinitTest { private lateinit var manager: Manager fun setupManager(manager: Manager) { this.manager = manager } fun run() { manager.run() }} 然后是lazy的代码示例： 12345678class LazyTest { private val manager = lazy { ManagerProvider.provideManager() } fun run() { manager.value.run() }} 可以看出这两种初始化方式有一个非常明显的区别： lateinit用于可变量var， 而lazy用于不可变量val。 如果从他们的具体作用来看，这其实很容易理解：lateinit用于class initialization时延期加载一个property属性，它可以随时在这个class的其他方法中（除了primary constructor）通过赋值的方式进行初始化加载，所以这个property必须是可变的variable。lateinit的主要使用场景包括：dependency injection以及non-null property的推迟加载（懒加载）。 lazy的具体作用则是：通过接收一个lambda function给property属性进行加载，后续再次调用property的get()函数时则会使用lambda返回的对象而不会再次初始化，也就是说lambda只会执行一次但获得的结果会持续返回，所以需要使用不可变量来保证lambda结果的唯一。lazy的主要使用场景包括：单例模式（if-null-then-init-else-return）。 总体来说，lateinit比lazy的适用范围更大，可以用lazy的地方都可以用lateinit但是反之却不行。但是对于单例模式来说使用lazy可以大量节省初始化资源，所以当可以使用的时候还是应该优先考虑lazy。 Android SDK相关###Serializable vs Parcelable Serializable是一个Java Interface，通过实现这个接口，可以轻松的将一个POJO（plain old java object）在Activity中进行传递。实现Serializable接口不需要Override任何方法，但是因为它使用了Java Reflection API所以在编译过程中会生成很多额外的文件，有时会触发垃圾回收（garbage collection），浪费系统资源以及设备电量。 Parcelable是Android SDK中的一个Android Interface，它不需要使用Java Reflection API 所以不存在冗余文件的问题，可以节省资源。但是实现Parcelable接口需要额外实现包括writeToParcel，describeContents以及Parcelable.Creator在内的几个方法，同时也会使得POJO中的代码难以理解和阅读。 总体来说，Serializable实现简单，代码易读；而Parcelable高效迅速，降低功耗。两者各有优劣，现在还有第三种方式，就是使用Serializable并实现writeObject()以及readObject()这两个方法来避免Reflection自动生成的多余文件，这相当于一种折中和妥协。只要根据具体使用场景来判断哪一种更好就可以了，具体问题，具体分析。 Java语言特性相关###Overriding vs Overloading TL,DR: Overloading occurs when two or more methods in one class have the same method name but different parameters. Overriding means having two methods with the same method name and parameters (i.e., method signature). One of the methods is in the parent class and the other is in the child class. 这是一个经常出现在面试中的经典问题，简单来说Overriding是指在同一个class内声明方法名相同但参数不同的多个方法（two or more methods in one class have the same method name but different parameters），而Overloading则是指在子类中声明一个和父类名称，参数均相同的方法，但却有不同的具体实现（two methods with the same method name and parameters， one is in the parent class and the other is in the child class）。代码实例如下： 123456789101112131415161718192021222324252627282930313233343536373839open class iPhone { // Overloading examples open fun start(password: String) { print(password) } open fun start(fingerPrint: FingerPrint) { print(fingerPrint) } open fun start(face: Face) { print(face) }}class iPhone8 : iPhone() { // Overriding examples override fun start(password: String) { print(\"iPhone8 $password\") } override fun start(fingerPrint: FingerPrint) { print(\"iPhone8 $fingerPrint\") }}class iPhone11 : iPhone() { // Overriding examples override fun start(password: String) { print(\"iPhone11 $password\") } override fun start(face: Face) { print(\"iPhone11 $face\") }} 代码中iPhone的三个不同参数的start()方法是Overloading，而iPhone8和iPhone11中的start()方法则是Overriding，且因为在各自内部方法名一样，参数不一样，所以也是Overloading。 除此以外，Overloading 和Overriding的区别还有以下几点要注意： Overloading发生在编译时（complie time），Overriding发生在运行时（runtime），所以从performance来说Overloading更高效； 静态方法（static method），final method 和 private method 均可以Overloading，但都不可以Overriding，因为子类不可以对父类的以上三种方法进行修改； Overloading属于静态绑定（static binding）而Overriding属于动态绑定（dynamic binding）； Overloading时返回值类型可以不同。 Volatile vs SynchronizedTL, DR: Use Volatile when you variables are going to get read by multiple threads, but written to by only one thread. Use Synchronized when your variables will get read and written to by multiple threads 这两个关键字的用法与Java虚拟机本身的操作特性有关。首先要知道，在Java中当多个CPU线程同时工作，每个CPU线程都可以从内存空间（main memory）获取需要的共享变量，存入当前线程的CPU缓存（CPU cache）中并使用。大致工作流程如下图： 所以这里就要先介绍一下关于工作流程中共享变量的两个特性：“可见性”和“原子性”: 可见性（memory visibility）：指当一个线程对共享变量进行修改的时候，会强制其在内存空间里进行更新以便其他线程使用更新后的值； 原子性（memory atomic）：指在线程修改共享变量到内存空间更新之间，其他线程不可以从内存空间内读取旧的，未经过更新的共享变量值（保证每个人拿到的都是最新值）； 在定义了这两个特性之后，我们可以来介绍一下Volatile和Synchronized这两个关键字的区别： Volatile可以保证每个线程中共享变量的“可见性”，但无法保证“原子性”。也就是说，使用Volatile的方法有可能会获取到旧的，未更新过的共享变量值。因为当前线程对于共享空间的更新操作和其他线程的读取操作会有Race Condition出现。所以一般Volatile适用于只需要读取，不需要写入内存空间的场景； Synchronized可以同时保证每个线程中共享变量的“可见性”与“原子性”，相比于Volatile， Synchronized更可靠，但同时开销也更高。它可以保证在同一时间片段内有且只有一个线程可以对内存空间的共享变量进行操作，包括读取，计算和更新。所以一般Synchronized更适用于需要同时进行读取和写入内存空间的场景。 参考文章：Learning Kotlin - lateinit vs lazy Overloading and overriding in java Parcelable vs Serializable Volatile vs Synchronized","link":"/2020/10/24/AndroidBasic5/"},{"title":"Clear Architecture - Programming Paradigms &amp; Design Principles","text":"Clean Architecture is one of the series book that written by “Uncle Bob”. In last post, I writed a summary of the Clean Code. It is super useful for begineers. But as we going deeper, we need take a step back and see the “big picture” – software architecture, which is all this book talk about. Part II Starting with the Bricks: Programming ParadigmsStructured Programming: direct transfer of controlConstructed from sequence, selection and iteration to replace old goto keyword. A typical structured programming example: 123456789101112131415// sequence executionval sum = 0val current = 1// iterationwhile (current &lt; 10) { sum += current current += 1}// selectionif (needNegative) { return sum *= -1} else { return sum}return sum All programs can be constructed from just these three structures: sequence, selection and iteration. Object-Oriented Programming: indirect transfer of controlThrough the use of polymorphism to gain absolute control over every source code dependency in the system.To better understnad about power of polymorphism. also check Dependency Inversion Principle below. A typical object-oriented programming example: 123456789101112131415161718192021222324252627282930313233343536// define Vehicle interfaceinterface Vehicle { fun alarm() fun turnOn() fun turnOff()}// different brand of car, should all implement the same interfaceclass BMW: Vehicle { override fun alarm() { makrSound(\"di~di~\") } override fun turnOn() { ... } override fun turnOff() { ... }}// but they can have diffrent implementation (such as differnt alram sound)class Ford: Vehicle { override fun alarm() { makrSound(\"do~do~\") } override fun turnOn() { ... } override fun turnOff() { ... }}// when client code is using them, they don't need to know the implementation detailsFord().turnOn()BMW().ring() Any source code dependency, no matter where it is, can be inverted. Functional Programming: variable assignmentVariables in functional languages do not vary, which will causing none of race condition, deadlock or concurrent update problems. A typical functional programming example: 123456789class Person constructor ( private val name: String) { fun getName(): String { return name }}// define a function to get person's nameval personName = fun(person: Person) = person.getName Concurrent problems can be eliminated by segregate the application into mutable and immutable components. Part III Design PrinciplesSingle Responsibility Principle (SRP) A module should have one, and only one reason to change A common way to impose this principle is: Separate shared functional code blocks from specific logic. For example, here is a Employee class from payroll application: 1234567891011121314class Employee { private val employeeDB = EmployeeDatabase() fun getWorkingHours(): Int { return employeeDB.queryWorkingHours() } fun calculatePayroll(): Int { val workingHours = getWorkingHours() val salaryRatePerHour = employeeDB.querySalaryRatePerHour() return workingHours * salaryRatePerHour } fun saveEmployee() { employeeDB.updateEmpployee(this) }} It’s clear that this Employee class has too many responsibilities including query working hour, query salary rate, calculate payroll, update employee info etc. And typical problem can be: It’s hard to extends, when introduce different ways to calculate payroll for example; Who wants to change ONLY working hours fetching may also touch payroll calculation accidentally; EmployeeDatabase is exposed to Employee class, which is dangerous for open visibility. To solve these issues, we can do: 1234567891011121314class Employee { private val hourReporter = HourReporter() private val payCalculator = PayCalculator() private val employeeSaver = EmployeeSaver() fun getWorkingHours(): Int { return hourReporter.reportHours() } fun calculatePayroll(): Int { return payCalculator.calculatePay() } fun saveEmployee() { employeeSaver.saveEmpployee(this) }} As we can see, after we create HourReporter, PayCalculator and EmployeeSaver, we separate different responsibilities to different class so: if we want to have diffrent ways to calculate payroll, it can be updated inside PayCalculator and no need to update Employee class; when working hours fetching need to change, no need to touch payroll calculation logic; no more database expose to Employee class since it’s handled by these three classes internally. Open-Closed Principle (OCP) A software artifact should be open for extension but closed for modification. This is a common case that sometimes we want to extends part of our code and extends without having to modify that artifact. To make this possible, we need to implement component hierarchy structure so code change in lower level component will not effect higher level component. In other word, higher level component is being protected from code change chain. Let’s continue on the Employee example: 1234567891011121314class Employee { private val hourReporter = HourReporter() private val payCalculator = PayCalculator() private val employeeSaver = EmployeeSaver() fun getWorkingHours(): Int { return hourReporter.reportHours() } fun calculatePayroll(): Int { return payCalculator.calculatePay() } fun saveEmployee() { employeeSaver.saveEmpployee(this) }} It’s easy to understand that HourReporter, PayCalculator, EmployeeSaver classes has higher prority then Employee class and we want to avoid code change on them when we need change Employee class. The UML of structure is like: Note that an arrow pointing from class A (Employee) to class B(HourReporter, PayCalculator, EmployeeSaver) means: the source code of class A mentionas the name of class B, but class B mentions nothing about class A. In this XML, Employee depends on these three classes, so those three classes is protected from changes in Employee. Liskov Substitution Principle (LSP) Subclass should be substitutable for their base class A typical example of this principle is square/rectangle problem, let’s briefly recall the problem first by UML: As common sense, a Square should be treated as a special Rectangle which means all operations or parameters for a rectangle object should also effect on a square object. Let’s see the code block below: 1234val rectangle = Rectangle()rectangle.setWidth(2)rectangle.setHeight(5)assert(rectangle.getArea() == 10) This should work fine and the assertion should pass as well, but when we do the same thing to a Square like: 1234val square= Square()square.setSide(2) // how can width and height change at same time???square.setSide(5)assert(rectangle.getArea() == 10) // this will failed and area will be 25 The core problem behind this case is : square has a feature which rectangle don't: need set both width and height always at same time with same value, they can't be changed separately. It may causing a lot problems becuase of this. Interface Segregation Principle (ISP) No client should be forced to implement methods it doesn’t use When we play with abstract interfaces and implementation, a common problem is we find there are extra methods that the implementation not used at all. The easiest way to handle it is just override it and make it empty. But by doing this, there is a risk that it might be touched by other maintainers or even yourself in future since you may not remember. A good fix on this should be separate it into multiple specific interfaces like: In my opinion this is a good way to minimum the risk and separate interface for different class if they not use all of them, but also note that this might causing a lot interfaces to be generated, this is the trade-off. Dependency Inversion Principle (DIP) High-level module shouldn’t depend on low-level, but both should only depend on abstraction, not on concretions This is the most information principle in my opinion and also the hardest one to understand. To understand this, first question is: what is abstraction and why we need it? To answer this, let’s see this example UML: This is the concrete implementation for an application with a simple service. Service is created by ServiceFactory by calling serviceFactory.createService(). It works fine but it has several problems: Application can access everthing inside Service and ServiceFactory, it including something they don’t use (violation of ISP); Both Service and ServiceFactory are dependencies of Application, which means when their code changed, Application will need to re-comple and re-generated everytime (violation of OCP); If we want to add new type of service in future, both Application and ServiceFactory need change the code and still hard to extends (violation of OCP again). So according to what we learned before, here is a better solution for all three points above: As you can see in the solution UML, we make both ServiceFactory and Service as Interface and give them implemnentations for each interface. Note that implementation is hided from Application so it only communicate with interfaces. Why? Look back into all three problems above and you will find all of them is successfully solved by using Interface! Now let’s understand the description of this principle with the example: consider Application as low-level module and ServiceFactory, Service as high-level module, Application should not depends on ServiceFactory and Service because of the violation of ISP, OCP and DIP, and they should all depends on the abstraction, which is Interface in this case. And by using interface, the control flow is successfully inverted from Application -&gt; ServiceFactory to ServiceFactoryImpl -&gt; Application, same for Service as well. This is how Inversion come from.","link":"/2020/05/11/ClearArchitecture1/"},{"title":"Clean Code Summary","text":"Recently I read this book written by Robert C. Martin also known as “Uncle Bob”. In this book it talked about general coding principles to make your code “clean“ and easy to understand. And here is some useful tips and summaries I extracted. Chapter 2 Meangingful Names Use Intention-Revealing Names: avoid nonsense naming Avoid Disinformation: using FULLNAME, avoid abbrevation accountList &gt; accounts &gt; List Make Meaningful Distinctions: ProductInfo and ProductData, Customer and CustomerObject has no difference at all! Use Pronounceable, Searchable Names: the length of a name should correspond to the size of its scope Interface and Implementtations: avoid passing IShapeFactory as interface, using ShapeFactoryImpl in implementation Class Name: Avoid using Manager, Processor, Info, Dataas class name, using noun or noun phrase word One Word Per Concept: Don’t use retrieve, fetchr, get all at same time! It’s horrible! Chapter 3 Functions Small!: Funtions should be very small Avoid nested structures and each block should be one line Function should do one thing can’t extract another function from it witha nmae that is not merely a restatement of its implementation Switch statements: using polymorphism with abstract factory pattern Common Monadic Forms Ask question about argument like boolean isFileExist(File file) Operating on argument, transforming it into something and return like InputStream fileOpen(File file) Interpret function call as event and use argument to alter state of system without output argument like void passwordAttemptFailedNtimes(int attempts) Try to avoid any other form besides those three above Dyadic Forms Sometime reasonable if it’s a natural cohesion or ordering like new Point(0, 0) or assertEquals(expected, actual) It itn’s evil, but it has cost and there always a way to at least convert it to Monadic, just depends on whether it worth or not Argument Objects Using wrapper to wrap into a class of their own see these two following declarations: 12Circle makeCircle(double x, double y, double radius);Circle makeCircle(Point center, double radius); Output Arguments Try not using output argument, if must change state of something, make it change inside it’s own Prefer Exception to Returning Error Codes Error code always force caller to deal with it immediately using using try-catch block, the code to deal with succeed or error will be separated extract try and catch block to its own method should be more clear Chapter 4 Comments Comment should be no need at all It’s always the compensate for failure to express in code Programmer always forget to maintain, which makes them misleading Save the energy to write better and clearer code Chapter 6 Objects and Data Structures Data Abstraction Expose abstract interfaces to allow user manipulate data without knowing its implementation Consider serious which data should be exposed Data/Object Anti-Symmetry Objects: Hide data behind abstractions and expose funtions that operate their data Data: Expose data and have no meaningful functions Procedural code: Easy to add new functions, hard to change data structure Object Oriented code Easy to add new classes, hard to add new functions Need to use both of them properly to make clean code, but not in one class (hybird is the worst!) Chapter 7 Error Handling Use Exceptions Rather Than Return Codes Error code needs to be returned every single case, make the code very complicated and cultter caller Separate detection logic with handle logic Define Exception Classes in Terms of Caller’s Needs Wrapping third-party API is a best practice, easy testing, easy migration and less dependencies Define your own exception type inside wrapper to make handling logic easier outside the wrapper(only one type outside) Null Handling Don’t Return Null: throw an exception or using Special Case Pattern Don’t Pass Null: never pass null in methods Chapter 8 Boundaries Using Third-Party Code Hide the interface inside a class that we can control Avoid when change comes, we need change everywhere Make a Wrapper or Adapter to hide thrid-party interface Learning Test / Boundary Test It’s free and can be used to learning thrid-party code It can be used to detect breaking changes Chapter 10 Classes Class Organization Public static constants Private static constants Public instance variables (if any) Private instance variables Public functions Private function should directly after their caller Class should be small The more ambiguous the class name, the more likely it has too many responsibilities Avoid weasel words like Manager, Processor or Super which will aggregate responsibilities Single Responsibility Principle A class or module should have one and only one reason to change Identity reason to change often helps for better abstraction of our code A system composed of many small , well-structured classes is always better than a few large, multipurpose classes Chapter 11 System (Need revisit in future) Separate Constructing a System from Use it System should not know or care about startup logic, it assume everything should be constructed correctly when start running Using Dynamic Factory pattern to hide the building logic and allow application to decide when and what to build during runtime Dependency Injection: a way to achieve IOC (Inversion of Control) principle: the responsibility of instantiating dependencies will delegate to another “authoritative” mechanism","link":"/2020/04/28/CleanCode/"},{"title":"ClearArchitecture - Architecture","text":"After we known all principles in class level and component level, finally we reached Architecutre level. In this post, we will summarize all architecture level knowedge concepts quickly and finish this book for now, this book has much more useful stuffs that we are not covered, so we will come back and revisit someday after we have more understanding about software architecture. Part V ArchitecutreClear ArchitectureBy dividing the software into layers, the architecture has the following characteristics: Independent of frameworks: not depend on the existence of any library, use them like plug-in; Independent of the UI: not effected if UI changed, easy to replace with another UI; Independent of the database: not effected whatever DB is using like SQL or Mongo, CouchDB; Independent of any external agency: business rules don’t know anything about outside world; Testable: business rule can be tested without UI, DB or web server, etc. In this way, we have the diagram structure of a Clear Architecture like: From this diagram, we can see: Inner circles represent higher level components and outer is lower, in another word, the further in you go, the higher level the software becomes; Source code dependencies must point only inward, toward higher-level policies. Nothing in an inner circle can know anything at all about outer circle. Inner circle has higher abstraction and stability while outer circle are more concrete and easy to change; The lower right corner shown how to cross circle boundaries; This four circles model is not strict, sometimes you may find more than four layers which is totally make sense: what important is following the component rules we introduced in last post here; When you want to pass data crosses boundaries, keep it isolated, simple and easy to be used by inner circle, which means: always processing raw data in outer circle before pass it inward. Now let’s review this architecture model layer by layer: EntitesThis is the core layer of the model which contains enterprise-wide critical business rules. Usually this should be shared by all different applications in the enterprise, it can be business objects or a set of data structure. These are the least likely to change and shouldn’t be effected when something external changed. User CaseThis is the layer of application-specific business rules that should be different between applications like mobile apps or browser websites. Changes in this layer should not affect Entites layer and vice versa, but the operation of the application will affect logic inside this layer for sure. Interface AdaptersThis layer contains a set of adapters that convert data from the format most convenient for the use cases and entities to the format most convenient for some external agency such as database, web or UI. For example, all models, views and presenters of the MVP pattern should be inside this layer. Also adapters in this layer should be bi-directional converting which means is should also convert data from external agency to use cases and entities as well. Frameworks And DriversThis is the outermost layer of the model which contains all frameworks and tools such as database, web framework or UI, in general, this is all the details go. Usually you don’t need write much code in here, other than glue code that communicates to the next circle inward. Architecture DecouplingIndenpendenceA good architecture should support all the following: Use cases and opearation of the system (support the intent of the system) Maintenance of the system (support daily operations requirements) Developement of the system (support contributed by whole company without conflicts) Deployment of the system (immediate deployment) To achieve this, we need to decouple system into layers. Different layer should have different reason and rate to change. This decoupling mode can have three levels: Source Level: control the dependencies between source code modules so changes to one module do not force changes of others; Deployment Level: control dependencies between independently deployable units like jar failes or shared libraries; Service Level: control dependencies between each services so communicate solely through network packets. As always, it’ hard to know which mode is best during the early phase of a project. As the project grows, the optimal mode may change. BoundaryBoundaries is drawing a line to prevented each side of the line from knowing anything about the other side. Drawing the boundary lines helped delay and defer decisions and saved amount of time and troubles. To draw boundary lines in software architecture, we need follow these steps: Partition the system into components, some components are core business rules and others are plugins; Arrange code in those components such that arrows between them point in one direction to core business; Apply SRP(Single Responsibility Principle) and it should tell where to draw the boundary line. DetailsDatabaseThe database is a utility that provides acccess to the data, it is just a mechanism we use to move the data back and forth between the surface of the dask and RAM. The organizational structure of data, the data model, is architecturally significant and the technologies and systems that move data on and off are not. WebThe web is an I/O device, it is a GUI, and GUI is a detail which only matters input and output. Framework Don’t marry the framework! Frameworks are not architecture. You must make a huge commitment to the framework, but the framework author makes no commitment to you whatsoever. Use the framework but do not couple to it by deriveing proxies and keep those proxies in components that are plugins to business rules.","link":"/2020/07/09/ClearArchitecture3/"},{"title":"clearArchitecture - Desgin Principles &amp; Component Principles","text":"In last post we talked about programming paradigms and SOLID principles. This is far more than enough to understand about architecture, so today let’s continue on “Design Principles” and see more of them that need to follow when thinking like an architect. Part IV Components PrinciplesComponentsThe samllest entities that can be deployed as part of a system. In java, they are jar files; In Ruby, they are gem files and in complied languages, they are aggregation of binary files. It can be dynamically linked together at runtime, which can be used as plug-in. Components Internal PrinciplesReuse/Release Equivalence Principle(REP) To resue software components, it need to be tracked through a release process and are given release numbers. Because developer needs to know which cohesive group is the current compoent belong to. In another word, component cannot be easily plug-in or pull-out without version control, it will mess up the whole project without clearly knowing which version contains what feature. Common Closure Principle(CCP) Gather into components those classes that change for the same reasons and at the same times. Separate into different components those classes that changed for different reasons and at different times. This is component level of SRP *(single responsible principle), which means *a component should not have multiple reasons to change. If you find two components are always changed together, try merge them into one. Common Reuse Principle(CRP) Don’t force users of a component to depend on things they don’t need This is component level of ISP (Interface Segregation Principle) and a bit more generic. If there are not used dependencies exists in component, that means when anything changed in those dependency, the component is highly possibly to do corresponding changes and then recompiled, revalidated and redeployed. So be careful to only depend on the things you really need. Component Tension DiagramSo after known those three component principle above, we can draw a tension diagram like this: As we can see here, these three principle are balanced to each other and when you try to apply two of them, you will sacrifice the another. Normally we start from CCP and CRP, to make the component working and changing fast. As the component become more and more stable, we will start to move left and apply REP to make it easier to reuse and maintain until we find a perfect balance in middle. The final balance point are varied team by team. Components External Principle (Between Components)Acyclic Dependencies Principle (ASP) Allow no cycles in the componet dependency graph Dependency cycle can work, but very difficult to change because when new change apply to one componet, all other components need to change to be compatiable. The cycle itself performed like a “super big component” which a lot other component will depend on. Two ways to eliminate the cycle in component dependency graph: Apply Dependency Inversion Principle (DIP): create an interface inside the depender component (the one need depend on the other) so the dependee will implement this interface. This UML will explain more clearly: Create a new component that both depender and dependee should depend on. In this way the cycle will be break since the new component will not depend on any of them. The UML should looks like: Stable Dependencies Principle (SDP) Depend in the direction of stability. This principle is short and concise, but might not be easy to understand. A better description might be: Any component that we expect to be volatile should not be depended on by a component that is hard to change, which means stable. To measure the instabillity, we need use I-metric to meature. I-metric can be calulated by: I = Fan-out / (Fan-in + Fan-out), for example: In this UML, we can see that both component A, B, C has I-metric = 1, which makes them unstable and easy to change because their changes will not influence any other componets. For component E, since I-metric = 0, which means it’s hard to change because to change it, it might need to change all components depend on it such as B, C and D, which might need change A as well since A depends on D! For Componet D, I-metric=0.25 which means it’s still stable and hard to change, but the effort to change it is less than component E. So basically I-metric can give us a hint that how easily this component can be changed. To make a stable component easy to change, we need to create something called abstract component. It is the same concept as interface at class level. so we will create a new component which contains interfaces and make both component depends on it, like: As we can see before compoent Authorizer I-metric = 0 which is hard to change, and after we using abstract component Permissions, it has I-metric = 1 and as easy to change as component Entities. Before we finish this principle, there are two points need to mention: SDP suggests that, in dependency graph, the I metric of a component should be larger than the I metric of the component that it depends on, which means the I metric should keep decreasing in the direction of dependency chain; Abstract components are very stable (usually I-metric = 0), so they are ideal target for less stable components to depend on. Stable Abstraction Principle (SAP) A component should be as abstract as it is stable. This is also too “abstract” to understand. So a better explanation should be: A stable component should also be abstract so that it’s stability does not prevent it from being extended; An unstable component should be concrete since its instability allows the concrete code within it to be easily changed. Since we know that dependencies should run in the direction of stability, and stable component should be abstract, we can also know: dependencies should run in the direction of abstraction. For stability, we have I-metric to measure, so do we have similar measurement for abstraction? Of course yes! Come on, A-metric! A-metric can be calculated by: A = Na / Nc, Na is number of classes inside the component and Nc is number of abstract classes and interfaces in the component. For an abstract component like we said above, A-metric = 1 which means totally abstract; and for a componet without any abstract classes and interfaces, A-metric = 0 which means totally concrete, pretty straightforward👍. I-metric/A-metric GraphNow we can two metrics to describe a component’s stability and abstractness. But what’s the relation between them? How can we evaluate it? This is the time I-metric/A-metric Graph start to use: In this graph, we are using A-metric as vertical axis and I-metric as horizontal axis. In this way, each component wil fall into a point with coordinates in this graph. There are some points need to mention in this graph: Zone of Pain is a zone that not expected to put componets, because in this zone components are rigid,concrete and very hard to change. The only excluded case might be Databse schema or some utility libraries; Zone of Uselessness is also a not expected zone, because in this zone compoents are totally abstract and dependent which means might nobody using them and can be removed. The most desirable position for a component is at one of the two endpoints of the Main Sequence. They are stable and abstract, or flexible and concrete. Once the I/A graph is done, we can fill the components inside the graph and got this: By calculating the Distance between a point to Main Sequence: D = |I + A - 1|, we can get the result of how far away a component is from ideal. and then we can draw the standard deviation line(Z = 1) and focus on the component that beyond these lines and start refactor them. This is how these metrics can help us find the correct components to improve.","link":"/2020/07/06/ClearArchitecture2/"},{"title":"RxJava基础概念梳理","text":"Reactive programming这个概念我在最近的安卓开发中极其频繁的接触到，但是对于从没有接触过的我来说，很多概念还是有点抽象和难以理解。所以这篇博客就来梳理一下在进行了一些了解和学习后，关于所谓“响应式编程”的我自己的理解。这里的例子主要都是应用于RxJava中，但实际上在稍微接触了RxSwift以及RxCocoa之后，我认为它们的基本概念都是相同的，所以了解RxJava之后，RxSwift和RxCocoa就完全不在话下。 The 3 O’s如果你熟悉设计模式中的观察者模式， 那么简单来说，Rxactive programming就是一种更为复杂和多样的观察者模式的应用。首先要介绍的，就是在RxJava中出于最核心部分的三个概念： Observable， Observer和Operator，简称 the 3 O’s。 ObservableObservable直译就是”可被观察的“，我认为可以把它理解成一种”数据源“，就是源源不断的产生数据的”工厂“。通常当我们需要任何数据时，我们都可以创建一个Observable实例并在其中声明产生数据的方法，比如网络请求，进行复杂运算，或等待用户输入等等。当需要获取对应数据时，它会依次发送出需要的数据，形成数据流，并被Observer依次获取。 创建一个Observable的方法有很多，最基础的方法就是使用Observable.create()方法并传入一个Observable.OnSubscribe实例，例如： 12345678Observable&lt;Integer&gt; observable = Observable.create(new Observable.OnSubscribe&lt;Integer&gt;() { @Override public void call(Subscriber&lt;? super Integer&gt; subscriber) { subscriber.onNext(1); subscriber.onNext(2); subscriber.onNext(3); subscriber.onCompleted(); }}); 在这个例子中，observable会依次发送1，2，3三个值，然后声明自己完成发送并结束。这里需要注意的是，如果不执行onCompleted()方法，那么Observable就会被认定依旧运行，这个对象也不会被回收直至一个onCompleted()或者onError()方法被执行或者observable本身被销毁（会存在内存泄漏的问题）。并且Observable在没有任何observer订阅时，不会发送任何数据。 为了更加方便的创建observable，RxJava又为我们提供了一些快速创建的方法，比如创建一个和上边一样的observable，也可以使用如下代码： 1Observable.just(1,2,3); 通过这种方式，我们可以更加快速直观的创建一个Observable并且看到需要发送的数据，但是这仅适用于发送简单数据的情况。 Observer说完Observable，下面就是对应的“观察者”Observer了。顾名思义，observer就是数据的“接收方”，也就是对于接收数据进行响应的对象。相比于Observable，observer的使用方法更为简单，我们只需要创建一个继承Observer接口：onNext(), onComplete()和onError()的实例，然后执行observable.subscribe()订阅方法并将observer传入即可。例如： 1234567891011121314151617181920// 创建ObserverObserver&lt;Object&gt; observer = new Observer&lt;Object&gt;() { @Override public void onCompleted() { Log.d(\"Test\", \"In onCompleted()\"); } @Override public void onError(Throwable e) { Log.d(\"Test\", \"In onError()\"); } @Override public void onNext(Object s) { Log.d(\"Test\", \"In onNext():\" + integer); } };// Observable订阅Observerobservable.subscribe(observer); 通过subscribe()的方法进行订阅后，observer就可以直接接收到所有从observable发出的数据，不仅十分方便，代码也十分直观。 Operator相比于Observable和Observer，Operator更像一个辅助性的“中间商”。它负责处理observable传递过来的原始数据，将其转化（transform &amp; polish）成observer需要的数据类型，再传给订阅的observer。通过这种方式，可以让数据类型的转换更为方便快捷，整体的代码也更为清晰明了。常用的一些operator方法包括： map()：对于每个数据都执行一个对应的function，执行结果与原数据一一对应并输出； flatMap()：对于每个数据都执行一个对应的function，执行结果全部存入一个Observable并输出（flat意思就在于此），相当于一对多的对应关系； groupBy()：对于每个数据源按grouping rule进行mapping，结果按不同group存入不同observable，最终输出observable set； filter：顾名思义，按照某种条件对其进行筛选并将符合筛选条件的数据输出。 所有build-in operator可以在这里找到，里面也有十分详尽的对于每个operator作用的介绍，关于Operator更为详细的介绍，以后会专门在写一篇文章，这里不再赘述。 综合上面对于三个基本概念的介绍，我们可以知道，Reactive Programming主体逻辑的流程图大致就是： Multi-threading首先要说明的是，RxJava本身在不声明任何scheduler时是默认单线程运行的，但实际使用时很多时候我们都需要在不同线程上去进行数据的产生和传递，这是就需要用到它的多线程(Multi-threading)特性。RxJava的多线程控制主要由两个方法来决定：subscribeOn() 和observeOn()。 subscribeOn()subscribeOn()这个方法用于指定Emitter（Observable，Single，Flowable等等）在哪一个thread上运行并产生数据，它的具体声明位置对于代码的执行没有任何影响，无论声明的先后顺序。举个例子： 123456Observable.just(\"1\", \"2\", \"3\", \"4\", \"5\") .subscribeOn(Schedulers.computation()) .flatMap { value -&gt; Observable.just(value.toInt()) } .subscribe { print(it) } 123456Observable.just(\"1\", \"2\", \"3\", \"4\", \"5\") .flatMap { value -&gt; Observable.just(value.toInt()) } .subscribeOn(Schedulers.computation()) .subscribe { print(it) } 以上两段代码，它们在运行逻辑上没有任何区别，Observable都是在computation thread上运行。 obverseOn()observeOn()这个方法用于指定Observer在哪一个thread上去处理Observable传递出来的数据，它只对当前声明位置下方的代码产生影响，换个方式来说，当代码执行到obverseOn()时，会切换线程并继续执行后面的逻辑。例如： 12345678Observable.just(\"1\", \"2\", \"3\", \"4\", \"5\") .observeOn(Schedulers.computation()) // 切换到 computation thread .flatMap { value -&gt; Observable.just(value.toInt()) } // computation thread上执行 .observeOn(Schedulers.io()) // 切换到 io thread .map { value -&gt; value * value } // io thread上执行 .subscribe { print(it) // io thread上执行 } Scheduler从上面的例子可以看出，subscribeOn()和observeOn()这两个方法都是通过传入Scheduler的类型作为参数来保证数据的产生，处理和接收都发生在对应的thread里的。那么Scheduler的类型都有哪些呢？这里就列举了一些Android平台上最为常用的Scheduler类型以及对应的适用情况： Scheduler.io() 最常使用的一种scheduler，主要用于处理IO操作例如网络请求，文件读写操作； Scheduler.computation() 处理与计算相关的操作，数量上限等同于处理器内核的数量； Scheduler.newThread() 创建一个新的scheduler，要尽量避免创建过多scheduler，尽量多使用已经存在的线程； Scheduler.single() 在一个独立的单线程处理操作，类似于一个后台独立的main thread； Scheduler.trampoline() 用于即时处理操作，它会立刻开始并严格按顺序处理所有当前线程上的Observable； AndroidSchedulers.mainThread() 安卓的主UI thread，必须注意不要让它被费时间，有延时的操作block住，否则会ANR。 Emitter除了Observable这个“数据源工厂”，RxJava还有许多其他的类型，它们被统称为Emitter，也就是“发射器“。它们都是产生数据或者获得数据的来源，但是不同的类型又有一些不同的特性，在这里列出几种除了Observable以外常用的Emitter类型： FlowableFlowable和Observable的用法几乎一摸一样，唯一的区别在于Flowable可以处理Backpressure的情况。所谓Backpressure，就是当Emitter的数据产生的速度过快，而Observer接收端处理数据的速度过慢时，数据会堆积在Emitter的memory里等待发送，累积到一定程度时就会抛出OutOfMemoryException异常。 Flowable通过使用BackpressureStrategy.DROP的策略，也就是在memory即将存满时丢弃一些数据的方法，来处理backpressure的问题。Observable也可以通过observable.toFlowable(BackpressureStrategy.DROP)的方法转换为Flowable来进行使用。 SingleSingle是一个非常简单的发射器，顾名思义，它仅在获取并发射一个单独的数据实例之后便结束发送。如果数据获取并发送成功，运行onSuccess()；发送失败的话则运行onError()。这种类型在我们返回单个数据时十分实用。Single的示例代码： 12345Single.just(\"This is a single\") .subscribe( { v -&gt; print(\"value is $v\") }, { e -&gt; print(\"error is $e\") } ) MaybeMaybe和Single类似，其区别在于：Maybe有可能不发送任何数据就结束发送。这种类型主要用于获取一些optional的数据时使用，因为它可能存在，也可以不存在。如果数据获取并发送成功，运行onSuccess()；发送失败的话，运行onError()；而没有获得数据的话则运行onComplete()。这种类型在我们返回单个optional数据时十分实用。Maybe的示例代码： 123456Maybe.just(\"This is a single\") .subscribe( { v -&gt; print(\"value is $v\") }, { e -&gt; print(\"error is $e\") }, { print(\"Completed\") } ) Completable相比于其他所有的Emitter的最大区别就是：它不发射数据，而是仅关心操作是否成功完成。如果成功完成，运行onComplete()，如果失败，则运行onError()。Completable就像是RxJava版的Runnable，可以通过addThen()方法进行连接并执行。同时，上面列举出的所有发射器类型，都可以通过例如Completable.fromSingle(Single.just(&quot;this is single&quot;))的方式转换为Completable并串联其他Completable进行运行。Completable示例代码： 1234567891011Completable.create { emitter -&gt; emitter.onComplete() emitter.onError(Exception())}Completable .fromSingle(Single.just(\"This is a single\")) .subscribe( { print(\"complete!\") }, { print(\"error!\") } ) Subject前面说到，Operator主要用于对传送数据进行处理和转化。但是对于一些实际使用场景来说，operator还是不够灵活。于是RxJava又提供了Subject这个类型来让我们更近灵活地进行数据的传输。 A Subject is a sort of bridge or proxy that is available in some implementations of ReactiveX that acts both as an observer and as an Observable. 上面是官方文档关于Subject的解释，简单来说Subject就像是一个连接不同Observable和Observer的”桥梁“。它既可以作为Observable来发送数据，也可以作为Observer来接收数据。通过Subject，我们可以将任意Observable的数据进行接收，处理，并再次发送给其他Observer。关于Subject，其实RxJava里还有许多其他的类型。这里只列举最为常用的四种类型，其余类型会在以后碰到时补充更新在这里： PublishSubject比较简单的一种Subject类型，会在subscription之后将所有数据依次发送。值得注意的是：PublishSubject会在初始化后立刻开始发送数据，而不是有Observer subscribe之后发送，所以会存在observer接收数据不完整的情况。对于这种情况，ReactiveX给出了两种方式解决：1. 使用Create()方法并在初始化前确认observer已经完成订阅；2.使用下面要介绍到的ReplaySubject。 BehaviourSubject相比于PublishSubject，BehaviourSubject最大的特点就是：它会发送Subscription之前的最后一个数据（last emitted data）以及Subscription之后将所有数据。除此之外，它和PublishSubject的特点基本一致。 ReplaySubjectReplaySubject会发送Observable产生的全部数据，无论是subscription之前还是之后。其内部就是用一个List动态存储所有接收的数据，并在subscription时发送给Observer。这也就是上面说到的为什么可以使用ReplaySubject来确保Observer接收数据的完整性。 AsyncSubjectAsyncSubject仅会发送Observable产生的最后一个数据，无论是subscription之前还是之后。 总结这是关于RxJava的第一篇总结文章，主要介绍了一些比较基础的概念。之后会继续写一些没有涉及到的概念比如Subject，更多Operator的具体用法，以及比较RxJava和RxSwift的一些异同等等。Reactive programming是非常强大的工具，可以让我们更轻松的管理数据流并实现多线程的同步，希望这篇文章中的概念可以对于响应式编程有一个更清晰的理解，happy coding!。 参考文章ReactiveX 官方文档 Meet RxJava: The Missing Reactive Programming Library for Android Fundamentals of RxJava with Kotlin for absolute beginners Reactive X: RxJava Data Flows: Observable, Flowable, Single, Maybe and Completable RxJava/RxAndroid使用实践实例","link":"/2020/08/06/RxJava/"},{"title":"Dependency Injection","text":"Dependency Injection is a huge topic in Android development and it’s very important because it can give us a clean, well-designed, easy-to-change environment no matter we develop new features or implement any testing. So here is some thoughts about DI and an useful framework which helps you do all dirty jobs behind the scene. What is Dependency InjectionBefore answering this question, a better question to ask might be: What is dependencyTo answer this question, let’s take a look at this Kotlin code here: 12345678910111213class SimpleFeature constructor( val businessLogicDelegate: BusinessLogicDelegate, val validator: Validator, val listener: Listener) { fun doSomeThing() { val helper = Helper() if (validator.validate()) { businessLogicDelegate.doSomething(helper, listener) } }} This is a very common secenario in real life: I have a class and serveral parameters in its constructor, I need call some methods of those parameters inside this class. At the same time, I also need initialize a helper class inside and use it. In this case, both the parameters and helper class will be considered as the Dependency of SimplyFeature class. Cause this SimpleFeature needs “depend on“ something to finsh its own job. In another word, if any class’s method is called inside a class A, those class will be considered as A’s dependency. So now I know dependency, what is dependency injection?Let’s look back to this code again: 12345678910111213class SimpleFeature constructor( val businessLogicDelegate: BusinessLogicDelegate, val validator: Validator, val listener: Listener) { fun doSomeThing() { val helper = Helper() if (validator.validate()) { businessLogicDelegate.doSomething(helper, listener) } }} There are two main issues in this code block: Inside the doSomeThing(), we need to initialize a Helper class to help finishing business logic. This can work for sure, but if this helper needs to be a static class, or I need to using a Signleton helper class, here, how can I use it? When writing unit test with Mockito or Mockk, a common way is passing in a “mock“ instance and testing if the expected method of this mock is called with correct parameter. But how can we pass in the mock of Helper class if the new operator is called inside? To solve these problems, what can we do? Just simply pass a helper instance in the constructor so it can become the dependency of SimpleFeature as well! The constructor will look like this: 12345678910111213class SimpleFeature constructor( val businessLogicDelegate: BusinessLogicDelegate, val validator: Validator, val listener: Listener, val helper: Helper) { fun doSomeThing() { if (validator.validate()) { businessLogicDelegate.doSomething(helper, listener) } }} Now it looks great! I can pass in any Helper class and also mocking it and do the unit test! Nice! Now we can make a conclusion here: Dependency Injection means:Passing the dependency into the class and use it One thing need to mention here is: passing through class’s constructor is only one of the way to do DI. More details about this concept can be find here. How can I use dependencies injection?To use dependencies injection effectively, let me introduce this super-useful library here: This Dagger 2 library are powerful for android application dependency injection, by using this, all we need to do it’s define each class’s dependency list and the scope to use it. All other stuff will be handled by this library automatically and anonymously. So how to use it? First, we need to have a module class: 12345678910111213141516@Moduleinterface MainModule { @Binds fun providesBusinessLogicDelegate(businessLogicDelegateImpl: BusinessLogicDelegateImpl): BusinessLogicDelegate @Binds fun providesValidator(validatorImpl: ValidatorImpl): Validator @Binds fun providesListener(listenerImpl: ListenerImpl): Listener @Binds fun providesHelper(helperImpl: HelperImpl): Helper} What is this Module use for? Basically this is the place you want dagger helps you to initialize all your dependency. There are two ways to initial dependency in dagger, one is through @Bind annotation and another is @Provides. In here I’m using @Binds since it’s much simpler if all dependencies has implement an interface. Then we need another class which is called componenet class: 1234567@Component (modules = [MainModule::class])interface MainComponent { fun inject(activity: MainActivity) fun inject(feature: SimpleFeature)} Inside this Component, the inject() method defines “where those dependencies should be injected to”. And following the @Component annotation we can declare all modules that can be included, so we can inject multiple module’s dependencies inside one single class that called by inject() method. So far so good! After create these two classes above, we defined What is the dependency and Where should we inject into. Now the final step will be refactor our SimpleFeature class: 12345678910111213class SimpleFeature @Inject constructor( val businessLogicDelegate: BusinessLogicDelegate, val validator: Validator, val listener: Listener, val helper: Helper) { fun doSomeThing() { if (validator.validate()) { businessLogicDelegate.doSomething(helper, listener) } }} Since all parameters inside the constructor are initialized in module class and the injection of this feature class also declared in component class, the only change needed in here is add @Inject annotation before constructor, then dagger knows that all parameters can be find in module and injected by component magically. Done! Now enjoy inject any dependency you want! Now there are still some notes worth mention here: What we using here is just a very brief introduction of Dagger, it has a lot powerful methods and tools that worth to try and play with it. More detail should be found in here One of the very useful feature of Dagger is @Scope annotation. It can be used in complicated structured project to define different scope for different dependencies to access. This part will be added in future as a follow-up of our DI topic. The main purpose of DI is align with one of the basic SOLID principle in softwate development, which is know as Dependency Inversion Rules. This principle states: High-level Module should not depends on low-level module, both should depend on abstractions (interface); Abstractions should not depend on details. Details (concrete implementation) should depends on abstraction. We will cover all these principles one by one in future, they are very important in industrial software development world. Although there are tons of advantages in DI, but it has its limit or disadvantage for sure. For example, when dependency is missing, it’s hard to find out which dependency is missing by checking the build output. So at this time, log is very useful to check.","link":"/2020/02/28/DependencyInjection/"},{"title":"常用摄影构图总结","text":"刚开始接触摄影，在这里总结一下常用的九种简单易学的摄影构图方法，每一种都有不同的适用场景和范围，也会使照片产生不同的意境。这仅是一个总结归纳，做为日常摄影练习时的构图思路参考。 1. 三分构图 三分法是最常用的构图方法，要注意一下几点： 被摄主体占总画面的 1/3 或 2/3； 被摄主体处于四条分割线的交点（趣味中心点），右上 &gt; 右下 &gt; 左边两点； 风光摄影时，一般天空或地面其中一方 1/3，另一方 2/3 （看拍摄主体在哪儿）； 另一种容易混淆的三分法是指：前景，中景，远景的三分，与这里的三分法不同。 2. 引导线构图 引导线构图主要是利用画面中线条引导观众的目光，让目光汇聚到画面焦点。引导线包括水平线，竖直线，对角线，曲线，汇聚线，隐藏线，常用道路，墙壁，桥梁，河流，山谷等，通过使用引导线，可以增加场景深度和透视感，使场景感觉更真实和立体。 3. 框架型构图 框架型构图的主要思路就是：利用前景作为框架，引导观众视线至画面焦点，明确主体，同时通过框架可以过滤掉无关元素，使画面更有层次感。但使用框架构图时要注意被摄主体和框架间的比例，框架为主体服务，不要太复杂。一般来说树叶间隙、门框窗框、山石缝隙，高光暗影等都可以当做框架进行使用。 4. 中心构图 中心构图可以用来制造视觉中心点，使得画面主体清晰明确，体现视觉张力。对于建筑类拍摄来说，中心构图可以体现平衡性和建筑的稳定性，常用于正方形图片比例。 5. 对称构图 对称构图常用于方正的建筑或有水面倒影时，也可以用于双人的拍摄以展现势均力敌的感觉，形成一定程度的对称冲击感。更高阶的对称构图可以主动去寻找“大对称下的小不对称”，使画面更生动自然。 6. 三角构图 三角构图是将三个视觉中心连成一个三角形，可以是正三角，倒三角或者斜三角。因为三角形给人的感觉较为稳定，所以常用于建筑摄影和人像摄影。其中正三角，斜三角多用于古典，对称建筑，灵活的同时不失趣味感；而倒三角则多用于人像，运动，呈现比较动感的效果。 7. 对角线构图 对角线构图会将被摄主体放在尽可能靠近照片对角线的位置，从而引导观众的视线在对角线游移，使其更具有延伸感，更加活泼生动，富有动感，视角也更加开阔。常用于建筑，桥梁，道路等线条型主体。 8. 曲线构图 曲线构图常用于被摄主体呈S形曲线时，如河流，曲径，小溪，道路，楼梯等，从而表现出延伸感和空间感。在拍摄人像时则可以来体现女性的曲线美。 9. 垂直线构图 垂直线构图会将画面用竖直的线分割开来，常用于表现景物的高大和深度，如摩天大楼，瀑布，高大的树木等。竖直线的延伸感可以使画面紧凑且富有节奏感，同时画面有规律感，使人感觉整齐稳定。 参考资料九种最常用的构图法","link":"/2020/10/31/%E6%91%84%E5%BD%B1%E6%9E%84%E5%9B%BE/"}],"tags":[{"name":"Chinese","slug":"Chinese","link":"/tags/Chinese/"},{"name":"Android UI","slug":"Android-UI","link":"/tags/Android-UI/"},{"name":"Multi-thread","slug":"Multi-thread","link":"/tags/Multi-thread/"},{"name":"Kotlin","slug":"Kotlin","link":"/tags/Kotlin/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"English","slug":"English","link":"/tags/English/"},{"name":"Clean Architecture","slug":"Clean-Architecture","link":"/tags/Clean-Architecture/"},{"name":"Clean Code","slug":"Clean-Code","link":"/tags/Clean-Code/"},{"name":"RxJava","slug":"RxJava","link":"/tags/RxJava/"},{"name":"Dagger","slug":"Dagger","link":"/tags/Dagger/"},{"name":"摄影构图","slug":"摄影构图","link":"/tags/%E6%91%84%E5%BD%B1%E6%9E%84%E5%9B%BE/"}],"categories":[{"name":"技术博客","slug":"技术博客","link":"/categories/%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/"},{"name":"Android","slug":"技术博客/Android","link":"/categories/%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/Android/"},{"name":"Reading","slug":"技术博客/Reading","link":"/categories/%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/Reading/"},{"name":"摄影","slug":"摄影","link":"/categories/%E6%91%84%E5%BD%B1/"}]}