{"pages":[{"title":"categories","text":"","link":"/categories/index.html"},{"title":"tags","text":"","link":"/tags/index.html"}],"posts":[{"title":"Androidå¼€å‘ç¬”è®°ä¹‹åŸºç¡€ç¯‡ï¼ˆä¸€ï¼‰","text":"å› ä¸ºæœ€è¿‘å¼€å§‹ç³»ç»Ÿåœ°å­¦ä¹ Androidå¼€å‘ï¼Œæ‰€ä»¥åœ¨è¿™é‡Œè®°å½•ä¸€ä¸‹æ‰€å­¦åˆ°çš„Androidå†…å®¹åšä¸€ä¸ªæ•´ç†ã€‚æ—¢ç®—æ˜¯å¯¹å·²å­¦åˆ°çŸ¥è¯†çš„æ€»ç»“å’Œæ¢³ç†ï¼Œä¹Ÿå¯ä»¥æ£€æŸ¥è‡ªå·±ç†è§£ä¸­å‡ºç°çš„é—®é¢˜ï¼Œå’Œå¤§å®¶å…±åŒè®¨è®ºä¸€ä¸‹ã€‚å› ä¸ºæ˜¯ç¬¬ä¸€æ¬¡å†™ä¸œè¥¿ï¼Œæ‰€ä»¥æœ‰ä»€ä¹ˆä¸è¯¦ç»†ï¼Œä¸æ¸…æ¥šï¼Œä¸å‡†ç¡®çš„åœ°æ–¹ï¼Œè¿˜å¸Œæœ›å¯ä»¥æŒ‡æ­£ï¼Œæˆ‘ä»¬å…±åŒè®¨è®ºï¼Œå…±åŒè¿›æ­¥ã€‚ æœ¬ç¯‡æ–‡ç« å¤§éƒ¨åˆ†çš„å†…å®¹éƒ½æ˜¯åŸºäºè‡ªå·±é€šè¿‡Googleå®˜æ–¹è¯´æ˜æ–‡æ¡£ï¼ŒStackoverFlow, CSDNç­‰ç½‘ç«™çš„é˜…è¯»è·å¾—çš„ï¼Œå¸Œæœ›é€šè¿‡æˆ‘ä¸ªäººçš„ç†è§£ï¼Œè®©è¿™äº›çŸ¥è¯†æ›´å®¹æ˜“è¢«è¯»è€…æ‰€ç†è§£å’Œæ¥å—ã€‚ Application Structureè¿›å…¥Andoridçš„ç¬¬ä¸€ä¸ªéœ€è¦ç†è§£çš„çŸ¥è¯†ï¼Œä¹Ÿæ˜¯æˆ‘ä¸ªäººè®¤ä¸ºæœ€ä¸ºé‡è¦çš„åŸºç¡€çŸ¥è¯†ä¹‹ä¸€ï¼Œå°±æ˜¯äº†è§£Android applicationçš„æ¶æ„ã€‚æ„æˆä¸€ä¸ªå®Œæ•´å®‰å“APPçš„ï¼Œæ˜¯å„ç§å„æ ·ä¸åŒçš„Componentï¼ˆç»„ä»¶ï¼‰ï¼Œè¿™äº›Componentåˆ†åˆ«æ‰¿æ‹…ç€ä¸åŒçš„å·¥ä½œå’ŒèŒè´£ï¼Œæ¯”å¦‚è´Ÿè´£ä¸ç”¨æˆ·è¿›è¡Œäº¤äº’çš„Activityï¼Œè´Ÿè´£åå°ç›¸å…³å·¥ä½œçš„Serviceï¼Œè´Ÿè´£ç›‘å¬ä¼ é€’ä¿¡æ¯çš„BoardcastReceiverï¼Œ ä»¥åŠå­˜å‚¨è¯»å–æ•°æ®çš„ContentProviderç­‰ç­‰ã€‚ æˆ‘ä»¬ç”¨ä¸€ä¸ªç®€å•çš„ä¾‹å­æ¥è§£é‡Šä¸€ä¸‹ï¼šå¦‚æœè¯´ç°åœ¨éœ€è¦åšä¸€ä¸ªè´Ÿè´£è®¡ç®—æ±‡ç‡è½¬æ¢çš„Androidåº”ç”¨ï¼Œé‚£ä¹ˆå…¶å¯¹åº”çš„ç»„ä»¶åŠŸèƒ½åˆ†åˆ«ä¸ºï¼š é¦–å…ˆè¦å®ç°æ±‡ç‡è½¬æ¢çš„åŠŸèƒ½ï¼Œæˆ‘ä»¬å°±éœ€è¦ä¸€ä¸ªè®©ç”¨æˆ·è¾“å…¥é‡‘é¢å¤§å°ï¼Œé€‰æ‹©è½¬æ¢è´§å¸ç±»åˆ«çš„ç•Œé¢ï¼Œè¿™å°±æ˜¯CurrencyConvertActivityï¼Œåœ¨å…¶ä¸­å®šä¹‰äº†ä¸€åˆ‡UIä¸ç”¨æˆ·è¿›è¡Œäº¤äº’çš„é€»è¾‘ï¼› æ¥ç€æˆ‘ä»¬æƒ³åœ¨åå°æœåŠ¡å™¨å®æ—¶è·å–å½“å‰çš„æ±‡ç‡æ•°æ®ä¿¡æ¯ï¼Œé‚£ä¹ˆå°±éœ€è¦ä¸€ä¸ªBoardcastReceiveræ¥éšæ—¶å‘æœåŠ¡å™¨å‘é€è¯·æ±‚è·å–å½“å‰æœ€æ–°çš„æ±‡ç‡ä¿¡æ¯å¹¶ä¼ é€ç»™CurrencyConvertActivityï¼Œç”¨æ¥è®¡ç®—é‡‘é¢ï¼› å¦‚æœæˆ‘ä»¬æƒ³åœ¨Appå¯åŠ¨æ—¶æ ¹æ®ç³»ç»Ÿä¸­ç”¨æˆ·è®¾å®šçš„å½“å‰å›½å®¶æ¥æ˜¾ç¤ºå¯¹åº”çš„å›½å®¶è´§å¸ï¼Œå¹¶ä¸”åœ¨ç”¨æˆ·åˆ‡æ¢å›½å®¶/æ—¶åŒºæ—¶åœ¨APPå†…è¿›è¡Œå®æ—¶æ›´æ–°ï¼Œå°±éœ€è¦å»ºç«‹ä¸€ä¸ªCountryChangeReceiveræ¥ç›‘å¬TIMEZONE_CHANGEDç³»ç»Ÿäº‹ä»¶å¹¶åœ¨ç›‘å¬åˆ°åˆ‡æ¢å›½å®¶/æ—¶åŒºæ—¶è¿›è¡Œè¯†åˆ«ï¼› å¦‚æœæˆ‘ä»¬æƒ³å°†å®æ—¶è·å¾—çš„æ±‡ç‡è¿›è¡Œç¼“å­˜ï¼Œä»¥ä¾¿åœ¨ç½‘ç»œç¯å¢ƒæ¶åŠ£çš„æƒ…å†µä¸‹è·å¾—æœ€è¿‘ä¸€æ¬¡å®æ—¶æ±‡ç‡è¡¨ï¼Œé‚£ä¹ˆå°±å¯ä»¥ä½¿ç”¨ExchangeRateContentProviderå°†æ±‡ç‡æ•°æ®è¿›è¡Œä¿å­˜å’Œå¤„ç† ç°åœ¨æ•´ä¸ªApplicationçš„æ¶æ„å¤§è‡´å°±æ˜¯è¿™æ ·: 123456789101112131415161718192021222324252627282930313233&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; package=&quot;com.yunze.myapplication&quot;&gt; &lt;application android:allowBackup=&quot;true&quot; android:icon=&quot;@mipmap/ic_launcher&quot; android:label=&quot;@string/app_name&quot; android:roundIcon=&quot;@mipmap/ic_launcher_round&quot; android:supportsRtl=&quot;true&quot; android:theme=&quot;@style/AppTheme&quot;&gt; &lt;activity android:name=&quot;com.yunze.myapplication.CurrencyActivity&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt; &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;service android:name=&quot;.BackendService&quot;&gt; &lt;intent-filter /&gt; &lt;/service&gt; &lt;receiver android:name=&quot;.CountryChangeReceiver&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.TIMEZONE_CHANGED&quot; /&gt; &lt;/intent-filter&gt; &lt;/receiver&gt; &lt;provider android:name=&quot;.ExchangeRateContentProvider&quot; android:authorities=&quot;.ExchangeRateDB&quot;&gt; &lt;/provider&gt; &lt;/application&gt;&lt;/manifest&gt; ä¸Šé¢æ˜¾ç¤ºçš„è¿™ä¸ªAndroidManifest.xmlï¼Œå¯ä»¥ç†è§£ä¸ºä¸€ä¸ªAndroid Applicationçš„â€œéª¨æ¶â€ã€‚æ­£å¦‚æˆ‘ä»¬ä¹‹å‰æ‰€è¯´ï¼ŒActivityï¼ŒServiceï¼ŒBroadcastReceiverå’ŒContentProviderå¯ä»¥ç®—æ˜¯Android Applicationçš„å››å¤§â€œç»„ä»¶â€ã€‚è€ŒAndroidManifest.xmlæ–‡ä»¶åˆ™æ­£æ˜¯ç”³æ˜è¿™ä¸ªAppæ‰€ä½¿ç”¨çš„æ‰€æœ‰ç»„ä»¶çš„åœ°æ–¹ï¼Œæ‰€ä»¥å½“æˆ‘ä»¬å¼€å§‹ä¸Šæ‰‹ä¸€ä¸ªæ–°çš„å®‰å“é¡¹ç›®æ—¶ï¼Œåº”è¯¥è¦ä»AndroidManifest.xmlå¼€å§‹çœ‹èµ·ï¼Œæ‰èƒ½æ¯”è¾ƒè¯¦å°½å…¨é¢åœ°äº†è§£è¿™ä¸ªAppã€‚ Android Componentsä¸‹é¢å…·ä½“æ¥æ¯”è¾ƒä¸€ä¸‹ä¸åŒçš„ç»„ä»¶ä¹‹é—´çš„å…³ç³»ï¼Œè®©æˆ‘ä»¬æœ‰æ›´è¿›ä¸€æ­¥çš„äº†è§£ã€‚ Activityï¼šæ•´ä¸ªAndroidå¼€å‘ä¸­æœ€ä¸ºé‡è¦çš„ä¸€ä¸ªæ¦‚å¿µã€‚Acitivityä¸­å®šä¹‰äº†Appä¸ç”¨æˆ·çš„äº¤äº’é€»è¾‘ï¼Œä¾‹å¦‚å½“ç”¨æˆ·ç‚¹å‡»å½“å‰è¿™ä¸ªæŒ‰é’®ï¼Œåº”è¯¥å‘ç”Ÿä»€ä¹ˆäº‹ï¼Œæ˜¯æ˜¾ç¤ºä¸€ä¸ªæ–‡æœ¬æ¡†ï¼Œæ›´æ”¹å›¾ç‰‡çš„é¢œè‰²ï¼Œæˆ–è€…å…³é—­å½“å‰ç•Œé¢å›åˆ°ä¸Šä¸€ä¸ªç•Œé¢ç­‰ç­‰ã€‚å¯ä»¥è¯´ï¼šæ‰€æœ‰å…³äºç”¨æˆ·äº¤äº’çš„é€»è¾‘å…¨éƒ¨éƒ½åªèƒ½å®šä¹‰å’Œå­˜åœ¨ä¸Activityä¹‹ä¸­ã€‚ Serviceï¼šå¦‚æœæˆ‘ä»¬çš„APPä¸­éœ€è¦ä¸€ä¸ªé•¿æ—¶é—´è¿è¡Œåœ¨åå°æ¥å¤„ç†ä¸šåŠ¡çš„åŠŸèƒ½ï¼Œæ¯”å¦‚é¢‘ç¹å‘æœåŠ¡å™¨å‘é€è¯·æ±‚ï¼Œæˆ–è€…éœ€è¦ç­‰å¾…æœåŠ¡å™¨éšæ—¶è¿”å›è¯·æ±‚ï¼Œæˆ–è€…è¦é•¿æ—¶é—´ä»æœåŠ¡å™¨åŠ è½½å¤§å‹æ–‡ä»¶ï¼ˆæ¯”å¦‚åœ¨çº¿æµè§ˆè§†é¢‘ï¼‰ï¼Œæ­¤æ—¶å°±éœ€è¦ç”¨åˆ°æˆ‘ä»¬çš„Serviceç»„ä»¶ã€‚Serviceç»„ä»¶æœ€é‡è¦çš„ç‰¹å¾å°±æ˜¯ï¼šå¯ä»¥é•¿æ—¶é—´çš„è¿è¡Œåœ¨åå°è¿›è¡ŒæœåŠ¡ï¼Œç›´åˆ°å®Œæˆä»»åŠ¡åå°†è‡ªå·±ç»“æŸï¼Œå¹¶ä¸”å…¶ä¸­ä¸èƒ½å®šä¹‰ä»»ä½•ä¸ç”¨æˆ·UIæœ‰å…³çš„å†…å®¹ã€‚ BroadcastReceiver: è¿™å¯èƒ½æ˜¯å››ä¸ªç»„ä»¶ä¸­æ¯”è¾ƒä¸å¥½ç†è§£çš„ä¸€ä¸ªï¼Œå…¶å®å¯ä»¥æŠŠå®ƒæƒ³è±¡æˆAPPçš„ä¸€æ ¹â€œå¤©çº¿â€ï¼Œå®ƒçš„åŠŸèƒ½å°±æ˜¯ä¸»åŠ¨æ¥å—å…¶ä»–APPä¼ æ¥çš„ç‰¹å®šâ€œä¿¡å·â€ã€‚æ¯”å¦‚æˆ‘ä»¬ä¹‹å‰è¯´çš„TIMEZONE_CHANGEDè¿™ä¸ªeventï¼Œå½“å®‰å“ç³»ç»Ÿæ£€æµ‹åˆ°ç”¨æˆ·æ‰‹æœºåˆ‡æ¢äº†æ—¶åŒºæ—¶ï¼Œå°±ä¼šå‘æ•´ä¸ªç³»ç»Ÿå†…å¹¿æ’­è¿™ä¸ªTIMEZONE_CHANGED eventï¼Œæ­¤æ—¶å¦‚æœæˆ‘ä»¬çš„APPä¸­å«æœ‰ä¸€ä¸ªæ³¨å†Œäº†TIMEZONE_CHANGEDçš„BroadcastReceiverï¼Œé‚£ä¹ˆè¿™ä¸ªreceiverå°±ä¼šè¢«è§¦å‘å¹¶å®Œæˆä¸€ç³»åˆ—æˆ‘ä»¬å®šä¹‰å¥½çš„é€»è¾‘ã€‚ ContentProviderï¼šè¿™ä¸ªç»„ä»¶ä¸€èˆ¬ä¸ºå­˜å‚¨å’Œè·å–æ•°æ®æä¾›ç»Ÿä¸€çš„æ¥å£ï¼Œå¯ä»¥åœ¨ä¸åŒçš„åº”ç”¨ç¨‹åºä¹‹é—´å…±äº«æ•°æ®ã€‚é€šè¿‡è¿™ä¸ªæ¥å£ï¼Œå…¶ä»–åº”ç”¨çœ‹ä¸åˆ°æ•°æ®æ˜¯å¦‚ä½•å­˜å‚¨çš„, ä½†é€šè¿‡ContentResolverå¯ä»¥å¯¹å…¶è¿›è¡ŒåŒ…æ‹¬ï¼šæ·»åŠ (insert), åˆ é™¤(delete), è·å–(query), ä¿®æ”¹(update) &amp; è¿”å›MIMEç±»å‹(getType)ç­‰ä¸€ç³»åˆ—çš„æ“ä½œã€‚åœ¨è¿™ä¸ªç»„ä»¶ä¸­ï¼Œæ‰€æœ‰æ–‡ä»¶éƒ½æ˜¯é€šè¿‡URIæ¥è¯†åˆ«ï¼Œç»“æ„ä¸º: content://æˆæƒä¿¡æ¯/è¡¨å/è®°å½•ã€‚ è¿™é‡Œè¦ç¨å¾®è¯´ä¸€ä¸‹BroadcastReceiverä¸Serviceçš„åŒºåˆ«ï¼Œå®ƒä»¬éƒ½æ˜¯è¿è¡Œåœ¨åå°ï¼Œä¸å¸¦æœ‰ä»»ä½•UIçš„ç»„ä»¶ã€‚ä½†æ˜¯Serviceä½œä¸ºæ¶ˆæ¯çš„æ¥æ”¶æ–¹æ˜¯åªèƒ½è¢«å•ç‹¬è§¦å‘çš„ï¼Œè€Œä¸åŒçš„BoardcastReceiverå´æ˜¯å¯ä»¥è¢«ä¸€èµ·è§¦å‘çš„ï¼Œå‰æå°±æ˜¯å®ƒä»¬éƒ½æ³¨å†Œäº†åŒä¸€ä¸ªeventã€‚ä¸‹é¢æ˜¯åœ¨çœ‹ä»–äººçš„æ€»ç»“ä»‹ç»æ—¶çœ‹åˆ°çš„ä¸€å¼ å¾ˆæœ‰æ„æ€çš„å›¾ï¼š ä»è¿™å¼ å›¾ä¸Šæ¥çœ‹ï¼Œæœ‰å‡ ç‚¹å€¼å¾—æˆ‘ä»¬ç‰¹åˆ«æ³¨æ„çš„ï¼š åªæœ‰Activityæ‰å¯ä»¥å¯åŠ¨ä¸€ä¸ªæ–°çš„Activityï¼ˆç†è®ºä¸Šè®²å…¶å®æ˜¯æœ‰å…¶ä»–åŠæ³•å¯ä»¥ä»Serviceå’ŒBoardcastReceiverä¸­å¯åŠ¨çš„ï¼Œä½†æ˜¯è¿™é‡Œè¯´çš„ä¸æ˜¯â€œèƒ½ä¸èƒ½â€ï¼Œè€Œæ˜¯â€œæ˜¯å¦åº”è¯¥â€ï¼‰ï¼Œå½“æˆ‘ä»¬åˆ›å»ºä¸€ä¸ªæ–°çš„Androidé¡¹ç›®æ—¶ï¼Œéƒ½ä¼šè‡ªåŠ¨ç”Ÿæˆä¸€ä¸ªMainActivityï¼Œæ‰€æœ‰å…³äºAPPçš„è¡Œä¸ºå’Œé€»è¾‘éƒ½åº”è¯¥åœ¨è¿™ä¸ªæˆ–è€…å‡ ä¸ªActivityå†…æ¥å®Œæˆï¼Œé¡¹ç›®ä¹Ÿä¼šæœ‰ä¸€ä¸ªApplicationç±»ï¼Œè¿™ä¸ªç±»ä¸€èˆ¬æ˜¯ä½œä¸ºå„ç§Activityçš„å®¹å™¨æ¥ä½¿ç”¨ï¼Œä¸è¦è½»æ˜“å°†ä»£ç é€»è¾‘å†™åœ¨Applicationé‡Œï¼›è€Œå¯åŠ¨æ–°çš„Activityçš„æ–¹å¼å°±æ˜¯åœ¨StartActivity()æ–¹æ³•ä¸­ä¼ é€’ä¸€ä¸ªIntentç±»ï¼Œè¿™ä¸ªä¸‹é¢ä¼šè®²åˆ°ã€‚ åªæœ‰Activityæ‰å¯ä»¥Layout Inflationã€‚è¿™ä¸ªä¹Ÿæ¯”è¾ƒå¥½ç†è§£ï¼Œå› ä¸ºå‰é¢è¯´è¿‡ï¼Œåªæœ‰Activityæ‰èƒ½å¤„ç†å’Œç”¨æˆ·çš„äº¤äº’ï¼Œæ˜¾ç¤ºæ‰€æœ‰çš„UIå’ŒLayoutï¼ˆå…¶å®æ‰€æœ‰çš„UIéƒ½åªèƒ½runåœ¨UI Threadï¼Œä¹Ÿå°±æ˜¯Main Threadä¸Šï¼Œè€Œåªæœ‰Activityå¯ä»¥accessåˆ°Main Threadï¼Œæ‰€ä»¥å½“ç„¶åªæœ‰å®ƒå¯ä»¥å¤„ç†UIçš„éƒ¨åˆ†ï¼‰ã€‚å½“ç„¶ä¹Ÿæ˜¯æœ‰Tricky wayæ¥åšçš„ï¼Œæ¯”å¦‚call runOnUiThread()ä¹‹ç±»çš„ï¼Œä¹‹åç­‰åˆ°å†™multi-threadçš„æ—¶å€™ä¼šæ¶‰åŠè¿™éƒ¨åˆ†ã€‚ Broadcast Receiveræ‰€ç›‘å¬çš„Eventä¸€èˆ¬æ¥è¯´æ˜¯å‘å…¨ç³»ç»Ÿå¹¿æ’­çš„ä¸€äº›äº‹ä»¶ï¼Œæ¯”å¦‚æ‰‹æœºè¿æ¥å¥½äº†WIFIï¼Œæ‰‹æœºå¤–æ¥äº†ç”µæºç­‰ç­‰ã€‚å½“ç„¶ä¹Ÿå¯ä»¥ç›‘å¬è‡ªå®šä¹‰çš„eventï¼Œä½†æ˜¯æ ¹æ®æˆ‘ä»¬å‰é¢è¯´çš„ç”¨é€”ï¼Œè‡ªå®šä¹‰çš„æƒ…å†µæ¯”è¾ƒå°‘ï¼Œæ¯•ç«Ÿæ²¡æœ‰å¿…è¦åªå‘è‡ªå·±çš„ä¸€ä¸ªserviceæˆ–è€…activityè¿›è¡Œå¹¿æ’­ã€‚ Communication between Componentsä¸‹é¢æˆ‘ä»¬æ¥äº†è§£ä¸€ä¸‹å„ç»„ä»¶é—´çš„é€šä¿¡æ–¹å¼ï¼Œæ‰€è°“â€œé€šä¿¡â€ï¼Œå…¶å®å°±æ˜¯æŒ‡ï¼š1. ä»ä¸€ä¸ªç»„ä»¶å‘å¦ä¸€ä¸ªç»„ä»¶ä¼ é€’å‚æ•°ï¼›2. ä»ä¸€ä¸ªç»„ä»¶ç”Ÿæˆå¦ä¸€ä¸ªæ–°ç»„ä»¶ã€‚ä¼ é€’å‚æ•°çš„æ–¹å¼æœ‰å¾ˆå¤šï¼Œä½†æ˜¯ç”Ÿæˆç»„ä»¶çš„æ–¹å¼å´å¾ˆæœ‰é™ï¼š Activityå¯åŠ¨ä¸€ä¸ªæ–°çš„Activityçš„æ–¹å¼ä¸»è¦å°±æ˜¯é€šè¿‡ startActivity() æˆ–startActivityForResult() æ–¹æ³•å¹¶ä¼ é€’ä¸€ä¸ªIntentå®ä¾‹ã€‚è¿™ä¸¤ä¸ªæ–¹æ³•çš„ä¸»è¦åŒºåˆ«åœ¨äºæ˜¯å¦éœ€è¦ä»æ–°çš„activityè¿”å›ä¸€ä¸ªç»“æœï¼Œæ¯”å¦‚é€šè¿‡æ–°çš„activityé€‰æ‹©ä¸€å¼ æœ¬åœ°å­˜å‚¨çš„å›¾ç‰‡ï¼Œæˆ–è€…é€šè¿‡æ–°çš„activityç¡®å®šä¸€ä¸ªæ–‡ä»¶æ˜¯å¦å·²ç»å‘é€å®Œæ¯•ç­‰ç­‰ã€‚Intentä¸­åŒ…å«äº†æ–°çš„Activityçš„ç±»åä»¥åŠä¸€äº›åˆå§‹åŒ–éœ€è¦çš„æ•°æ®(Extra)ã€‚ é€šè¿‡putExtra()æ–¹æ³•å¯ä»¥å°†è¿™äº›æ•°æ®ä¼ å…¥Intentï¼Œä»è€Œä¼ é€’ç»™æ–°çš„Activityã€‚ Serviceå¯åŠ¨ä¸€ä¸ªServiceçš„æ–¹æ³•å¤§è‡´æœ‰ä¸‰ç§ï¼š ç›´æ¥å¼€å¯ï¼šé€šè¿‡startService()æ–¹æ³•å¹¶ä¼ é€’ä¸€ä¸ªIntentå®ä¾‹ï¼Œè¿™ä¸ªæ–¹æ³•å’ŒActivityåŸºæœ¬ä¸€è‡´ï¼› ç»‘å®šå¼€å¯ï¼šé€šè¿‡bindService()æ–¹æ³•å¹¶ä¼ é€’ä¸€ä¸ªIntentå®ä¾‹ï¼Œç»‘å®šå¼€å¯ä¸ç›´æ¥å¼€å¯çš„ä¸€ä¸ªæœ€å¤§çš„åŒºåˆ«å°±æ˜¯ï¼šç»‘å®šå¼€å¯çš„serviceä¼šåœ¨å¼€å¯å®ƒçš„ç»„ä»¶ç”Ÿå‘½å‘¨æœŸç»“æŸæ—¶éšä¹‹ç»“æŸï¼Œè€Œç›´æ¥å¼€å¯åˆ™ä¸ä¼šã€‚å®é™…ä¸Šï¼Œç›´æ¥å¼€å¯çš„serviceä¼šä¸€ç›´è¿è¡Œï¼Œç›´åˆ°stopService()è¢«æ‰§è¡Œï¼Œæˆ–è€…Appè¢«å¸è½½ã€‚ JobSchedulerè°ƒåº¦ï¼šåœ¨Android 5.0+ä¸­ï¼Œå¯ä»¥é€šè¿‡JobSchedulerä¸­çš„schedule()æ–¹æ³•æ¥å¯åŠ¨ä¸€ä¸ªserviceï¼Œè¿™ä¸ªæ–¹å¼ç›®å‰æˆ‘è¿˜æ²¡æœ‰ç”¨åˆ°è¿‡ï¼Œä»¥åå¦‚æœæ¶‰åŠåˆ°å†å•ç‹¬å†™ä¸€ç¯‡å§ã€‚ BroadcastReceiverå¯åŠ¨BroadcastReceiverçš„æ–¹å¼å’ŒActivityåŸºæœ¬ä¸€è‡´ï¼ŒåŒºåˆ«åœ¨äºå¯ä½¿ç”¨çš„æ–¹æ³•æ›´å¤šï¼Œå…¶ä¸­åŒ…æ‹¬ï¼šsendBroadCast()ï¼ŒsendOrderedBroadcast()ä»¥åŠsendStickyBroadcast()ï¼Œä¹Ÿéƒ½éœ€è¦ä¼ é€’Intentå®ä¾‹åˆ°å„ä¸ªæ–¹æ³•ä¸­ã€‚Broadcastæœ‰ä¸€ä¸ªä¸åŒç‚¹åœ¨äºé™æ€æ³¨å†Œ/åŠ¨æ€æ³¨å†Œï¼Œä¹‹åä¼šä¸“é—¨å†™ä¸€ç¯‡è®²å®ƒã€‚ ContentProviderè¿™ä¸ªç»„ä»¶å’Œå…¶ä»–ç»„ä»¶ä¸åŒï¼Œå› ä¸ºå®ƒåªæ˜¯ä¸€ä¸ªæ¥å£ï¼Œæ‰€ä»¥å…¶ä¸éœ€è¦è¿›è¡Œå¯åŠ¨æˆ–è€…åˆå§‹åŒ–ã€‚è€Œä½¿ç”¨ContentProviderçš„ä¸€èˆ¬æ­¥éª¤åŒ…æ‹¬ï¼š åˆ›å»ºä¸€ä¸ªå®ç°ContentProvideræ¥å£çš„ç±»ï¼Œå¹¶å®ç°æ¥å£ä¸­çš„å„ä¸ªæ–¹æ³•ï¼ˆinsert()ï¼Œ delete()ï¼Œ query()ç­‰ï¼‰; åœ¨AndroidManifest.xmlä¸­è¿›è¡Œæ³¨å†Œï¼› é€šè¿‡getContentResolver().query(URI)æ–¹æ³•å°±å¯ä»¥ç›´æ¥è·å¾—å®šä¹‰çš„ContentProviderä¸­çš„æ•°æ®ã€‚ å‚è€ƒé“¾æ¥Application Fundamentals - Google Android å®˜æ–¹è¯´æ˜æ–‡æ¡£","link":"/2020/06/10/AndroidBasic1/"},{"title":"Androidå¼€å‘ç¬”è®°ä¹‹åŸºç¡€ç¯‡ï¼ˆäºŒï¼‰","text":"ä¹‹å‰çš„Androidå¼€å‘ç¬”è®°ä¹‹åŸºç¡€ç¯‡(ä¸€)ä¸­ä¸»è¦è®²åˆ°äº†ä¸€äº›å…³äºAndroid Componentsçš„åŸºæœ¬æ¦‚å¿µä»¥åŠå®ƒä»¬çš„å¼‚åŒã€‚ä»Šå¤©å°±æ¥è®²è§£ä¸€ä¸‹å…³äºActivityä¸­æ¶‰åŠUIéƒ¨åˆ†çš„ä¸‰ä¸ªæ ¸å¿ƒç»„ä»¶ï¼šActivityï¼ŒFragmentå’ŒDialogã€‚å®ƒä»¬åŸºæœ¬æ‰¿æ‹…èµ·äº†APPä¸­æ‰€æœ‰çš„å›¾å½¢ç•Œé¢å’Œäº¤äº’é€»è¾‘ï¼Œä¹Ÿæ˜¯é¢å‘ç”¨æˆ·æœ€ç›´è§‚çš„å±•ç°ã€‚ Activityå‰é¢æˆ‘ä»¬è¯´åˆ°è¿‡ï¼Œåœ¨Activityä¸­å®šä¹‰äº†ä¸ç”¨æˆ·äº¤äº’çš„æ‰€æœ‰é€»è¾‘ï¼ˆPresentation Layer Logicï¼‰ã€‚ä¸¾ä¸ªä¾‹å­ï¼Œæˆ‘ä»¬æƒ³åšä¸€ä¸ªç”µè¯æœ¬Appï¼Œé‚£ä¹ˆå°±éœ€è¦è®¾è®¡å½“ç”¨æˆ·ç‚¹å‡»æŸä¸ªæŒ‰é’®æ—¶ï¼Œå…¶èƒŒåå‘ç”Ÿçš„ä¸€åˆ‡é€»è¾‘ï¼Œè€Œè¿™äº›å®šä¹‰éƒ½åŒ…å«åœ¨Activityä¸­ã€‚é‚£ä¹ˆï¼Œä¸€ä¸ªApplicationä¸­å¯ä»¥åŒ…å«å¤šä¸ªActivityä¹ˆï¼Ÿç­”æ¡ˆå½“ç„¶æ˜¯å¯ä»¥çš„ï¼Œè€Œä¸”æ˜¯å‡ ä¹å¿…é¡»çš„ï¼æƒ³è±¡ä¸€ä¸‹åœ¨è¿™ä¸ªApplicationä¸­å¯èƒ½ä¼šå‡ºç°çš„ç•Œé¢åŒ…æ‹¬ï¼š åŸºæœ¬çš„æµè§ˆç”µè¯æœ¬é¡µé¢ï¼ˆDashboardActivityï¼‰ï¼Œæ˜¾ç¤ºä¸€ä¸ªè”ç³»äººçš„åˆ—è¡¨ï¼› å½“é€‰ä¸­ä¸€ä¸ªç”µè¯æ—¶ï¼Œè¦æ˜¾ç¤ºä¸€ä¸ªè¯¦ç»†è”ç³»äººçš„é¡µé¢ï¼ˆContactActivityï¼‰ï¼› ç‚¹å‡»ç”µè¯å·ç æ—¶ï¼Œå¼¹å‡ºä¸€ä¸ªæ‹¨æ‰“ç”µè¯çš„ç•Œé¢(DialingActivity)ï¼› Dashboardé‡Œè¦æœ‰ä¸€ä¸ªâ€œç¼–è¾‘â€æŒ‰é’®ï¼Œç‚¹å‡»åå¼¹å‡ºä¸€ä¸ªæ–°å»ºè”ç³»äººç•Œé¢ï¼ˆNewContactActivityï¼‰ å¯ä»¥çœ‹å‡ºï¼Œè¿™æ¯ä¸€ä¸ªå•ç‹¬çš„ç•Œé¢ï¼Œéƒ½æ˜¯ä¸€ä¸ªä¸“é—¨çš„Activityã€‚ä¹Ÿæ­£æ˜¯å› ä¸ºä¸€ä¸ªAPPä¸­æœ‰å¤šä¸ªActivityçš„å­˜åœ¨ï¼Œæ‰ä½¿æ•´ä¸ªå®‰å“Appçš„æ¶æ„å˜å¾—æ›´åŠ æ¸…æ™°ï¼Œä¹Ÿæ›´æœ‰åˆ©äºæˆ‘ä»¬é˜…è¯»ï¼Œé‡æ„ä»¥åŠdebugã€‚ å¯¹äºä¸€ä¸ªActivityæ¥è¯´ï¼Œå¯ä»¥é‡‡ç”¨å¤šç§ä¸åŒçš„è®¾è®¡æ¨¡å¼ï¼ˆDesign Patternï¼‰æ¯”å¦‚MVCï¼ŒMVVMä»¥åŠMVPã€‚è¿™å…¶ä¸­æˆ‘ä¸ªäººéå¸¸å–œæ¬¢MVPï¼ˆModel-View-Presenterï¼‰æ¥è®¾è®¡ä»£ç ã€‚å¯¹äºä¸åŒçš„Activityï¼Œå‡ºäºè§£è€¦ï¼ˆDe-couplingï¼‰çš„è€ƒè™‘ï¼Œé€šå¸¸å°†å®ƒä»¬æ”¾å…¥ä¸åŒçš„packageä¸­ï¼Œæ–¹ä¾¿åŒºåˆ†ä»¥åŠæ—¥åå¯¹å®ƒä»¬åˆ†åˆ«è¿›è¡Œé‡æ„ã€‚åƒå¦‚ä¸Šæˆ‘ä»¬ä¸¾ä¾‹çš„ç”µè¯Appï¼Œå®ƒçš„ç»“æ„å¤§è‡´å°±æ˜¯è¿™æ ·ï¼š åœ¨ä¸Šä¸€æ¬¡æˆ‘ä»¬è¯´åˆ°ï¼ŒAndroidManifestè¿™ä¸ªæ–‡ä»¶é‡Œå®šä¹‰äº†æ‰€æœ‰Appæ‰€éœ€è¦çš„Activityï¼ŒServiceï¼ŒBoardcastReceiver, ContentProviderç­‰ç­‰ï¼Œæ‰€ä»¥ä¸è¦å¿˜è®°åœ¨åˆ›å»ºå®ŒActivityä¹‹åï¼Œä¸€å®šè¦åœ¨Manifesté‡Œé¢æŠŠå®ƒå£°æ˜å¥½ã€‚ Activity Lifecycleå…³äºç”Ÿå‘½å‘¨æœŸï¼ˆLifecycleï¼‰ï¼Œæˆ‘ä»¬åªéœ€è¦çŸ¥é“å®ƒå®šä¹‰äº†ä¸€ä¸ªç»„ä»¶ä»€ä¹ˆæ—¶å€™è¢«åˆå§‹åŒ–ï¼Œä»€ä¹ˆæ—¶å€™å¯¹åº”ä»€ä¹ˆçŠ¶æ€ï¼Œä»¥åŠåº”è¯¥åœ¨ä½•æ—¶è¿›è¡Œä½•ç§æ“ä½œå³å¯ã€‚Activityçš„ç”Ÿå‘½å‘¨æœŸå¦‚ä¸‹å›¾æ‰€ç¤ºï¼š è®©æˆ‘ä»¬æ¥ä¸€æ­¥æ­¥è¯´æ˜ä¸€ä¸‹å„ç”Ÿå‘½å‘¨æœŸæ–¹æ³•çš„ä½œç”¨ï¼š onCreate()ï¼šå¿…é¡»å®ç°ï¼Œä¸»è¦ç”¨äºåˆå§‹åŒ–activityä»¥åŠè®¾å®šå„ç§å‚æ•°ï¼› onRestart()ï¼šonStop()åå¦‚æœæ²¡æœ‰è¢«killï¼Œä¼šä»è¿™é‡Œå”¤é†’ï¼Œæ—©äºonStart()ï¼› onStart()ï¼šç³»ç»Ÿæ­£åœ¨å¯åŠ¨ï¼ŒUIå·²æ˜¾ç¤ºï¼Œä½†æ— æ³•äº¤äº’ï¼› onResume()ï¼šUIå·²æ˜¾ç¤ºï¼Œç”¨æˆ·å¯ä»¥è¿›è¡Œäº¤äº’ï¼Œè€Œå¦‚æœåœ¨Acitivityå†…éƒ¨åˆå§‹åŒ–å…¶ä»–Dialogæˆ–Fragmentæ—¶ï¼Œä¸è®ºactivityæ˜¯å¦å…¨å±ï¼Œå®ƒéƒ½ä¼šä¿æŒåœ¨æ­¤çŠ¶æ€ï¼› onPause()ï¼šæœ€å¥½åœ¨æ­¤é‡Šæ”¾CPUï¼Œä¿å­˜æ•°æ®ï¼› onStop()ï¼šactivityå®Œå…¨ä»å‰å°ç»“æŸï¼Œçœ‹ä¸è§æ—¶è¿›å…¥æ­¤çŠ¶æ€ï¼› onDestory()ï¼šactivityè¢«å®Œå…¨é”€æ¯ï¼Œå¯ä»¥åšå›æ”¶å’Œæœ€ç»ˆé‡Šæ”¾ã€‚ å¦å¤–å€¼å¾—æ³¨æ„çš„ä¸€ç‚¹å°±æ˜¯ï¼šå½“è®¾å¤‡è¿›è¡Œæ¨ªç«–å±åˆ‡æ¢æ—¶ï¼šacitivityä¼šé”€æ¯å¹¶é‡æ–°åˆå§‹åŒ–ã€‚å¦‚ä¸é”€æ¯ï¼Œéœ€åœ¨manifestå¯¹åº”çš„activityå†…éƒ¨å£°æ˜configChange=â€œorientation | screenSizeâ€, æ­¤æ—¶onConfigurationChanged()ä¼šè¢«callã€‚ Fragmentåœ¨è¯´å®ŒActivityä¹‹åï¼Œä¸‹é¢æˆ‘ä»¬è¦è¯´ä¸€ä¸‹Fragmentè¿™ä¸ªé‡è¦çš„componentã€‚åœ¨å„ç§Androidçš„æ¡£æ¡ˆå®šä¹‰é‡Œï¼Œéƒ½ä¼šåå¤å‡ºç°å¯¹äºFragmentçš„å®šä¹‰ï¼šA Fragment represents a behavior or a portion of user interface in a FragmentActivity. You can combine multiple fragments in a single activity to build a multi-pane UI and reuse a fragment in multiple activities. ä½†æ˜¯æˆ‘ä¸€ç›´å°±è§‰å¾—è¿™ä¸ªè§£é‡Šéå¸¸ä¸æ˜ç¡®ï¼Œä¸ºä»€ä¹ˆæˆ‘ä»¬éœ€è¦ç”¨Fragmentå‘¢ï¼Ÿæˆ‘ä¸ªäººçš„ç†è§£æ˜¯ï¼šå½“åœ¨ä¸€ä¸ªActivityå†…æœ‰å¤šä¸ªå•ç‹¬æ˜¾ç¤ºçš„é¡µé¢ï¼Œå¹¶ä¸”æ¯ä¸ªé¡µé¢ä¸ç”¨æˆ·äº¤äº’çš„é€»è¾‘éƒ½å„ä¸ç›¸åŒæ—¶ï¼ŒFragmentå¯ä»¥å¸®åŠ©æˆ‘ä»¬å‡å°‘å¾ˆå¤šéº»çƒ¦ï¼Œå°†æ•´ä¸ªActivityçš„æ¶æ„å˜å¾—ååˆ†æ¸…æ™°ã€‚è¿™æ˜¯æˆ‘è®¤ä¸ºFragmentæœ€ä¸ºæœ‰ç”¨çš„ä¸€ç‚¹ã€‚ è¿˜æ˜¯ä»¥å‰é¢çš„ç”µè¯æœ¬Appä¸ºä¾‹ï¼Œåœ¨æ‹¨æ‰“ç”µè¯çš„ç•Œé¢DialingActivityä¸­ï¼Œå¯èƒ½ä¼šåˆ†ä¸ºä¸‰ä¸ªé˜¶æ®µï¼š æ¥æ”¶åˆ°æ¥ç”µï¼ˆInComingCallï¼‰ ç”µè¯è¢«æ¥é€šï¼ˆCallingï¼‰ é€šè¯ç»“æŸï¼ˆCallEndedï¼‰ æ ¹æ®éœ€æ±‚ä¸åŒï¼Œè¿™ä¸‰ä¸ªé˜¶æ®µçš„ç•Œé¢å¯èƒ½ä¼šæœ‰å®Œå…¨ä¸åŒçš„UIå¸ƒå±€ï¼Œæ¯ä¸ªæŒ‰é’®ä¹Ÿå¯èƒ½ä¼šæœ‰ä¸åŒçš„åŠŸèƒ½ï¼Œä½†æ˜¯å®ƒä»¬åŒå±äºä¸€ä¸ªæ‰“ç”µè¯çš„åŠŸèƒ½ä¹‹ä¸­ï¼ˆDialingActivityï¼‰ã€‚æ­¤æ—¶å¦‚æœæˆ‘ä»¬ä½¿ç”¨ä¸‰ä¸ªä¸åŒçš„Activityï¼Œå½“ç„¶æ˜¯å¯ä»¥çš„ï¼Œè¿™ä¸ä»…æ„å‘³ç€æˆ‘ä»¬éœ€è¦åœ¨å„ä¸ªactivityä¹‹é—´ä¼ é€’å„ç§å„æ ·çš„å‚æ•°ï¼Œè€Œä¸”å¤„ç†ä¸åŒActivityä¹‹é—´çš„æ²Ÿé€šä¼šå˜å¾—ååˆ†éº»çƒ¦ï¼Œä¹Ÿä¸åˆ©äºæˆ‘ä»¬ä¹‹åå¯¹äºä»£ç çš„ç»´æŠ¤ã€‚ æ­¤æ—¶å°±è½®åˆ°Fragmentå‡ºåœºäº†ï¼Œæˆ‘ä»¬å¯ä»¥åœ¨DialingActivityé‡Œå®šä¹‰ä¸‰ä¸ªFragmentï¼šInComingCallFragmentï¼ŒCallingFragmentä»¥åŠCallEndedFragmentï¼Œæ¯ä¸ªFragmentéƒ½å¯ä»¥æœ‰è‡ªå·±çš„modelå’Œpresenterï¼ˆMVP patternï¼‰è€Œåœ¨DialingActivityé‡Œï¼Œæˆ‘ä»¬å¯ä»¥å®šä¹‰ä¸‰ä¸ªFragmentçš„å…±åŒè¡Œä¸ºé€»è¾‘ã€‚é€šè¿‡è¿™ç§æ–¹å¼ï¼Œå¯ä»¥ä½¿æ•´ä¸ªActivityç»“æ„æ¸…æ™°ï¼Œåˆ†å·¥æ˜ç¡®ï¼Œå®ƒçš„ç»“æ„å¤§æ¦‚æ˜¯è¿™æ ·ï¼š Activityå’ŒFragmentéƒ½æ˜¯å…³äºUIéƒ¨åˆ†çš„é‡è¦ç»„ä»¶ã€‚ä¸€èˆ¬æ¥è¯´å¯¹äºä¸€ä¸ªæ¯”è¾ƒæˆç†Ÿçš„Appæ¥è¯´ï¼Œå…¶åŒ…å«çš„Activityå’ŒFragmentå¯èƒ½æ˜¯æˆç™¾ä¸Šåƒçš„ï¼Œæ‰€ä»¥ç†Ÿç»ƒæŒæ¡å®ƒä»¬çš„ä½¿ç”¨æ–¹æ³•æ˜¯æä¸ºé‡è¦çš„ã€‚ Fragment LifecycleFragmentçš„ç”Ÿå‘½å‘¨æœŸç›¸æ¯”äºActivityè¦ç®€å•ä¸å°‘ï¼Œä¸‹é¢åˆ†åˆ«ç®€å•ä»‹ç»ä¸€ä¸‹å„ç”Ÿå‘½å‘¨æœŸæ–¹æ³•ä¸‹çš„ä½œç”¨ï¼š onAttach(Context context)ï¼šä¸è°ƒç”¨çš„Activityå‘ç”Ÿè”ç³»ï¼Œå¯ä»¥é€šè¿‡getActivity()è·å–è°ƒç”¨å®ƒçš„Activityå®ä¾‹ï¼› onCreate(Bundle savedInstanceState)ï¼šä»bundleä¸­è·å–ä»Acitivityä¼ æ¥çš„æ•°æ®ï¼Œå¯ç”¨äºåˆå§‹åŒ–ï¼› onCreateView(LayoutInflater, ViewGroup, Bundle)ï¼šåˆ›å»ºè§†å›¾ï¼Œinflaterç”¨äºè£…è½½å±€éƒ¨æ–‡ä»¶ï¼ŒviewGroupæ˜¯çˆ¶æ ‡ç­¾å¯¹è±¡ï¼› onViewCreated(View, Bundle)ï¼šæ­¤æ—¶Viewåˆ›å»ºå®Œæˆï¼Œä½†è¿˜æ²¡æœ‰æ˜¾ç¤ºï¼Œ Viewå°±æ˜¯ä¹‹å‰åˆ›å»ºçš„å¯¹è±¡ï¼› onActivityCreated(Bundle)ï¼šçª—å£åˆå§‹åŒ–å·²å®Œæˆï¼Œå¯ä»¥é€šè¿‡findViewById()æ¥æ‰¾åˆ°Activityä¸­çš„viewï¼› onStart()ï¼šæ­¤æ—¶UIå·²ç»æ˜¾ç¤ºåœ¨å±å¹•ä¸Šï¼Œä½†æ— æ³•äº¤äº’ï¼› onResume()ï¼šå¯ä»¥ä¸ç”¨æˆ·å¼€å§‹è¿›è¡Œäº¤äº’äº†ï¼› onPause()ï¼šå¯ä»¥ä¿å­˜ä¸€äº›ä¸´æ—¶æ€§çš„æš‚å®šå·¥ä½œï¼Œæ¯”å¦‚æ’­æ”¾å™¨çš„ä¿å­˜éŸ³ä¹æ’­æ”¾è¿›åº¦ï¼Œä»¥ä¾¿åœ¨OnResumeé‡Œæ¢å¤ï¼› onStop()ï¼šfragmentä»å±å¹•ä¸Šæ¶ˆå¤±ï¼› onDestroyView()ï¼šç§»é™¤æ‰€æœ‰è§†å›¾ï¼Œæ‰€æœ‰åœ¨onCreateViewä¸­çš„è§†å›¾éƒ½å°†è¢«ç§»é™¤ï¼› onDestroy()ï¼šæ­¤æ—¶Activityè¿˜æ˜¯å’ŒFragmentä¿æŒè”ç³»çš„ï¼Œå¯ä»¥è·å¾—Fragmentå¯¹è±¡ï¼Œæ— æ³•è¿›è¡Œä»»ä½•æ“ä½œï¼› onDetach()ï¼šæœ€åä¸€æ­¥,æ‰§è¡Œè¿‡åActivityä¸Fragmentä¸å†æœ‰ä»»ä½•å…³è”ã€‚ æ­¤å¤–ï¼Œå…³äºFragmentç”Ÿå‘½å‘¨æœŸè¿˜æœ‰å‡ ç‚¹å€¼å¾—è¯´æ˜ï¼š Fragmentçš„å¼•å…¥ï¼Œä¸»è¦æ˜¯ä¸ºäº†åœ¨å¤§å±å¹•ä¸Šæ˜¾ç¤ºæ›´åŠ çµæ´»çš„ç•Œé¢è®¾è®¡ï¼Œæ¯”å¦‚åœ¨å¹³æ¿ç”µè„‘ä¸Šï¼Œå¯ä»¥åŒæ—¶å¹¶æ’æ˜¾ç¤ºä¸¤ä¸ªFragmentï¼› Fragmentå¿…é¡»å§‹ç»ˆæ‰˜ç®¡åœ¨ Activity ä¸­ï¼Œå…¶ç”Ÿå‘½å‘¨æœŸç›´æ¥å—å®¿ä¸» Activity ç”Ÿå‘½å‘¨æœŸçš„å½±å“ï¼Œå½“Activityæš‚åœæ—¶ï¼Œå…¶æ‰€æœ‰Fragmentyä¹Ÿä¼šæš‚åœï¼ŒActivityè¢«é”€æ¯æ—¶ï¼Œå…¶æ‰€æœ‰Fragmentä¹Ÿä¼šè¢«é”€æ¯ã€‚ Dialogç›¸æ¯”äºActivityå’ŒFragmentï¼ŒDialogå°±ç®€å•ä¸€äº›ã€‚Dialogä¸»è¦åº”ç”¨äºä¸€äº›ä¸´æ—¶çš„å¯¹è¯æ¡†ï¼Œæ¯”å¦‚å‘ç”¨æˆ·è¯¢é—®æ˜¯å¦å…è®¸å¼€å¯ä¸€äº›æƒé™AlertDialogï¼Œè®©ç”¨æˆ·é€‰æ‹©ä¸€ä¸ªæ—¶é—´TimePickerDialogï¼Œæˆ–è€…è‡ªå®šä¹‰ç•Œé¢è¿›è¡Œé€‰æ‹©DialogFragmentã€‚åˆå§‹åŒ–ä¸€ä¸ªç®€å•çš„Dialogçš„è¯­æ³•æ˜¯ï¼š 123456789101112131415// ä½¿ç”¨Builder classæ¥å®šä¹‰AlertDialogçš„å±æ€§val builder = AlertDialog.Builder(this)builder.setMessage(R.string.your_dialog_message) .setPositiveButton( R.string.ok, DialogInterface.OnClickListener { dialog, id -&gt; // å®šä¹‰ç”¨æˆ·æŒ‰ä¸‹OKæŒ‰é’®åçš„è¡Œä¸º }) .setNegativeButton( R.string.cancel, DialogInterface.OnClickListener { dialog, id -&gt; // å®šä¹‰ç”¨æˆ·æŒ‰ä¸‹CANCELæŒ‰é’®åçš„è¡Œä¸º })// åˆ›å»ºä¸€ä¸ªAlertDIalogå®ä¾‹builder.create() ä¸Šé¢çš„ä»£ç ä¼šåˆ›å»ºå‡ºä¸€ä¸ªå¸¦æœ‰ä¸¤ä¸ªæŒ‰é’®çš„å¯¹è¯æ¡†ï¼Œå¹¶ä¸”æ ¹æ®ç”¨æˆ·çš„é€‰æ‹©æ¥è¿è¡Œç›¸å¯¹åº”çš„é€»è¾‘ã€‚ Dialog LifecycleDialogç”±äºå…¶ç‰¹æ®Šæ€§ï¼Œå¹¶ä¸å­˜åœ¨å¤æ‚çš„ç”Ÿå‘½å‘¨æœŸï¼Œå®ƒåœ¨åˆå§‹åŒ–ä¹‹åæ˜¾ç¤ºåœ¨ç”¨æˆ·ç•Œé¢ä¸Šï¼Œéšç€ç”¨æˆ·çš„äº¤äº’è·å¾—ç»“æœåè¢«é”€æ¯ã€‚å”¯ä¸€çš„ä¾‹å¤–å°±æ˜¯DialogFragmentï¼Œå› ä¸ºå®ƒæ˜¯Fragmentçš„å­ç±»ï¼Œæ‰€ä»¥å…¶ç”Ÿå‘½å‘¨æœŸéµä»äºå…¶çˆ¶ç±»Fragmentï¼Œè¿™é‡Œä¹Ÿå°±ä¸å†èµ˜è¿°äº†ã€‚ å‚è€ƒé“¾æ¥Activity - Google Android å®˜æ–¹è¯´æ˜æ–‡æ¡£ Fragment - Google Android å®˜æ–¹è¯´æ˜æ–‡æ¡£ Dialog - Google Android å®˜æ–¹è¯´æ˜æ–‡æ¡£","link":"/2020/06/16/AndroidBasic2/"},{"title":"Androidå¼€å‘ç¬”è®°ä¹‹åŸºç¡€ç¯‡ï¼ˆä¸‰ï¼‰","text":"ä»Šå¤©çš„å†…å®¹æ˜¯è¿™å‘¨å·¥ä½œä¸­å‡ºç°çš„ä¸€ä¸ªç›¸å…³å†…å®¹çš„å­¦ä¹ ï¼šå¤šçº¿ç¨‹ï¼ˆMulti-threadï¼‰ã€‚å¤šçº¿ç¨‹å¯ä»¥æå¤§åœ°å‡å°‘ç¨‹åºåœ¨å¹¶å‘æ‰§è¡Œæ—¶æ‰€ä»˜å‡ºçš„æ—¶ç©ºå¼€é”€ï¼Œæé«˜æ“ä½œç³»ç»Ÿçš„å¹¶å‘æ€§èƒ½ã€‚åœ¨Androidçš„å¼€å‘ä¸­ï¼Œå¤šçº¿ç¨‹æ˜¯éå¸¸é‡è¦çš„ä¸€ç¯ï¼Œè€Œç›¸ä¿¡å¾ˆå¤šäººä¹Ÿåœ¨é¢è¯•ä¸­è¢«é—®åˆ°è¿‡ä¸æ­¢ä¸€æ¬¡è¿›ç¨‹ï¼ˆProcessï¼‰ä¸çº¿ç¨‹ï¼ˆThreadï¼‰çš„åŒºåˆ«ã€‚é‚£ä¹ˆæˆ‘ä»¬å°±æ¥çœ‹çœ‹å’ŒAndroidç›¸å…³çš„å¤šçº¿ç¨‹ç»„ä»¶Processï¼ŒThreadï¼ŒLooperï¼ŒHandlerå„è‡ªçš„æ¦‚å¿µå’Œå®ä¾‹ã€‚ Process vs Threadè¿›ç¨‹ï¼ˆProcessï¼‰æ˜¯å¤šçº¿ç¨‹çš„ç¬¬ä¸€ä¸ªæ¦‚å¿µã€‚ç®€å•æ¥è¯´ï¼Œè¿›ç¨‹æ˜¯æŒ‡è®¡ç®—æœºä¸­å·²ç»è¿è¡Œçš„ç¨‹åºï¼Œè€Œå¯¹äºå®‰å“ç³»ç»Ÿï¼Œä¸€èˆ¬ä¸€ä¸ªAndroidåº”ç”¨ç¨‹åºå°±æ˜¯ä¸€ä¸ªè¿›ç¨‹ï¼Œå…¶ä¸­åŒ…å«å¤šä¸ªçº¿ç¨‹ååŒå·¥ä½œã€‚ çº¿ç¨‹ï¼ˆThreadï¼‰æ˜¯ä¸€ç§è½»é‡çº§çš„å­è¿›ç¨‹ï¼Œæ˜¯ä¸€ä¸ªåŸºæœ¬çš„CPUæ‰§è¡Œå•å…ƒ &amp; ç¨‹åºæ‰§è¡Œæµçš„æœ€å°å•å…ƒï¼Œä¹Ÿæ˜¯ç‹¬ç«‹è¿è¡Œå’Œç‹¬ç«‹è°ƒåº¦çš„åŸºæœ¬å•ä½ã€‚åœ¨Androidçš„ç¯å¢ƒé‡Œï¼Œä¸€ä¸ªçº¿ç¨‹å¯ä»¥ç†è§£ä¸ºä¸€ç¾¤ä»»åŠ¡çš„æœ‰åºé›†åˆï¼Œæ‰€æœ‰çº¿ç¨‹å…±äº«è¿›ç¨‹æ‰€æ‹¥æœ‰çš„ç³»ç»Ÿèµ„æºå’Œå­˜å‚¨èµ„æºï¼Œå„çº¿ç¨‹ä¹‹é—´é€šä¿¡å¿«é€Ÿé«˜æ•ˆã€‚å½“è¿™ä¸ªçº¿ç¨‹çš„ä»»åŠ¡å…¨éƒ¨æ‰§è¡Œç»“æŸæ—¶ï¼Œçº¿ç¨‹å°±ä¼šè¢«ç»ˆæ­¢ã€‚ Android Multi-threadAndroidç³»ç»Ÿä¸­çš„çº¿ç¨‹åˆ†ä¸ºä¸¤ç±»ï¼šä¸»çº¿ç¨‹ï¼ˆMain Threadï¼‰å’Œå…¶ä»–å­çº¿ç¨‹ã€‚ ä¸»çº¿ç¨‹ä¹Ÿå«UIçº¿ç¨‹ï¼Œåœ¨Android APPå¯åŠ¨æ—¶ä¼šè‡ªåŠ¨ç”Ÿæˆï¼Œä¸»è¦è´Ÿè´£å¤„ç†Androidå››å¤§ç»„ä»¶ï¼ˆå¯ä»¥çœ‹è¿™ç¯‡ä¸­å…³äºå››å¤§ç»„ä»¶çš„ä»‹ç»ï¼‰ä¸ç”¨æˆ·è¿›è¡Œäº¤äº’çš„äº‹ä»¶å“åº”ä¸é€»è¾‘ï¼Œæ‰€ä»¥ä¹Ÿå«ä¸»çº¿ç¨‹ä¹Ÿå«UIçº¿ç¨‹ã€‚è¦æ³¨æ„çš„æ˜¯ï¼Œå› ä¸ºç”¨æˆ·éšæ—¶ä¼šä¸ç•Œé¢å‘ç”Ÿäº¤äº’ï¼Œå› æ­¤ä¸»çº¿ç¨‹ä»»ä½•æ—¶å€™éƒ½å¿…é¡»ä¿æŒå¾ˆé«˜çš„å“åº”é€Ÿåº¦ï¼Œæ‰€ä»¥ä¸»çº¿ç¨‹ä¸å…è®¸è¿›è¡Œè€—æ—¶æ“ä½œï¼Œå¦åˆ™ä¼šå‡ºç°ANRï¼ˆApplicationNotRespondingï¼‰å¼‚å¸¸ã€‚ å­çº¿ç¨‹å°±æ˜¯APPçš„å·¥ä½œçº¿ç¨‹ï¼Œå­çº¿ç¨‹éƒ½æ˜¯APPè¿è¡Œè¿‡ç¨‹ä¸­æ‰‹åŠ¨åˆ›å»ºçš„çº¿ç¨‹ï¼Œå¯ä»¥åœ¨å…¶ä¸­å¤„ç†ä¸€äº›è€—æ—¶çš„æ“ä½œä¾‹å¦‚ç½‘ç»œè¯·æ±‚ã€I/Oæ“ä½œç­‰ã€‚å¯ä»¥é€šè¿‡ä½¿ç”¨RxJavaç­‰å‡½æ•°åº“æ¥åˆ›å»ºç”¨äºä¸åŒæ“ä½œçš„ç‰¹å®šå­çº¿ç¨‹ã€‚ åœ¨Androidå®˜æ–¹å£°æ˜ä¸­ï¼Œå¯¹äºå¤šçº¿ç¨‹ç¼–ç¨‹æ—¶æœ‰ä¸¤å¤§åŸåˆ™ï¼š ä¸è¦é˜»å¡UIçº¿ç¨‹ï¼ˆå³ä¸»çº¿ç¨‹ï¼‰ï¼šä¸»çº¿ç¨‹è¢«é˜»å¡è¶…è¿‡5såˆ™ä¼šå‡ºç°ANRé”™è¯¯ï¼› ä¸è¦åœ¨UIçº¿ç¨‹ä¹‹å¤–æ›´æ–°UIç»„ä»¶ã€‚ é‚£ä¹ˆç°åœ¨æˆ‘ä»¬æ¥çœ‹çœ‹å¦‚ä½•åœ¨ä»£ç ä¸­åˆ›å»ºä¸€ä¸ªå­çº¿ç¨‹å§ã€‚ä»£ç å¦‚ä¸‹ï¼š 123456789package com.example.yunzeli.testapplicationpublic class MyWorkingThread extends Thread { private boolean isRunning; @Override public void run() { // å¼€å§‹çº¿ç¨‹çš„å·¥ä½œ }} å¯ä»¥çœ‹åˆ°ï¼Œæˆ‘ä»¬çœŸæ­£éœ€è¦åšçš„ï¼Œå°±æ˜¯ç»§æ‰¿Threadè¿™ä¸ªç±»ï¼Œå¹¶å®ç°run()æ–¹æ³•ã€‚å°†æˆ‘ä»¬éœ€è¦åšçš„å·¥ä½œåœ¨run()é‡Œå®Œæˆå³å¯ï¼Œè¿™ä¸ªæ–¹æ³•ç®€å•æ–¹ä¾¿ï¼Œä½†æ˜¯å´æœ‰ä¸€ä¸ªé—®é¢˜ï¼šä¸Šé¢æˆ‘ä»¬è¯´è¿‡ï¼Œå½“è¿™ä¸ªçº¿ç¨‹çš„ä»»åŠ¡å…¨éƒ¨æ‰§è¡Œç»“æŸæ—¶ï¼Œçº¿ç¨‹å°±ä¼šè¢«ç»ˆæ­¢ï¼Œé‚£ä¹ˆå¦‚æœæˆ‘ä»¬éœ€è¦åœ¨å·¥ä½œçº¿ç¨‹å®Œæˆå½“å‰å·¥ä½œåä¸è¢«ä¸­æ­¢ï¼Œè€Œæ˜¯ç»§ç»­ç­‰å¾…æ–°çš„ä»»åŠ¡åˆ°æ¥å‘¢ï¼Ÿé‚£ä¹ˆå°±å¯ä»¥è¿™æ ·ï¼š 123456789101112131415package com.example.yunzeli.testapplicationpublic class MyWorkingThread extends Thread { private boolean isRunning; @Override public void run() { isRunning = ture; while (isRunning) { // å¼€å§‹çº¿ç¨‹çš„å·¥ä½œ // çº¿ç¨‹çš„å·¥ä½œå®Œæˆå isRunning = false; } }} ä¸Šé¢çš„ä»£ç ä¸­ï¼Œæˆ‘ä»¬é€šè¿‡è®¾ç½®ä¸€ä¸ªisRunningçš„flagï¼Œå¯ä»¥ç”¨å¾ªç¯çš„æ–¹å¼æ¥blockä½è¿™ä¸ªçº¿ç¨‹ï¼Œç„¶åç­‰å¾…æ–°çš„ä»»åŠ¡åˆ°æ¥ã€‚å¾ˆå¥½ï¼Œç°åœ¨æˆ‘ä»¬æœ‰äº†ä¸€ä¸ªç‹¬ç«‹è¿è¡Œçš„ï¼Œéšæ—¶å¯ä»¥ä½¿ç”¨çš„å·¥ä½œçº¿ç¨‹ã€‚ä½†äº‹å®ä¸Šï¼ŒJavaä»£ç åº“é‡Œç»™æˆ‘ä»¬æä¾›äº†ä¸€ä¸ªæ›´åŠ ç®€å•æ¸…æ™°ï¼Œå¹¶ä¸”å¯é çš„ç±»ï¼Œè¿™å°±æ˜¯Looperã€‚ Looperä»ä¸Šé¢çš„å†…å®¹æˆ‘ä»¬çŸ¥é“ï¼Œè¦æƒ³å°†ä¸€ä¸ªçº¿ç¨‹blockä½ï¼Œæˆ‘ä»¬éœ€è¦ç”¨loopingå°†å…¶ä¸æ–­å¾ªç¯å¹¶ç­‰å¾…æ–°çš„ä»»åŠ¡ã€‚åœ¨Androidçš„å¼€å‘åŒ…é‡Œï¼Œå°±æœ‰ä¸€ä¸ªè®¾è®¡å¥½çš„Looperç±»ä¾›æˆ‘ä»¬ä½¿ç”¨ã€‚è¿™ä¸ªLooperä¸€ç›´åœ¨ä¸åœçš„å¾ªç¯å¹¶ç›‘å¬æ–°æ¥çš„taskï¼Œæ¯ä¸ªLooperéƒ½æœ‰ä¸€ä¸ªmessageQueueç”¨æ¥å­˜æ”¾åˆ†é…çš„taskï¼Œä¹Ÿå«åšMessageã€‚Looperçš„ä½¿ç”¨æœ‰ä¸¤ä¸ªåŸºæœ¬åŸåˆ™ï¼š æ¯ä¸€ä¸ªThreadæœ‰ä¸”åªèƒ½æœ‰ä¸€ä¸ªLooperï¼› å½“æƒ³è®©æŸä¸€ä¸ªThreadæ‰§è¡ŒæŸä¸ªä»»åŠ¡æ—¶ï¼Œå°±å°†messageä¼ é€ç»™å¯¹åº”Looperçš„messageQueueã€‚ Looperåœ¨threadçš„å…·ä½“ä½¿ç”¨æ–¹æ³•å¦‚ä¸‹ï¼š 12345678910111213141516package com.example.yunzeli.testapplicationimport android.os.Looperpublic class MyLooperThread extends Thread { @Override public void run() { // prepare the loop Looper.prepare(); // start looping Looper.loop(); // do your staff here... }} Looper.prepare()ï¼šæ£€æŸ¥å½“å‰è¿™ä¸ªthreadæ˜¯å¦å·²ç»åˆ†é…å¥½looperï¼Œå¦‚æœæ²¡æœ‰ï¼Œåˆ™æ–°å»ºä¸€ä¸ªlooperæ¥ç›‘å¬è¿™ä¸ªthreadï¼› Looper.loop()ï¼šlooperå¼€å§‹ç›‘å¬å½“å‰çº¿ç¨‹ï¼Œå¼€å§‹å¤„ç†æ”¶åˆ°çš„messageï¼› ç®€è€Œè¨€ä¹‹ï¼ŒLooperçš„ä½œç”¨å°±æ˜¯ä¸€ç›´looping and keep thread aliveã€‚å€¼å¾—æ³¨æ„çš„æ˜¯ï¼ŒMain Threadä¹Ÿå°±æ˜¯UIçº¿ç¨‹ï¼Œæ˜¯å·²ç»åˆå§‹åŒ–äº†MainLooperçš„ã€‚æ‰€ä»¥ä¸éœ€è¦å¯¹äºMain Threadè¿›è¡Œä»»ä½•çš„æ“ä½œï¼ŒAndroidç³»ç»Ÿå·²ç»å¸®æˆ‘ä»¬éƒ½å¤„ç†å¥½äº†ã€‚ MessageQueue &amp; Handlerè¯´å®Œäº†Looperï¼Œç°åœ¨æˆ‘ä»¬æ¥è¯´è¯´Looperé‡Œé¢çš„ä¸€ä¸ªé‡è¦æ¦‚å¿µï¼šMessageQueueã€‚å½“æˆ‘ä»¬æƒ³å‘ä¸€ä¸ªthreadé‡Œæ´¾é€ä¸€ä¸ªæ–°çš„taskæ—¶ï¼ŒJavaè§„å®šäº†æˆ‘ä»¬åªèƒ½æ´¾é€å¦‚ä¸‹ä¸¤ç§ç±»å‹ï¼šMessageå’ŒRunnableã€‚é‚£ä¹ˆï¼Œæˆ‘ä»¬å¦‚ä½•å°†è¿™ä¸¤ç§ç±»å‹çš„å®ä¾‹æ´¾é€åˆ°ç›®æ ‡çº¿ç¨‹çš„messageQueueé‡Œå‘¢ï¼Ÿè¿™é‡Œå°±ç”¨åˆ°äº†å¦ä¸€ä¸ªé‡è¦æ¦‚å¿µï¼šHandlerã€‚Handlerçš„åŠŸèƒ½ç›¸å½“äºä¸€ä¸ªè£…é…å™¨ï¼Œå®ƒå¯ä»¥å°†ä»»æ„ç»§æ‰¿äº†Messageæˆ–è€…Runnableç±»çš„å®ä¾‹æ”¾å…¥å…¶ç›‘å¬çš„Looperçš„messageQueueé‡Œï¼Œä¾‹å¦‚ï¼š 12345678910111213141516171819202122232425262728293031323334353637383940public class MyLooperThread extends Thread { private static final int MSG_1 = 1; private static final int MSG_2 = 2; @Override public void run() { // prepare the loop Looper.prepare(); // start looping Looper.loop(); // send message here Handler handler = new MyHandler(); handler.obtainMessage(MSG_1).sendToTarget(); handler.post(new Runnable() { @Override public void run() { // do something here... } }); } class MyHandler extends Handler { @Override public void handleMessage(Message message) { // switch your message type here switch(message.what) { case MSG_1: // do something here... break; case MSG_2ï¼š // do something here... break; default: } } }} ç”±ä¸Šé¢ä¾‹å­å¯è§ï¼ŒHandleré€šè¿‡obtainMessage(Message msg)çš„æ–¹æ³•æ¥ä¼ é€messageå®ä¾‹ï¼Œç”¨post(Runnable runable)çš„æ–¹æ³•æ¥ä¼ é€Runnableå®ä¾‹ã€‚é‚£ä¹ˆï¼ŒHandlerå¦‚ä½•çŸ¥é“æ‰€è¦ä¼ é€çš„ç›®æ ‡threadå‘¢ï¼ŸAndroidå®˜æ–¹æ–‡æ¡£é‡Œå†™çš„å¾ˆæ¸…æ¥šï¼ŒHandleræœ‰ä¸¤ä¸ªé»˜è®¤çš„æ„é€ å™¨ï¼ˆconstructorï¼‰ï¼Œå¦‚æœä½¿ç”¨new Handler()çš„è¯ï¼Œåˆ™å½“å‰çº¿ç¨‹å°±ä¼šæˆä¸ºåˆ›å»ºçš„Handlerçš„ç›®æ ‡çº¿ç¨‹ï¼›è€Œå¦‚æœä½¿ç”¨new Handler(Looper looper)çš„è¯ï¼Œåˆ™ä¼ å…¥çš„looperå¯¹åº”çš„çº¿ç¨‹å°±ä¼šä½œä¸ºåˆ›å»ºçš„Handlerçš„ç›®æ ‡çº¿ç¨‹ã€‚æ€»ç»“ä¸€ä¸‹ï¼ŒHanlderçš„ä½œç”¨ä¸»è¦å°±æ˜¯ä¸¤ç‚¹ï¼š ä»ä»»æ„threadä¸­å°†messageæˆ–è€…runnableä¼ å…¥å…¶å¯¹åº”çš„looperçš„message queueä¸­ï¼› è·å–å…¶å¯¹åº”looperçš„message queueä¸­çš„ä¸‹ä¸€ä¸ªtaskï¼ˆmessageæˆ–runnableï¼‰å¹¶æ‰§è¡Œå¯¹åº”çš„æ“ä½œã€‚ éœ€è¦å¼ºè°ƒçš„ä¸€ç‚¹æ˜¯ï¼šè™½ç„¶ä¸€ä¸ªthreadåªèƒ½æœ‰ä¸€ä¸ªå¯¹åº”çš„looperï¼Œä½†æ˜¯ä¸€ä¸ªlooperå´å¯ä»¥åŒæ—¶è¢«å¤šä¸ªHandleræ‰€å¼•ç”¨ï¼ˆå…è®¸å°†åŒä¸€ä¸ªLooperä¼ å…¥å¤šä¸ªHandlerçš„æ„é€ å™¨ï¼‰ä»¥ä¾¿æŒ‡å®šç»™åŒä¸€threadçš„ä¸åŒhandleråˆ†åˆ«å¤„ç†ä¸åŒçš„messageæˆ–è€…runnableã€‚è¿™æ ·çš„è®¾è®¡ä¹Ÿæ–¹ä¾¿äº†æˆ‘ä»¬å¯¹äºå¤šä¸ªtaskçš„å¤„ç†ã€‚ Message &amp; Runnableæœ€åå…³äºMessageå’ŒRunnableå†ç®€å•ä»‹ç»ä¸€ä¸‹ï¼š å½“æˆ‘ä»¬å¸Œæœ›åœ¨ä¸€ä¸ªthreadé‡Œæ‰§è¡Œä¸€æ®µä»£ç ï¼ˆtaskï¼‰æ—¶ï¼ŒAndroid OS è§„å®šäº†è¿™ä¸¤ç§ç±»å‹ä½œä¸ºä¼ å…¥çš„å‚æ•°ã€‚Messageçš„ä½¿ç”¨æ–¹å¼åœ¨äºï¼šæˆ‘ä»¬é¢„å…ˆåœ¨Handleré‡Œå®šä¹‰å¥½äº†å¦‚ä½•å¤„ç†è¿™ä¸ªMESSAGE_TYPEçš„é€»è¾‘ï¼Œç„¶åå°†å¯¹åº”çš„MESSAGE_TYPEä¼ å…¥ã€‚ä¸ªäººç†è§£æ¯”è¾ƒåƒæ˜¯pre-defineäº†ä¸€ä¸ªå¤„ç†é€»è¾‘ï¼Œç„¶ååªéœ€è¦ä¼ å…¥å¯¹åº”messageå°±å¯ä»¥triggerè¿™ä¸ªtaskï¼›è€ŒRunnableæ˜¯ä¸€ä¸ªInterfaceï¼Œå½“æˆ‘ä»¬ä¼ å…¥æ—¶ï¼Œåˆ™éœ€è¦é‡å†™å®ƒçš„run()æ–¹æ³•å¹¶å°†æˆ‘ä»¬æƒ³æ‰§è¡Œçš„ä»£ç é€»è¾‘å†™åœ¨é‡Œé¢ã€‚ å…³äºè¿™ä¸¤ç§æ–¹å¼çš„åŒºåˆ«ï¼Œä¸ªäººè®¤ä¸ºä¸»è¦å–å†³äºè¿™æ®µé€»è¾‘æ˜¯å¦éœ€è¦ä¼ å…¥åŠ¨æ€å˜åŒ–çš„å‚æ•°ï¼šæ¯”å¦‚ï¼Œå¦‚æœæ˜¯æ‰§è¡Œä¾‹å¦‚æ˜¾ç¤ºä¸€ä¸ªæ–‡æœ¬æ¡†å¹¶é«˜äº®è¿™ç§å›ºå®šçš„ï¼Œé™æ€çš„é€»è¾‘ï¼Œé‚£ä¹ˆmessageçš„æ–¹æ³•æ˜¯æ¯”è¾ƒå¥½çš„é€‰æ‹©ã€‚ä½†å¦‚æœæ‰§è¡Œæ ¹æ®ç”¨æˆ·è¾“å…¥å€¼æ¥æ˜¾ç¤ºå­—ä½“å¤§å°è¿™ç§éœ€è¦å‚æ•°çš„é€»è¾‘ï¼Œåˆ™runnableçš„æ–¹æ³•æˆ–æ›´å¥½äº›ã€‚ æ€»ç»“è¿™ä¸€ç¯‡åªæ˜¯å¯¹äºAndroidå¤šçº¿ç¨‹ä¸€ä¸ªéå¸¸ç®€å•çš„ä»‹ç»ã€‚å¸Œæœ›é€šè¿‡æˆ‘çš„ç®€å•ä»‹ç»èƒ½è®©è¯»è€…å¯¹äºå¤šçº¿ç¨‹æœ‰ä¸€ä¸ªç®€å•ç›´è§‚çš„è®¤è¯†ã€‚Androidå¤šçº¿ç¨‹è¿˜æœ‰ç€è®¸å¤šè®¸å¤šå¤æ‚çš„å†…å®¹ï¼Œä»¥åä¼šåœ¨ç¢°åˆ°å¹¶è§£å†³ä¹‹åï¼Œä¸€ä¸€åœ¨è¿™é‡Œä»‹ç»ç»™å¤§å®¶çš„ã€‚è®©æˆ‘ä»¬å…±åŒå­¦ä¹ ï¼Œå…±åŒè¿›æ­¥ï¼Œè°¢è°¢ï¼ å‚è€ƒæ–‡ç« ï¼šUnderstanding Android Core: Looper, Handler, and HandlerThread A journey on the Android Main Thread â€” PSVM Android Handler Internals Androidå¤šçº¿ç¨‹ Multithreading Interview Question","link":"/2020/06/22/AndroidBasic3/"},{"title":"Androidå¼€å‘ç¬”è®°ä¹‹åŸºç¡€ç¯‡ï¼ˆå››ï¼‰","text":"åœ¨Androidå¼€å‘çš„å¤§éƒ¨åˆ†åœºæ™¯é‡Œï¼Œæˆ‘ä»¬éœ€è¦æ„å»ºå„ç§å„æ ·çš„UIç•Œé¢ç”¨äºä¸ç”¨æˆ·è¿›è¡Œäº¤äº’ã€‚å¾ˆå¤šUIè®¾è®¡çœ‹èµ·æ¥å¾ˆç®€å•ä¹Ÿå¾ˆæ¸…æ™°ï¼Œä½†ä¸€æ—¦å¼€å§‹ä¸Šæ‰‹è®¾è®¡ï¼Œå°±ä¼šå‘ç°ï¼šè®¾è®¡å¸ˆè½»æ¾ç”»å‡ºçš„å„ä¸ªUIç»„ä»¶ï¼Œå®ƒä»¬çš„æ’åˆ—ï¼Œé—´éš”ï¼Œå¯¹é½ï¼Œå¤§å°ï¼Œå…¶å®æ²¡æœ‰é‚£ä¹ˆå®¹æ˜“æ‘†æ”¾æ­£ç¡®ã€‚å†åŠ ä¸Šå¯¹äºå®‰å“ç³»ç»Ÿçš„æ‰‹æœºï¼Œå±å¹•å¤§å°å°ºå¯¸æ›´æ˜¯å¤šç§å¤šæ ·ã€‚è¿™æ˜¯æˆ‘ä»¬å°±éœ€è¦ç”¨åˆ°é¡µé¢å¸ƒå±€ï¼ˆUI Layoutï¼‰è¿™ä¸ªå·¥å…·ã€‚é‚£ä¹ˆä»Šå¤©å°±æ¥çœ‹çœ‹Androidä¸­å…³äºé¡µé¢å¸ƒå±€çš„ä¸€äº›æ¦‚å¿µå’ŒçŸ¥è¯†ã€‚ å››ç§å¸¸è§çš„Android Layoutå¸ƒå±€åœ¨Androidå¼€å‘ç¯å¢ƒä¸­ï¼Œä¸€ä¸ªUI layoutå¸ƒå±€é¡µé¢ä»¥xmlæ–‡ä»¶çš„æ ¼å¼å­˜äºï¼šä½ çš„å·¥ç¨‹è·¯å¾„/main/res/layouté‡Œé¢ã€‚xmlæ–‡ä»¶çš„å…·ä½“æ ¼å¼è¿™é‡Œä¸å†èµ˜è¿°ï¼Œä½†æ˜¯è¦å…·ä½“å¯¹äºä¸åŒç§ç±»çš„Layoutç¨å¾®è§£é‡Šä¸€ä¸‹ï¼š LinearLayoutç¬¬ä¸€ç§æ˜¯LinearLayoutï¼Œè¿™ç§å¸ƒå±€ä¸€èˆ¬æ¥è¯´æ˜¯æœ€ç®€å•ï¼Œç›´æ¥ï¼Œå¿«é€Ÿçš„ä¸€ç§ï¼Œå½“æ–°å»ºä¸€ä¸ªlayoutå¸ƒå±€æ–‡ä»¶æ—¶ï¼ŒAndroid Studioé»˜è®¤çš„å¸ƒå±€æ–‡ä»¶å³ä¸ºè¿™ç§LinearLayoutã€‚é¡¾åæ€ä¹‰ï¼Œè¿™ç§å¸ƒå±€æœ€é€‚ç”¨äºçº¿æ€§çš„UIå‘ˆç°æ–¹å¼ï¼Œæ¯”å¦‚å¦‚ä¸‹çš„å¸ƒå±€ï¼š å¯¹äºè¿™ç§åªéœ€è¦æ¨ªå‘(Horizontal)æˆ–çºµå‘(Vertical)æ’åˆ—çš„å¸ƒå±€ï¼ŒLinearLayoutå¯ä»¥è¯´æ˜¯æœ€é€‚åˆä¸è¿‡çš„é€‰æ‹©äº†ï¼Œå®ƒå‡å°‘äº†å¾ˆå¤šå¤„ç†å„éƒ¨ä»¶ä¹‹å‰ä½ç½®å…³ç³»çš„å‚æ•°å£°æ˜ï¼Œåªéœ€æŒ‰éœ€è°ƒæ•´å½“å‰éƒ¨ä»¶å’Œä¸Šä¸€ä¸ªéƒ¨ä»¶ä¹‹é—´çš„ä½ç½®å…³ç³»ï¼Œç›´åˆ°å®Œæˆå¸ƒå±€å³å¯ã€‚ç®€å•æ¥è¯´ï¼ŒLinearLayoutå°±åƒå †ç§¯æœ¨ï¼Œä½ åªéœ€è¦æ²¿æŸä¸€ä¸ªæ–¹å‘ä¸æ–­å †ç Œä½ çš„subviewï¼Œå¹¶ç»™æ¯ä¸ªsubviewè§„å®šå¥½è¾¹è·ç­‰å‚æ•°å³å¯ã€‚ä½†æ˜¯éœ€è¦æ³¨æ„çš„æ˜¯ï¼šè¿™ç§Layoutç±»å‹ä¸å…è®¸åœ¨åŒä¸€å±‚å†…å †å¤šä¸ªsubviewã€‚å¦‚æœéœ€è¦çš„è¯ï¼Œè¦ä½¿ç”¨ä¸‹é¢çš„RelativeLayoutã€‚ RelativeLayoutç¬¬äºŒç§æ˜¯RelativeLayoutï¼Œè¿™ç§å¸ƒå±€çš„ç‰¹ç‚¹åœ¨äºï¼šå„éƒ¨ä»¶ä¹‹é—´çš„ä½ç½®å…³ç³»ä¸»è¦é å®šä¹‰ä¸å…¶åŒå¸ƒå±€çš„å…¶ä»–éƒ¨ä»¶(Sibling)çš„ä½ç½®å…³ç³»æ¥å†³å®šã€‚æ¯”å¦‚æˆ‘ä»¬åœ¨å®šä¹‰ä¸‹é¢è¿™æ ·ä¸€ä¸ªé¡µé¢ï¼š ç±»ä¼¼å¦‚ä¸Šçš„ç•Œé¢ä¸€èˆ¬ä¼šå‡ºç°åœ¨åˆ—è¡¨ï¼ˆListï¼‰ä¸­ï¼Œå¯¹äºè¿™ç§å¸ƒå±€æˆ‘ä»¬å¸Œæœ›view 1å’Œview 3çš„å·¦è¾¹ç•Œå¯¹é½ï¼Œè€Œview 2å’Œview 3çš„å³è¾¹ç•Œå¯¹é½ã€‚è‡³äºæ•´ä½“å¸ƒå±€çš„é«˜åº¦æˆ‘ä»¬å¹¶ä¸æ˜¯ååˆ†ä»‹æ„ï¼ˆä¸€èˆ¬è¿™ç§å¸ƒå±€ä¼šé‡‡ç”¨ä¸Šæ»‘æ˜¾ç¤ºæ›´å¤šçš„RecyclerListViewï¼Œè¿™ä¸ªä»¥åä¼šç»§ç»­è®²åˆ°ï¼‰ã€‚æ‰€ä»¥æ­¤æ—¶RelativeLayoutå°±å¯ä»¥é€šè¿‡å£°æ˜ android:layout_toLeftOf ä»¥åŠ android:layout_toRightOf æ¥é™åˆ¶ç»„ä»¶é—´ä½ç½®å…³ç³»ï¼Œä»è€Œè¾¾åˆ°æˆ‘ä»¬æƒ³è¦çš„æ•ˆæœã€‚ RelativeLayouté¡¾åæ€ä¹‰ï¼Œåœ¨å®šä¹‰åŒä¸€ä¸ªsubviewå†…çš„ä¸åŒç»„ä»¶é—´ç›¸å¯¹ä½ç½®å…³ç³»æ—¶éå¸¸æœ‰æ•ˆã€‚ä½†åœ¨ä½¿ç”¨æ—¶éœ€è¦å¤„ç†å¥½ç›¸å¯¹ä½ç½®å…³ç³»é—´çš„å†²çªï¼Œä¸€èˆ¬éœ€è¦èŠ±è´¹ä¸€äº›æ—¶é—´ç”¨äºè°ƒæ•´ç›¸å¯¹çš„ä½ç½®å…³ç³»ã€‚è¿™ç§å¸ƒå±€çš„ä½¿ç”¨æ–¹æ³•åœ¨é¢å¯¹ç¨å¾®å¤æ‚ä¸€ç‚¹çš„UIç•Œé¢æ—¶ç›¸æ¯”LinearLayoutæ›´çµæ´»ï¼Œæ›´é«˜æ•ˆã€‚ FrameLayoutç¬¬ä¸‰ç§æ˜¯FrameLayoutï¼Œè¿™ç§å¸ƒå±€ä¸€èˆ¬åº”ç”¨äºå¤šå±‚åµŒå¥—çš„è§†å›¾å¸ƒå±€ã€‚å…¶å®ä¸Šé¢ä»‹ç»çš„ä¸¤ç§è§†å›¾ä¹Ÿå¯ä»¥ç”¨äºå±‚å ï¼ˆOverlapï¼‰æ•ˆæœï¼Œå¯¹äºåˆ°åº•ä½¿ç”¨å“ªç§å¸ƒå±€åœ¨ä¸€äº›ç‰¹å®šçš„åº”ç”¨åœºæ™¯ä¸‹ä¹Ÿä¼šæœ‰æ‰€ä¸åŒã€‚ä½†æˆ‘çš„ç†è§£æ˜¯: FrameLayoutå¯¹äºå±‚å åœºæ™¯ä¼šæœ‰æ›´å¥½çš„è¡¨ç°å’Œå¤„ç†æ–¹å¼ï¼Œåœ¨FrameLayoutä¸­ä¹Ÿä¼šæœ‰æ›´å¤šä¸åŒçš„å£°æ˜æ–¹å¼æ¥è¿›è¡Œå¸ƒå±€ï¼Œè€Œä¸€èˆ¬çš„RelativeLayoutæ¥å®šä¹‰å±‚å çš„ä½ç½®å…³ç³»ä¼šå˜å¾—å¾ˆå¤æ‚ã€‚æ‰€ä»¥ä¸å¦¨åˆ†ç¦»å‡ºæ‰€è®¾è®¡çš„é¡µé¢ä¸­çš„å±‚å éƒ¨åˆ†ï¼Œæ¥ç”¨FrameLayoutå®Œæˆï¼Œè€Œå…¶ä»–çš„éƒ¨åˆ†åˆ™é‡‡ç”¨RelativeLayoutã€‚ å°†ä½ çš„é¡µé¢è¿›è¡Œåˆ†ç¦»ï¼Œä½¿ç”¨ä¸åŒçš„UIå¸ƒå±€æ¡†æ¶æ¥å®šä¹‰ä¸åŒçš„å­é¡µé¢ï¼Œä¹Ÿæ˜¯UIè®¾è®¡å¸ƒå±€ä¸­ååˆ†é‡è¦çš„ä¸€æ­¥ã€‚å†³å®šå¥½ä½¿ç”¨çš„æ¡†æ¶ä¼šè®©ä½ çš„UIè®¾è®¡å˜å¾—ç®€å•æ˜“æ‡‚ï¼Œå¹¶ä¸”æ˜“äºæ”¹åŠ¨ã€‚ç›¸ä¿¡å¾ˆå¤šäººéƒ½é‡åˆ°è¿‡æ”¹UIçš„æ—¶å€™ä¸€æ”¹å°±è¦åŠ¨åˆ°æ‰€æœ‰çš„æ¡†æ¶è¿™ç§ååˆ†ç—›è‹¦çš„äº‹æƒ…ã€‚ ConstraintLayoutæœ€åä¸€ä¸ªï¼Œä¹Ÿæ˜¯æˆ‘è®¤ä¸ºæœ€ä¸ºé‡è¦ï¼ŒåŠŸèƒ½æœ€ä¸ºå¼ºå¤§çš„ä¸€ä¸ªï¼Œå°±æ˜¯ConstraintLayoutã€‚ConstraintLayoutå’Œå…¶å®ƒå¸ƒå±€æ–¹å¼æœ€æ˜æ˜¾çš„åŒºåˆ«åœ¨äºï¼Œå®ƒéœ€è¦å¯¹äºæ¯ä¸€ä¸ªç»„ä»¶å£°æ˜å¸ƒå±€çš„constraintï¼Œè¿™äº›constraintsä¼šæŒ‰ç…§ä¼˜å…ˆçº§è¢«æ‰§è¡Œå¹¶å¸ƒå±€ã€‚ä½†æ˜¯å¿…é¡»å£°æ˜å¾—æ¯”è¾ƒå®Œå¤‡ï¼Œæ‰èƒ½è·å¾—æƒ³è¦å‘ˆç°çš„æ•ˆæœï¼ˆä¹Ÿæ­£æ˜¯å› ä¸ºéœ€è¦å£°æ˜çš„constraintæ¯”è¾ƒå¤šï¼Œæ‰€ä»¥ConstraintLayoutå¯ä»¥æ¯”è¾ƒå¥½çš„å¤§éƒ¨åˆ†åœ¨Appä¸­æˆ‘ä»¬æƒ³è¦å‘ˆç°çš„å¸ƒå±€æ•ˆæœï¼‰ã€‚ åœ¨ConstraintLayoutä¸­ï¼Œå½“å®šä¹‰ä¸€ä¸ªç»„ä»¶çš„æ—¶å€™ï¼Œå¯ä»¥é€šè¿‡å£°æ˜app:layout_constraintXX_toXXOfæ¥å®šä¹‰å…¶ç›¸å¯¹äºå¦ä¸€ä¸ªç»„å»ºçš„ä½ç½®ï¼ŒåŒæ—¶ä¹Ÿå¯ä»¥é€šè¿‡å£°æ˜android:layout_marginXXæ¥å®šä¹‰å…¶ç›¸å¯¹è¾¹è·ï¼Œå…¶ç”¨æ³•æ˜¯ååˆ†çµæ´»çš„ã€‚ConstranitLayoutåœ¨è¿›è¡Œè¯¸å¦‚è¾¹ç¼˜å¯¹é½ï¼Œå±…ä¸­ï¼Œå„å­è§†å›¾(subview)å¹³å‡åˆ†é…ç­‰åŠŸèƒ½æ—¶ååˆ†æœ‰æ•ˆï¼Œç›®å‰å¯ä»¥è¯´æ˜¯æˆ‘æœ€å–œæ¬¢ä½¿ç”¨ï¼Œä¹Ÿæœ€ç»å¸¸ä½¿ç”¨çš„ä¸€ç§å¸ƒå±€æ¡†æ¶ã€‚","link":"/2020/07/02/AndroidBasic4/"},{"title":"Clean Code Summary","text":"Recently I read this book written by Robert C. Martin also known as â€œUncle Bobâ€. In this book it talked about general coding principles to make your code â€œcleanâ€œ and easy to understand. And here is some useful tips and summaries I extracted. Chapter 2 Meangingful Names Use Intention-Revealing Names: avoid nonsense naming Avoid Disinformation: using FULLNAME, avoid abbrevation accountList &gt; accounts &gt; List Make Meaningful Distinctions: ProductInfo and ProductData, Customer and CustomerObject has no difference at all! Use Pronounceable, Searchable Names: the length of a name should correspond to the size of its scope Interface and Implementtations: avoid passing IShapeFactory as interface, using ShapeFactoryImpl in implementation Class Name: Avoid using Manager, Processor, Info, Dataas class name, using noun or noun phrase word One Word Per Concept: Donâ€™t use retrieve, fetchr, get all at same time! Itâ€™s horrible! Chapter 3 Functions Small!: Funtions should be very small Avoid nested structures and each block should be one line Function should do one thing canâ€™t extract another function from it witha nmae that is not merely a restatement of its implementation Switch statements: using polymorphism with abstract factory pattern Common Monadic Forms Ask question about argument like boolean isFileExist(File file) Operating on argument, transforming it into something and return like InputStream fileOpen(File file) Interpret function call as event and use argument to alter state of system without output argument like void passwordAttemptFailedNtimes(int attempts) Try to avoid any other form besides those three above Dyadic Forms Sometime reasonable if itâ€™s a natural cohesion or ordering like new Point(0, 0) or assertEquals(expected, actual) It itnâ€™s evil, but it has cost and there always a way to at least convert it to Monadic, just depends on whether it worth or not Argument Objects Using wrapper to wrap into a class of their own see these two following declarations: 12Circle makeCircle(double x, double y, double radius);Circle makeCircle(Point center, double radius); Output Arguments Try not using output argument, if must change state of something, make it change inside itâ€™s own Prefer Exception to Returning Error Codes Error code always force caller to deal with it immediately using using try-catch block, the code to deal with succeed or error will be separated extract try and catch block to its own method should be more clear Chapter 4 Comments Comment should be no need at all Itâ€™s always the compensate for failure to express in code Programmer always forget to maintain, which makes them misleading Save the energy to write better and clearer code Chapter 6 Objects and Data Structures Data Abstraction Expose abstract interfaces to allow user manipulate data without knowing its implementation Consider serious which data should be exposed Data/Object Anti-Symmetry Objects: Hide data behind abstractions and expose funtions that operate their data Data: Expose data and have no meaningful functions Procedural code: Easy to add new functions, hard to change data structure Object Oriented code Easy to add new classes, hard to add new functions Need to use both of them properly to make clean code, but not in one class (hybird is the worst!) Chapter 7 Error Handling Use Exceptions Rather Than Return Codes Error code needs to be returned every single case, make the code very complicated and cultter caller Separate detection logic with handle logic Define Exception Classes in Terms of Callerâ€™s Needs Wrapping third-party API is a best practice, easy testing, easy migration and less dependencies Define your own exception type inside wrapper to make handling logic easier outside the wrapper(only one type outside) Null Handling Donâ€™t Return Null: throw an exception or using Special Case Pattern Donâ€™t Pass Null: never pass null in methods Chapter 8 Boundaries Using Third-Party Code Hide the interface inside a class that we can control Avoid when change comes, we need change everywhere Make a Wrapper or Adapter to hide thrid-party interface Learning Test / Boundary Test Itâ€™s free and can be used to learning thrid-party code It can be used to detect breaking changes Chapter 10 Classes Class Organization Public static constants Private static constants Public instance variables (if any) Private instance variables Public functions Private function should directly after their caller Class should be small The more ambiguous the class name, the more likely it has too many responsibilities Avoid weasel words like Manager, Processor or Super which will aggregate responsibilities Single Responsibility Principle A class or module should have one and only one reason to change Identity reason to change often helps for better abstraction of our code A system composed of many small , well-structured classes is always better than a few large, multipurpose classes Chapter 11 System (Need revisit in future) Separate Constructing a System from Use it System should not know or care about startup logic, it assume everything should be constructed correctly when start running Using Dynamic Factory pattern to hide the building logic and allow application to decide when and what to build during runtime Dependency Injection: a way to achieve IOC (Inversion of Control) principle: the responsibility of instantiating dependencies will delegate to another â€œauthoritativeâ€ mechanism","link":"/2020/04/28/CleanCode/"},{"title":"clearArchitecture - Desgin Principles &amp; Component Principles","text":"In last post we talked about programming paradigms and SOLID principles. This is far more than enough to understand about architecture, so today letâ€™s continue on â€œDesign Principlesâ€ and see more of them that need to follow when thinking like an architect. Part IV Components PrinciplesComponentsThe samllest entities that can be deployed as part of a system. In java, they are jar files; In Ruby, they are gem files and in complied languages, they are aggregation of binary files. It can be dynamically linked together at runtime, which can be used as plug-in. Components Internal PrinciplesReuse/Release Equivalence Principle(REP) To resue software components, it need to be tracked through a release process and are given release numbers. Because developer needs to know which cohesive group is the current compoent belong to. In another word, component cannot be easily plug-in or pull-out without version control, it will mess up the whole project without clearly knowing which version contains what feature. Common Closure Principle(CCP) Gather into components those classes that change for the same reasons and at the same times. Separate into different components those classes that changed for different reasons and at different times. This is component level of SRP *(single responsible principle), which means *a component should not have multiple reasons to change. If you find two components are always changed together, try merge them into one. Common Reuse Principle(CRP) Donâ€™t force users of a component to depend on things they donâ€™t need This is component level of ISP (Interface Segregation Principle) and a bit more generic. If there are not used dependencies exists in component, that means when anything changed in those dependency, the component is highly possibly to do corresponding changes and then recompiled, revalidated and redeployed. So be careful to only depend on the things you really need. Component Tension DiagramSo after known those three component principle above, we can draw a tension diagram like this: As we can see here, these three principle are balanced to each other and when you try to apply two of them, you will sacrifice the another. Normally we start from CCP and CRP, to make the component working and changing fast. As the component become more and more stable, we will start to move left and apply REP to make it easier to reuse and maintain until we find a perfect balance in middle. The final balance point are varied team by team. Components External Principle (Between Components)Acyclic Dependencies Principle (ASP) Allow no cycles in the componet dependency graph Dependency cycle can work, but very difficult to change because when new change apply to one componet, all other components need to change to be compatiable. The cycle itself performed like a â€œsuper big componentâ€ which a lot other component will depend on. Two ways to eliminate the cycle in component dependency graph: Apply Dependency Inversion Principle (DIP): create an interface inside the depender component (the one need depend on the other) so the dependee will implement this interface. This UML will explain more clearly: Create a new component that both depender and dependee should depend on. In this way the cycle will be break since the new component will not depend on any of them. The UML should looks like: Stable Dependencies Principle (SDP) Depend in the direction of stability. This principle is short and concise, but might not be easy to understand. A better description might be: Any component that we expect to be volatile should not be depended on by a component that is hard to change, which means stable. To measure the instabillity, we need use I-metric to meature. I-metric can be calulated by: I = Fan-out / (Fan-in + Fan-out), for example: In this UML, we can see that both component A, B, C has I-metric = 1, which makes them unstable and easy to change because their changes will not influence any other componets. For component E, since I-metric = 0, which means itâ€™s hard to change because to change it, it might need to change all components depend on it such as B, C and D, which might need change A as well since A depends on D! For Componet D, I-metric=0.25 which means itâ€™s still stable and hard to change, but the effort to change it is less than component E. So basically I-metric can give us a hint that how easily this component can be changed. To make a stable component easy to change, we need to create something called abstract component. It is the same concept as interface at class level. so we will create a new component which contains interfaces and make both component depends on it, like: As we can see before compoent Authorizer I-metric = 0 which is hard to change, and after we using abstract component Permissions, it has I-metric = 1 and as easy to change as component Entities. Before we finish this principle, there are two points need to mention: SDP suggests that, in dependency graph, the I metric of a component should be larger than the I metric of the component that it depends on, which means the I metric should keep decreasing in the direction of dependency chain; Abstract components are very stable (usually I-metric = 0), so they are ideal target for less stable components to depend on. Stable Abstraction Principle (SAP) A component should be as abstract as it is stable. This is also too â€œabstractâ€ to understand. So a better explanation should be: A stable component should also be abstract so that itâ€™s stability does not prevent it from being extended; An unstable component should be concrete since its instability allows the concrete code within it to be easily changed. Since we know that dependencies should run in the direction of stability, and stable component should be abstract, we can also know: dependencies should run in the direction of abstraction. For stability, we have I-metric to measure, so do we have similar measurement for abstraction? Of course yes! Come on, A-metric! A-metric can be calculated by: A = Na / Nc, Na is number of classes inside the component and Nc is number of abstract classes and interfaces in the component. For an abstract component like we said above, A-metric = 1 which means totally abstract; and for a componet without any abstract classes and interfaces, A-metric = 0 which means totally concrete, pretty straightforwardğŸ‘. I-metric/A-metric GraphNow we can two metrics to describe a componentâ€™s stability and abstractness. But whatâ€™s the relation between them? How can we evaluate it? This is the time I-metric/A-metric Graph start to use: In this graph, we are using A-metric as vertical axis and I-metric as horizontal axis. In this way, each component wil fall into a point with coordinates in this graph. There are some points need to mention in this graph: Zone of Pain is a zone that not expected to put componets, because in this zone components are rigid,concrete and very hard to change. The only excluded case might be Databse schema or some utility libraries; Zone of Uselessness is also a not expected zone, because in this zone compoents are totally abstract and dependent which means might nobody using them and can be removed. The most desirable position for a component is at one of the two endpoints of the Main Sequence. They are stable and abstract, or flexible and concrete. Once the I/A graph is done, we can fill the components inside the graph and got this: By calculating the Distance between a point to Main Sequence: D = |I + A - 1|, we can get the result of how far away a component is from ideal. and then we can draw the standard deviation line(Z = 1) and focus on the component that beyond these lines and start refactor them. This is how these metrics can help us find the correct components to improve.","link":"/2020/07/06/ClearArchitecture2/"},{"title":"ClearArchitecture - Architecture","text":"After we known all principles in class level and component level, finally we reached Architecutre level. In this post, we will summarize all architecture level knowedge concepts quickly and finish this book for now, this book has much more useful stuffs that we are not covered, so we will come back and revisit someday after we have more understanding about software architecture. Part V ArchitecutreClear ArchitectureBy dividing the software into layers, the architecture has the following characteristics: Independent of frameworks: not depend on the existence of any library, use them like plug-in; Independent of the UI: not effected if UI changed, easy to replace with another UI; Independent of the database: not effected whatever DB is using like SQL or Mongo, CouchDB; Independent of any external agency: business rules donâ€™t know anything about outside world; Testable: business rule can be tested without UI, DB or web server, etc. In this way, we have the diagram structure of a Clear Architecture like: From this diagram, we can see: Inner circles represent higher level components and outer is lower, in another word, the further in you go, the higher level the software becomes; Source code dependencies must point only inward, toward higher-level policies. Nothing in an inner circle can know anything at all about outer circle. Inner circle has higher abstraction and stability while outer circle are more concrete and easy to change; The lower right corner shown how to cross circle boundaries; This four circles model is not strict, sometimes you may find more than four layers which is totally make sense: what important is following the component rules we introduced in last post here; When you want to pass data crosses boundaries, keep it isolated, simple and easy to be used by inner circle, which means: always processing raw data in outer circle before pass it inward. Now letâ€™s review this architecture model layer by layer: EntitesThis is the core layer of the model which contains enterprise-wide critical business rules. Usually this should be shared by all different applications in the enterprise, it can be business objects or a set of data structure. These are the least likely to change and shouldnâ€™t be effected when something external changed. User CaseThis is the layer of application-specific business rules that should be different between applications like mobile apps or browser websites. Changes in this layer should not affect Entites layer and vice versa, but the operation of the application will affect logic inside this layer for sure. Interface AdaptersThis layer contains a set of adapters that convert data from the format most convenient for the use cases and entities to the format most convenient for some external agency such as database, web or UI. For example, all models, views and presenters of the MVP pattern should be inside this layer. Also adapters in this layer should be bi-directional converting which means is should also convert data from external agency to use cases and entities as well. Frameworks And DriversThis is the outermost layer of the model which contains all frameworks and tools such as database, web framework or UI, in general, this is all the details go. Usually you donâ€™t need write much code in here, other than glue code that communicates to the next circle inward. Architecture DecouplingIndenpendenceA good architecture should support all the following: Use cases and opearation of the system (support the intent of the system) Maintenance of the system (support daily operations requirements) Developement of the system (support contributed by whole company without conflicts) Deployment of the system (immediate deployment) To achieve this, we need to decouple system into layers. Different layer should have different reason and rate to change. This decoupling mode can have three levels: Source Level: control the dependencies between source code modules so changes to one module do not force changes of others; Deployment Level: control dependencies between independently deployable units like jar failes or shared libraries; Service Level: control dependencies between each services so communicate solely through network packets. As always, itâ€™ hard to know which mode is best during the early phase of a project. As the project grows, the optimal mode may change. BoundaryBoundaries is drawing a line to prevented each side of the line from knowing anything about the other side. Drawing the boundary lines helped delay and defer decisions and saved amount of time and troubles. To draw boundary lines in software architecture, we need follow these steps: Partition the system into components, some components are core business rules and others are plugins; Arrange code in those components such that arrows between them point in one direction to core business; Apply SRP(Single Responsibility Principle) and it should tell where to draw the boundary line. DetailsDatabaseThe database is a utility that provides acccess to the data, it is just a mechanism we use to move the data back and forth between the surface of the dask and RAM. The organizational structure of data, the data model, is architecturally significant and the technologies and systems that move data on and off are not. WebThe web is an I/O device, it is a GUI, and GUI is a detail which only matters input and output. Framework Donâ€™t marry the framework! Frameworks are not architecture. You must make a huge commitment to the framework, but the framework author makes no commitment to you whatsoever. Use the framework but do not couple to it by deriveing proxies and keep those proxies in components that are plugins to business rules.","link":"/2020/07/09/ClearArchitecture3/"},{"title":"RxJavaåŸºç¡€æ¦‚å¿µæ¢³ç†","text":"Reactive programmingè¿™ä¸ªæ¦‚å¿µæˆ‘åœ¨æœ€è¿‘çš„å®‰å“å¼€å‘ä¸­æå…¶é¢‘ç¹çš„æ¥è§¦åˆ°ï¼Œä½†æ˜¯å¯¹äºä»æ²¡æœ‰æ¥è§¦è¿‡çš„æˆ‘æ¥è¯´ï¼Œå¾ˆå¤šæ¦‚å¿µè¿˜æ˜¯æœ‰ç‚¹æŠ½è±¡å’Œéš¾ä»¥ç†è§£ã€‚æ‰€ä»¥è¿™ç¯‡åšå®¢å°±æ¥æ¢³ç†ä¸€ä¸‹åœ¨è¿›è¡Œäº†ä¸€äº›äº†è§£å’Œå­¦ä¹ åï¼Œå…³äºæ‰€è°“â€œå“åº”å¼ç¼–ç¨‹â€çš„æˆ‘è‡ªå·±çš„ç†è§£ã€‚è¿™é‡Œçš„ä¾‹å­ä¸»è¦éƒ½æ˜¯åº”ç”¨äºRxJavaä¸­ï¼Œä½†å®é™…ä¸Šåœ¨ç¨å¾®æ¥è§¦äº†RxSwiftä»¥åŠRxCocoaä¹‹åï¼Œæˆ‘è®¤ä¸ºå®ƒä»¬çš„åŸºæœ¬æ¦‚å¿µéƒ½æ˜¯ç›¸åŒçš„ï¼Œæ‰€ä»¥äº†è§£RxJavaä¹‹åï¼ŒRxSwiftå’ŒRxCocoaå°±å®Œå…¨ä¸åœ¨è¯ä¸‹ã€‚ The 3 Oâ€™så¦‚æœä½ ç†Ÿæ‚‰è®¾è®¡æ¨¡å¼ä¸­çš„è§‚å¯Ÿè€…æ¨¡å¼ï¼Œ é‚£ä¹ˆç®€å•æ¥è¯´ï¼ŒRxactive programmingå°±æ˜¯ä¸€ç§æ›´ä¸ºå¤æ‚å’Œå¤šæ ·çš„è§‚å¯Ÿè€…æ¨¡å¼çš„åº”ç”¨ã€‚é¦–å…ˆè¦ä»‹ç»çš„ï¼Œå°±æ˜¯åœ¨RxJavaä¸­å‡ºäºæœ€æ ¸å¿ƒéƒ¨åˆ†çš„ä¸‰ä¸ªæ¦‚å¿µï¼š Observableï¼Œ Observerå’ŒOperatorï¼Œç®€ç§° the 3 Oâ€™sã€‚ ObservableObservableç›´è¯‘å°±æ˜¯â€å¯è¢«è§‚å¯Ÿçš„â€œï¼Œæˆ‘è®¤ä¸ºå¯ä»¥æŠŠå®ƒç†è§£æˆä¸€ç§â€æ•°æ®æºâ€œï¼Œå°±æ˜¯æºæºä¸æ–­çš„äº§ç”Ÿæ•°æ®çš„â€å·¥å‚â€œã€‚é€šå¸¸å½“æˆ‘ä»¬éœ€è¦ä»»ä½•æ•°æ®æ—¶ï¼Œæˆ‘ä»¬éƒ½å¯ä»¥åˆ›å»ºä¸€ä¸ªObservableå®ä¾‹å¹¶åœ¨å…¶ä¸­å£°æ˜äº§ç”Ÿæ•°æ®çš„æ–¹æ³•ï¼Œæ¯”å¦‚ç½‘ç»œè¯·æ±‚ï¼Œè¿›è¡Œå¤æ‚è¿ç®—ï¼Œæˆ–ç­‰å¾…ç”¨æˆ·è¾“å…¥ç­‰ç­‰ã€‚å½“éœ€è¦è·å–å¯¹åº”æ•°æ®æ—¶ï¼Œå®ƒä¼šä¾æ¬¡å‘é€å‡ºéœ€è¦çš„æ•°æ®ï¼Œå½¢æˆæ•°æ®æµï¼Œå¹¶è¢«Observerä¾æ¬¡è·å–ã€‚ åˆ›å»ºä¸€ä¸ªObservableçš„æ–¹æ³•æœ‰å¾ˆå¤šï¼Œæœ€åŸºç¡€çš„æ–¹æ³•å°±æ˜¯ä½¿ç”¨Observable.create()æ–¹æ³•å¹¶ä¼ å…¥ä¸€ä¸ªObservable.OnSubscribeå®ä¾‹ï¼Œä¾‹å¦‚ï¼š 12345678Observable&lt;Integer&gt; observable = Observable.create(new Observable.OnSubscribe&lt;Integer&gt;() { @Override public void call(Subscriber&lt;? super Integer&gt; subscriber) { subscriber.onNext(1); subscriber.onNext(2); subscriber.onNext(3); subscriber.onCompleted(); }}); åœ¨è¿™ä¸ªä¾‹å­ä¸­ï¼Œobservableä¼šä¾æ¬¡å‘é€1ï¼Œ2ï¼Œ3ä¸‰ä¸ªå€¼ï¼Œç„¶åå£°æ˜è‡ªå·±å®Œæˆå‘é€å¹¶ç»“æŸã€‚è¿™é‡Œéœ€è¦æ³¨æ„çš„æ˜¯ï¼Œå¦‚æœä¸æ‰§è¡ŒonCompleted()æ–¹æ³•ï¼Œé‚£ä¹ˆObservableå°±ä¼šè¢«è®¤å®šä¾æ—§è¿è¡Œï¼Œè¿™ä¸ªå¯¹è±¡ä¹Ÿä¸ä¼šè¢«å›æ”¶ç›´è‡³ä¸€ä¸ªonCompleted()æˆ–è€…onError()æ–¹æ³•è¢«æ‰§è¡Œæˆ–è€…observableæœ¬èº«è¢«é”€æ¯ï¼ˆä¼šå­˜åœ¨å†…å­˜æ³„æ¼çš„é—®é¢˜ï¼‰ã€‚å¹¶ä¸”Observableåœ¨æ²¡æœ‰ä»»ä½•observerè®¢é˜…æ—¶ï¼Œä¸ä¼šå‘é€ä»»ä½•æ•°æ®ã€‚ ä¸ºäº†æ›´åŠ æ–¹ä¾¿çš„åˆ›å»ºobservableï¼ŒRxJavaåˆä¸ºæˆ‘ä»¬æä¾›äº†ä¸€äº›å¿«é€Ÿåˆ›å»ºçš„æ–¹æ³•ï¼Œæ¯”å¦‚åˆ›å»ºä¸€ä¸ªå’Œä¸Šè¾¹ä¸€æ ·çš„observableï¼Œä¹Ÿå¯ä»¥ä½¿ç”¨å¦‚ä¸‹ä»£ç ï¼š 1Observable.just(1,2,3); é€šè¿‡è¿™ç§æ–¹å¼ï¼Œæˆ‘ä»¬å¯ä»¥æ›´åŠ å¿«é€Ÿç›´è§‚çš„åˆ›å»ºä¸€ä¸ªObservableå¹¶ä¸”çœ‹åˆ°éœ€è¦å‘é€çš„æ•°æ®ï¼Œä½†æ˜¯è¿™ä»…é€‚ç”¨äºå‘é€ç®€å•æ•°æ®çš„æƒ…å†µã€‚ Observerè¯´å®ŒObservableï¼Œä¸‹é¢å°±æ˜¯å¯¹åº”çš„â€œè§‚å¯Ÿè€…â€Observeräº†ã€‚é¡¾åæ€ä¹‰ï¼Œobserverå°±æ˜¯æ•°æ®çš„â€œæ¥æ”¶æ–¹â€ï¼Œä¹Ÿå°±æ˜¯å¯¹äºæ¥æ”¶æ•°æ®è¿›è¡Œå“åº”çš„å¯¹è±¡ã€‚ç›¸æ¯”äºObservableï¼Œobserverçš„ä½¿ç”¨æ–¹æ³•æ›´ä¸ºç®€å•ï¼Œæˆ‘ä»¬åªéœ€è¦åˆ›å»ºä¸€ä¸ªç»§æ‰¿Observeræ¥å£ï¼šonNext(), onComplete()å’ŒonError()çš„å®ä¾‹ï¼Œç„¶åæ‰§è¡Œobservable.subscribe()è®¢é˜…æ–¹æ³•å¹¶å°†observerä¼ å…¥å³å¯ã€‚ä¾‹å¦‚ï¼š 1234567891011121314151617181920// åˆ›å»ºObserverObserver&lt;Object&gt; observer = new Observer&lt;Object&gt;() { @Override public void onCompleted() { Log.d(\"Test\", \"In onCompleted()\"); } @Override public void onError(Throwable e) { Log.d(\"Test\", \"In onError()\"); } @Override public void onNext(Object s) { Log.d(\"Test\", \"In onNext():\" + integer); } };// Observableè®¢é˜…Observerobservable.subscribe(observer); é€šè¿‡subscribe()çš„æ–¹æ³•è¿›è¡Œè®¢é˜…åï¼Œobserverå°±å¯ä»¥ç›´æ¥æ¥æ”¶åˆ°æ‰€æœ‰ä»observableå‘å‡ºçš„æ•°æ®ï¼Œä¸ä»…ååˆ†æ–¹ä¾¿ï¼Œä»£ç ä¹Ÿååˆ†ç›´è§‚ã€‚ Operatorç›¸æ¯”äºObservableå’ŒObserverï¼ŒOperatoræ›´åƒä¸€ä¸ªè¾…åŠ©æ€§çš„â€œä¸­é—´å•†â€ã€‚å®ƒè´Ÿè´£å¤„ç†observableä¼ é€’è¿‡æ¥çš„åŸå§‹æ•°æ®ï¼Œå°†å…¶è½¬åŒ–ï¼ˆtransform &amp; polishï¼‰æˆobserveréœ€è¦çš„æ•°æ®ç±»å‹ï¼Œå†ä¼ ç»™è®¢é˜…çš„observerã€‚é€šè¿‡è¿™ç§æ–¹å¼ï¼Œå¯ä»¥è®©æ•°æ®ç±»å‹çš„è½¬æ¢æ›´ä¸ºæ–¹ä¾¿å¿«æ·ï¼Œæ•´ä½“çš„ä»£ç ä¹Ÿæ›´ä¸ºæ¸…æ™°æ˜äº†ã€‚å¸¸ç”¨çš„ä¸€äº›operatoræ–¹æ³•åŒ…æ‹¬ï¼š map()ï¼šå¯¹äºæ¯ä¸ªæ•°æ®éƒ½æ‰§è¡Œä¸€ä¸ªå¯¹åº”çš„functionï¼Œæ‰§è¡Œç»“æœä¸åŸæ•°æ®ä¸€ä¸€å¯¹åº”å¹¶è¾“å‡ºï¼› flatMap()ï¼šå¯¹äºæ¯ä¸ªæ•°æ®éƒ½æ‰§è¡Œä¸€ä¸ªå¯¹åº”çš„functionï¼Œæ‰§è¡Œç»“æœå…¨éƒ¨å­˜å…¥ä¸€ä¸ªObservableå¹¶è¾“å‡ºï¼ˆflatæ„æ€å°±åœ¨äºæ­¤ï¼‰ï¼Œç›¸å½“äºä¸€å¯¹å¤šçš„å¯¹åº”å…³ç³»ï¼› groupBy()ï¼šå¯¹äºæ¯ä¸ªæ•°æ®æºæŒ‰grouping ruleè¿›è¡Œmappingï¼Œç»“æœæŒ‰ä¸åŒgroupå­˜å…¥ä¸åŒobservableï¼Œæœ€ç»ˆè¾“å‡ºobservable setï¼› filterï¼šé¡¾åæ€ä¹‰ï¼ŒæŒ‰ç…§æŸç§æ¡ä»¶å¯¹å…¶è¿›è¡Œç­›é€‰å¹¶å°†ç¬¦åˆç­›é€‰æ¡ä»¶çš„æ•°æ®è¾“å‡ºã€‚ æ‰€æœ‰build-in operatorå¯ä»¥åœ¨è¿™é‡Œæ‰¾åˆ°ï¼Œé‡Œé¢ä¹Ÿæœ‰ååˆ†è¯¦å°½çš„å¯¹äºæ¯ä¸ªoperatorä½œç”¨çš„ä»‹ç»ï¼Œå…³äºOperatoræ›´ä¸ºè¯¦ç»†çš„ä»‹ç»ï¼Œä»¥åä¼šä¸“é—¨åœ¨å†™ä¸€ç¯‡æ–‡ç« ï¼Œè¿™é‡Œä¸å†èµ˜è¿°ã€‚ ç»¼åˆä¸Šé¢å¯¹äºä¸‰ä¸ªåŸºæœ¬æ¦‚å¿µçš„ä»‹ç»ï¼Œæˆ‘ä»¬å¯ä»¥çŸ¥é“ï¼ŒReactive Programmingä¸»ä½“é€»è¾‘çš„æµç¨‹å›¾å¤§è‡´å°±æ˜¯ï¼š Multi-threadingé¦–å…ˆè¦è¯´æ˜çš„æ˜¯ï¼ŒRxJavaæœ¬èº«åœ¨ä¸å£°æ˜ä»»ä½•scheduleræ—¶æ˜¯é»˜è®¤å•çº¿ç¨‹è¿è¡Œçš„ï¼Œä½†å®é™…ä½¿ç”¨æ—¶å¾ˆå¤šæ—¶å€™æˆ‘ä»¬éƒ½éœ€è¦åœ¨ä¸åŒçº¿ç¨‹ä¸Šå»è¿›è¡Œæ•°æ®çš„äº§ç”Ÿå’Œä¼ é€’ï¼Œè¿™æ˜¯å°±éœ€è¦ç”¨åˆ°å®ƒçš„å¤šçº¿ç¨‹(Multi-threading)ç‰¹æ€§ã€‚RxJavaçš„å¤šçº¿ç¨‹æ§åˆ¶ä¸»è¦ç”±ä¸¤ä¸ªæ–¹æ³•æ¥å†³å®šï¼šsubscribeOn() å’ŒobserveOn()ã€‚ subscribeOn()subscribeOn()è¿™ä¸ªæ–¹æ³•ç”¨äºæŒ‡å®šEmitterï¼ˆObservableï¼ŒSingleï¼ŒFlowableç­‰ç­‰ï¼‰åœ¨å“ªä¸€ä¸ªthreadä¸Šè¿è¡Œå¹¶äº§ç”Ÿæ•°æ®ï¼Œå®ƒçš„å…·ä½“å£°æ˜ä½ç½®å¯¹äºä»£ç çš„æ‰§è¡Œæ²¡æœ‰ä»»ä½•å½±å“ï¼Œæ— è®ºå£°æ˜çš„å…ˆåé¡ºåºã€‚ä¸¾ä¸ªä¾‹å­ï¼š 123456Observable.just(\"1\", \"2\", \"3\", \"4\", \"5\") .subscribeOn(Schedulers.computation()) .flatMap { value -&gt; Observable.just(value.toInt()) } .subscribe { print(it) } 123456Observable.just(\"1\", \"2\", \"3\", \"4\", \"5\") .flatMap { value -&gt; Observable.just(value.toInt()) } .subscribeOn(Schedulers.computation()) .subscribe { print(it) } ä»¥ä¸Šä¸¤æ®µä»£ç ï¼Œå®ƒä»¬åœ¨è¿è¡Œé€»è¾‘ä¸Šæ²¡æœ‰ä»»ä½•åŒºåˆ«ï¼ŒObservableéƒ½æ˜¯åœ¨computation threadä¸Šè¿è¡Œã€‚ obverseOn()observeOn()è¿™ä¸ªæ–¹æ³•ç”¨äºæŒ‡å®šObserveråœ¨å“ªä¸€ä¸ªthreadä¸Šå»å¤„ç†Observableä¼ é€’å‡ºæ¥çš„æ•°æ®ï¼Œå®ƒåªå¯¹å½“å‰å£°æ˜ä½ç½®ä¸‹æ–¹çš„ä»£ç äº§ç”Ÿå½±å“ï¼Œæ¢ä¸ªæ–¹å¼æ¥è¯´ï¼Œå½“ä»£ç æ‰§è¡Œåˆ°obverseOn()æ—¶ï¼Œä¼šåˆ‡æ¢çº¿ç¨‹å¹¶ç»§ç»­æ‰§è¡Œåé¢çš„é€»è¾‘ã€‚ä¾‹å¦‚ï¼š 12345678Observable.just(\"1\", \"2\", \"3\", \"4\", \"5\") .observeOn(Schedulers.computation()) // åˆ‡æ¢åˆ° computation thread .flatMap { value -&gt; Observable.just(value.toInt()) } // computation threadä¸Šæ‰§è¡Œ .observeOn(Schedulers.io()) // åˆ‡æ¢åˆ° io thread .map { value -&gt; value * value } // io threadä¸Šæ‰§è¡Œ .subscribe { print(it) // io threadä¸Šæ‰§è¡Œ } Schedulerä»ä¸Šé¢çš„ä¾‹å­å¯ä»¥çœ‹å‡ºï¼ŒsubscribeOn()å’ŒobserveOn()è¿™ä¸¤ä¸ªæ–¹æ³•éƒ½æ˜¯é€šè¿‡ä¼ å…¥Schedulerçš„ç±»å‹ä½œä¸ºå‚æ•°æ¥ä¿è¯æ•°æ®çš„äº§ç”Ÿï¼Œå¤„ç†å’Œæ¥æ”¶éƒ½å‘ç”Ÿåœ¨å¯¹åº”çš„threadé‡Œçš„ã€‚é‚£ä¹ˆSchedulerçš„ç±»å‹éƒ½æœ‰å“ªäº›å‘¢ï¼Ÿè¿™é‡Œå°±åˆ—ä¸¾äº†ä¸€äº›Androidå¹³å°ä¸Šæœ€ä¸ºå¸¸ç”¨çš„Schedulerç±»å‹ä»¥åŠå¯¹åº”çš„é€‚ç”¨æƒ…å†µï¼š Scheduler.io() æœ€å¸¸ä½¿ç”¨çš„ä¸€ç§schedulerï¼Œä¸»è¦ç”¨äºå¤„ç†IOæ“ä½œä¾‹å¦‚ç½‘ç»œè¯·æ±‚ï¼Œæ–‡ä»¶è¯»å†™æ“ä½œï¼› Scheduler.computation() å¤„ç†ä¸è®¡ç®—ç›¸å…³çš„æ“ä½œï¼Œæ•°é‡ä¸Šé™ç­‰åŒäºå¤„ç†å™¨å†…æ ¸çš„æ•°é‡ï¼› Scheduler.newThread() åˆ›å»ºä¸€ä¸ªæ–°çš„schedulerï¼Œè¦å°½é‡é¿å…åˆ›å»ºè¿‡å¤šschedulerï¼Œå°½é‡å¤šä½¿ç”¨å·²ç»å­˜åœ¨çš„çº¿ç¨‹ï¼› Scheduler.single() åœ¨ä¸€ä¸ªç‹¬ç«‹çš„å•çº¿ç¨‹å¤„ç†æ“ä½œï¼Œç±»ä¼¼äºä¸€ä¸ªåå°ç‹¬ç«‹çš„main threadï¼› Scheduler.trampoline() ç”¨äºå³æ—¶å¤„ç†æ“ä½œï¼Œå®ƒä¼šç«‹åˆ»å¼€å§‹å¹¶ä¸¥æ ¼æŒ‰é¡ºåºå¤„ç†æ‰€æœ‰å½“å‰çº¿ç¨‹ä¸Šçš„Observableï¼› AndroidSchedulers.mainThread() å®‰å“çš„ä¸»UI threadï¼Œå¿…é¡»æ³¨æ„ä¸è¦è®©å®ƒè¢«è´¹æ—¶é—´ï¼Œæœ‰å»¶æ—¶çš„æ“ä½œblockä½ï¼Œå¦åˆ™ä¼šANRã€‚ Emitteré™¤äº†Observableè¿™ä¸ªâ€œæ•°æ®æºå·¥å‚â€ï¼ŒRxJavaè¿˜æœ‰è®¸å¤šå…¶ä»–çš„ç±»å‹ï¼Œå®ƒä»¬è¢«ç»Ÿç§°ä¸ºEmitterï¼Œä¹Ÿå°±æ˜¯â€œå‘å°„å™¨â€œã€‚å®ƒä»¬éƒ½æ˜¯äº§ç”Ÿæ•°æ®æˆ–è€…è·å¾—æ•°æ®çš„æ¥æºï¼Œä½†æ˜¯ä¸åŒçš„ç±»å‹åˆæœ‰ä¸€äº›ä¸åŒçš„ç‰¹æ€§ï¼Œåœ¨è¿™é‡Œåˆ—å‡ºå‡ ç§é™¤äº†Observableä»¥å¤–å¸¸ç”¨çš„Emitterç±»å‹ï¼š FlowableFlowableå’ŒObservableçš„ç”¨æ³•å‡ ä¹ä¸€æ‘¸ä¸€æ ·ï¼Œå”¯ä¸€çš„åŒºåˆ«åœ¨äºFlowableå¯ä»¥å¤„ç†Backpressureçš„æƒ…å†µã€‚æ‰€è°“Backpressureï¼Œå°±æ˜¯å½“Emitterçš„æ•°æ®äº§ç”Ÿçš„é€Ÿåº¦è¿‡å¿«ï¼Œè€ŒObserveræ¥æ”¶ç«¯å¤„ç†æ•°æ®çš„é€Ÿåº¦è¿‡æ…¢æ—¶ï¼Œæ•°æ®ä¼šå †ç§¯åœ¨Emitterçš„memoryé‡Œç­‰å¾…å‘é€ï¼Œç´¯ç§¯åˆ°ä¸€å®šç¨‹åº¦æ—¶å°±ä¼šæŠ›å‡ºOutOfMemoryExceptionå¼‚å¸¸ã€‚ Flowableé€šè¿‡ä½¿ç”¨BackpressureStrategy.DROPçš„ç­–ç•¥ï¼Œä¹Ÿå°±æ˜¯åœ¨memoryå³å°†å­˜æ»¡æ—¶ä¸¢å¼ƒä¸€äº›æ•°æ®çš„æ–¹æ³•ï¼Œæ¥å¤„ç†backpressureçš„é—®é¢˜ã€‚Observableä¹Ÿå¯ä»¥é€šè¿‡observable.toFlowable(BackpressureStrategy.DROP)çš„æ–¹æ³•è½¬æ¢ä¸ºFlowableæ¥è¿›è¡Œä½¿ç”¨ã€‚ SingleSingleæ˜¯ä¸€ä¸ªéå¸¸ç®€å•çš„å‘å°„å™¨ï¼Œé¡¾åæ€ä¹‰ï¼Œå®ƒä»…åœ¨è·å–å¹¶å‘å°„ä¸€ä¸ªå•ç‹¬çš„æ•°æ®å®ä¾‹ä¹‹åä¾¿ç»“æŸå‘é€ã€‚å¦‚æœæ•°æ®è·å–å¹¶å‘é€æˆåŠŸï¼Œè¿è¡ŒonSuccess()ï¼›å‘é€å¤±è´¥çš„è¯åˆ™è¿è¡ŒonError()ã€‚è¿™ç§ç±»å‹åœ¨æˆ‘ä»¬è¿”å›å•ä¸ªæ•°æ®æ—¶ååˆ†å®ç”¨ã€‚Singleçš„ç¤ºä¾‹ä»£ç ï¼š 12345Single.just(\"This is a single\") .subscribe( { v -&gt; print(\"value is $v\") }, { e -&gt; print(\"error is $e\") } ) MaybeMaybeå’ŒSingleç±»ä¼¼ï¼Œå…¶åŒºåˆ«åœ¨äºï¼šMaybeæœ‰å¯èƒ½ä¸å‘é€ä»»ä½•æ•°æ®å°±ç»“æŸå‘é€ã€‚è¿™ç§ç±»å‹ä¸»è¦ç”¨äºè·å–ä¸€äº›optionalçš„æ•°æ®æ—¶ä½¿ç”¨ï¼Œå› ä¸ºå®ƒå¯èƒ½å­˜åœ¨ï¼Œä¹Ÿå¯ä»¥ä¸å­˜åœ¨ã€‚å¦‚æœæ•°æ®è·å–å¹¶å‘é€æˆåŠŸï¼Œè¿è¡ŒonSuccess()ï¼›å‘é€å¤±è´¥çš„è¯ï¼Œè¿è¡ŒonError()ï¼›è€Œæ²¡æœ‰è·å¾—æ•°æ®çš„è¯åˆ™è¿è¡ŒonComplete()ã€‚è¿™ç§ç±»å‹åœ¨æˆ‘ä»¬è¿”å›å•ä¸ªoptionalæ•°æ®æ—¶ååˆ†å®ç”¨ã€‚Maybeçš„ç¤ºä¾‹ä»£ç ï¼š 123456Maybe.just(\"This is a single\") .subscribe( { v -&gt; print(\"value is $v\") }, { e -&gt; print(\"error is $e\") }, { print(\"Completed\") } ) Completableç›¸æ¯”äºå…¶ä»–æ‰€æœ‰çš„Emitterçš„æœ€å¤§åŒºåˆ«å°±æ˜¯ï¼šå®ƒä¸å‘å°„æ•°æ®ï¼Œè€Œæ˜¯ä»…å…³å¿ƒæ“ä½œæ˜¯å¦æˆåŠŸå®Œæˆã€‚å¦‚æœæˆåŠŸå®Œæˆï¼Œè¿è¡ŒonComplete()ï¼Œå¦‚æœå¤±è´¥ï¼Œåˆ™è¿è¡ŒonError()ã€‚Completableå°±åƒæ˜¯RxJavaç‰ˆçš„Runnableï¼Œå¯ä»¥é€šè¿‡addThen()æ–¹æ³•è¿›è¡Œè¿æ¥å¹¶æ‰§è¡Œã€‚åŒæ—¶ï¼Œä¸Šé¢åˆ—ä¸¾å‡ºçš„æ‰€æœ‰å‘å°„å™¨ç±»å‹ï¼Œéƒ½å¯ä»¥é€šè¿‡ä¾‹å¦‚Completable.fromSingle(Single.just(&quot;this is single&quot;))çš„æ–¹å¼è½¬æ¢ä¸ºCompletableå¹¶ä¸²è”å…¶ä»–Completableè¿›è¡Œè¿è¡Œã€‚Completableç¤ºä¾‹ä»£ç ï¼š 1234567891011Completable.create { emitter -&gt; emitter.onComplete() emitter.onError(Exception())}Completable .fromSingle(Single.just(\"This is a single\")) .subscribe( { print(\"complete!\") }, { print(\"error!\") } ) Subjectå‰é¢è¯´åˆ°ï¼ŒOperatorä¸»è¦ç”¨äºå¯¹ä¼ é€æ•°æ®è¿›è¡Œå¤„ç†å’Œè½¬åŒ–ã€‚ä½†æ˜¯å¯¹äºä¸€äº›å®é™…ä½¿ç”¨åœºæ™¯æ¥è¯´ï¼Œoperatorè¿˜æ˜¯ä¸å¤Ÿçµæ´»ã€‚äºæ˜¯RxJavaåˆæä¾›äº†Subjectè¿™ä¸ªç±»å‹æ¥è®©æˆ‘ä»¬æ›´è¿‘çµæ´»åœ°è¿›è¡Œæ•°æ®çš„ä¼ è¾“ã€‚ A Subject is a sort of bridge or proxy that is available in some implementations of ReactiveX that acts both as an observer and as an Observable. ä¸Šé¢æ˜¯å®˜æ–¹æ–‡æ¡£å…³äºSubjectçš„è§£é‡Šï¼Œç®€å•æ¥è¯´Subjectå°±åƒæ˜¯ä¸€ä¸ªè¿æ¥ä¸åŒObservableå’ŒObserverçš„â€æ¡¥æ¢â€œã€‚å®ƒæ—¢å¯ä»¥ä½œä¸ºObservableæ¥å‘é€æ•°æ®ï¼Œä¹Ÿå¯ä»¥ä½œä¸ºObserveræ¥æ¥æ”¶æ•°æ®ã€‚é€šè¿‡Subjectï¼Œæˆ‘ä»¬å¯ä»¥å°†ä»»æ„Observableçš„æ•°æ®è¿›è¡Œæ¥æ”¶ï¼Œå¤„ç†ï¼Œå¹¶å†æ¬¡å‘é€ç»™å…¶ä»–Observerã€‚å…³äºSubjectï¼Œå…¶å®RxJavaé‡Œè¿˜æœ‰è®¸å¤šå…¶ä»–çš„ç±»å‹ã€‚è¿™é‡Œåªåˆ—ä¸¾æœ€ä¸ºå¸¸ç”¨çš„å››ç§ç±»å‹ï¼Œå…¶ä½™ç±»å‹ä¼šåœ¨ä»¥åç¢°åˆ°æ—¶è¡¥å……æ›´æ–°åœ¨è¿™é‡Œï¼š PublishSubjectæ¯”è¾ƒç®€å•çš„ä¸€ç§Subjectç±»å‹ï¼Œä¼šåœ¨subscriptionä¹‹åå°†æ‰€æœ‰æ•°æ®ä¾æ¬¡å‘é€ã€‚å€¼å¾—æ³¨æ„çš„æ˜¯ï¼šPublishSubjectä¼šåœ¨åˆå§‹åŒ–åç«‹åˆ»å¼€å§‹å‘é€æ•°æ®ï¼Œè€Œä¸æ˜¯æœ‰Observer subscribeä¹‹åå‘é€ï¼Œæ‰€ä»¥ä¼šå­˜åœ¨observeræ¥æ”¶æ•°æ®ä¸å®Œæ•´çš„æƒ…å†µã€‚å¯¹äºè¿™ç§æƒ…å†µï¼ŒReactiveXç»™å‡ºäº†ä¸¤ç§æ–¹å¼è§£å†³ï¼š1. ä½¿ç”¨Create()æ–¹æ³•å¹¶åœ¨åˆå§‹åŒ–å‰ç¡®è®¤observerå·²ç»å®Œæˆè®¢é˜…ï¼›2.ä½¿ç”¨ä¸‹é¢è¦ä»‹ç»åˆ°çš„ReplaySubjectã€‚ BehaviourSubjectç›¸æ¯”äºPublishSubjectï¼ŒBehaviourSubjectæœ€å¤§çš„ç‰¹ç‚¹å°±æ˜¯ï¼šå®ƒä¼šå‘é€Subscriptionä¹‹å‰çš„æœ€åä¸€ä¸ªæ•°æ®ï¼ˆlast emitted dataï¼‰ä»¥åŠSubscriptionä¹‹åå°†æ‰€æœ‰æ•°æ®ã€‚é™¤æ­¤ä¹‹å¤–ï¼Œå®ƒå’ŒPublishSubjectçš„ç‰¹ç‚¹åŸºæœ¬ä¸€è‡´ã€‚ ReplaySubjectReplaySubjectä¼šå‘é€Observableäº§ç”Ÿçš„å…¨éƒ¨æ•°æ®ï¼Œæ— è®ºæ˜¯subscriptionä¹‹å‰è¿˜æ˜¯ä¹‹åã€‚å…¶å†…éƒ¨å°±æ˜¯ç”¨ä¸€ä¸ªListåŠ¨æ€å­˜å‚¨æ‰€æœ‰æ¥æ”¶çš„æ•°æ®ï¼Œå¹¶åœ¨subscriptionæ—¶å‘é€ç»™Observerã€‚è¿™ä¹Ÿå°±æ˜¯ä¸Šé¢è¯´åˆ°çš„ä¸ºä»€ä¹ˆå¯ä»¥ä½¿ç”¨ReplaySubjectæ¥ç¡®ä¿Observeræ¥æ”¶æ•°æ®çš„å®Œæ•´æ€§ã€‚ AsyncSubjectAsyncSubjectä»…ä¼šå‘é€Observableäº§ç”Ÿçš„æœ€åä¸€ä¸ªæ•°æ®ï¼Œæ— è®ºæ˜¯subscriptionä¹‹å‰è¿˜æ˜¯ä¹‹åã€‚ æ€»ç»“è¿™æ˜¯å…³äºRxJavaçš„ç¬¬ä¸€ç¯‡æ€»ç»“æ–‡ç« ï¼Œä¸»è¦ä»‹ç»äº†ä¸€äº›æ¯”è¾ƒåŸºç¡€çš„æ¦‚å¿µã€‚ä¹‹åä¼šç»§ç»­å†™ä¸€äº›æ²¡æœ‰æ¶‰åŠåˆ°çš„æ¦‚å¿µæ¯”å¦‚Subjectï¼Œæ›´å¤šOperatorçš„å…·ä½“ç”¨æ³•ï¼Œä»¥åŠæ¯”è¾ƒRxJavaå’ŒRxSwiftçš„ä¸€äº›å¼‚åŒç­‰ç­‰ã€‚Reactive programmingæ˜¯éå¸¸å¼ºå¤§çš„å·¥å…·ï¼Œå¯ä»¥è®©æˆ‘ä»¬æ›´è½»æ¾çš„ç®¡ç†æ•°æ®æµå¹¶å®ç°å¤šçº¿ç¨‹çš„åŒæ­¥ï¼Œå¸Œæœ›è¿™ç¯‡æ–‡ç« ä¸­çš„æ¦‚å¿µå¯ä»¥å¯¹äºå“åº”å¼ç¼–ç¨‹æœ‰ä¸€ä¸ªæ›´æ¸…æ™°çš„ç†è§£ï¼Œhappy coding!ã€‚ å‚è€ƒæ–‡ç« ReactiveX å®˜æ–¹æ–‡æ¡£ Meet RxJava: The Missing Reactive Programming Library for Android Fundamentals of RxJava with Kotlin for absolute beginners Reactive X: RxJava Data Flows: Observable, Flowable, Single, Maybe and Completable RxJava/RxAndroidä½¿ç”¨å®è·µå®ä¾‹","link":"/2020/08/06/RxJava/"},{"title":"Clear Architecture - Programming Paradigms &amp; Design Principles","text":"Clean Architecture is one of the series book that written by â€œUncle Bobâ€. In last post, I writed a summary of the Clean Code. It is super useful for begineers. But as we going deeper, we need take a step back and see the â€œbig pictureâ€ â€“ software architecture, which is all this book talk about. Part II Starting with the Bricks: Programming ParadigmsStructured Programming: direct transfer of controlConstructed from sequence, selection and iteration to replace old goto keyword. A typical structured programming example: 123456789101112131415// sequence executionval sum = 0val current = 1// iterationwhile (current &lt; 10) { sum += current current += 1}// selectionif (needNegative) { return sum *= -1} else { return sum}return sum All programs can be constructed from just these three structures: sequence, selection and iteration. Object-Oriented Programming: indirect transfer of controlThrough the use of polymorphism to gain absolute control over every source code dependency in the system.To better understnad about power of polymorphism. also check Dependency Inversion Principle below. A typical object-oriented programming example: 123456789101112131415161718192021222324252627282930313233343536// define Vehicle interfaceinterface Vehicle { fun alarm() fun turnOn() fun turnOff()}// different brand of car, should all implement the same interfaceclass BMW: Vehicle { override fun alarm() { makrSound(\"di~di~\") } override fun turnOn() { ... } override fun turnOff() { ... }}// but they can have diffrent implementation (such as differnt alram sound)class Ford: Vehicle { override fun alarm() { makrSound(\"do~do~\") } override fun turnOn() { ... } override fun turnOff() { ... }}// when client code is using them, they don't need to know the implementation detailsFord().turnOn()BMW().ring() Any source code dependency, no matter where it is, can be inverted. Functional Programming: variable assignmentVariables in functional languages do not vary, which will causing none of race condition, deadlock or concurrent update problems. A typical functional programming example: 123456789class Person constructor ( private val name: String) { fun getName(): String { return name }}// define a function to get person's nameval personName = fun(person: Person) = person.getName Concurrent problems can be eliminated by segregate the application into mutable and immutable components. Part III Design PrinciplesSingle Responsibility Principle (SRP) A module should have one, and only one reason to change A common way to impose this principle is: Separate shared functional code blocks from specific logic. For example, here is a Employee class from payroll application: 1234567891011121314class Employee { private val employeeDB = EmployeeDatabase() fun getWorkingHours(): Int { return employeeDB.queryWorkingHours() } fun calculatePayroll(): Int { val workingHours = getWorkingHours() val salaryRatePerHour = employeeDB.querySalaryRatePerHour() return workingHours * salaryRatePerHour } fun saveEmployee() { employeeDB.updateEmpployee(this) }} Itâ€™s clear that this Employee class has too many responsibilities including query working hour, query salary rate, calculate payroll, update employee info etc. And typical problem can be: Itâ€™s hard to extends, when introduce different ways to calculate payroll for example; Who wants to change ONLY working hours fetching may also touch payroll calculation accidentally; EmployeeDatabase is exposed to Employee class, which is dangerous for open visibility. To solve these issues, we can do: 1234567891011121314class Employee { private val hourReporter = HourReporter() private val payCalculator = PayCalculator() private val employeeSaver = EmployeeSaver() fun getWorkingHours(): Int { return hourReporter.reportHours() } fun calculatePayroll(): Int { return payCalculator.calculatePay() } fun saveEmployee() { employeeSaver.saveEmpployee(this) }} As we can see, after we create HourReporter, PayCalculator and EmployeeSaver, we separate different responsibilities to different class so: if we want to have diffrent ways to calculate payroll, it can be updated inside PayCalculator and no need to update Employee class; when working hours fetching need to change, no need to touch payroll calculation logic; no more database expose to Employee class since itâ€™s handled by these three classes internally. Open-Closed Principle (OCP) A software artifact should be open for extension but closed for modification. This is a common case that sometimes we want to extends part of our code and extends without having to modify that artifact. To make this possible, we need to implement component hierarchy structure so code change in lower level component will not effect higher level component. In other word, higher level component is being protected from code change chain. Letâ€™s continue on the Employee example: 1234567891011121314class Employee { private val hourReporter = HourReporter() private val payCalculator = PayCalculator() private val employeeSaver = EmployeeSaver() fun getWorkingHours(): Int { return hourReporter.reportHours() } fun calculatePayroll(): Int { return payCalculator.calculatePay() } fun saveEmployee() { employeeSaver.saveEmpployee(this) }} Itâ€™s easy to understand that HourReporter, PayCalculator, EmployeeSaver classes has higher prority then Employee class and we want to avoid code change on them when we need change Employee class. The UML of structure is like: Note that an arrow pointing from class A (Employee) to class B(HourReporter, PayCalculator, EmployeeSaver) means: the source code of class A mentionas the name of class B, but class B mentions nothing about class A. In this XML, Employee depends on these three classes, so those three classes is protected from changes in Employee. Liskov Substitution Principle (LSP) Subclass should be substitutable for their base class A typical example of this principle is square/rectangle problem, letâ€™s briefly recall the problem first by UML: As common sense, a Square should be treated as a special Rectangle which means all operations or parameters for a rectangle object should also effect on a square object. Letâ€™s see the code block below: 1234val rectangle = Rectangle()rectangle.setWidth(2)rectangle.setHeight(5)assert(rectangle.getArea() == 10) This should work fine and the assertion should pass as well, but when we do the same thing to a Square like: 1234val square= Square()square.setSide(2) // how can width and height change at same time???square.setSide(5)assert(rectangle.getArea() == 10) // this will failed and area will be 25 The core problem behind this case is : square has a feature which rectangle don't: need set both width and height always at same time with same value, they can't be changed separately. It may causing a lot problems becuase of this. Interface Segregation Principle (ISP) No client should be forced to implement methods it doesnâ€™t use When we play with abstract interfaces and implementation, a common problem is we find there are extra methods that the implementation not used at all. The easiest way to handle it is just override it and make it empty. But by doing this, there is a risk that it might be touched by other maintainers or even yourself in future since you may not remember. A good fix on this should be separate it into multiple specific interfaces like: In my opinion this is a good way to minimum the risk and separate interface for different class if they not use all of them, but also note that this might causing a lot interfaces to be generated, this is the trade-off. Dependency Inversion Principle (DIP) High-level module shouldnâ€™t depend on low-level, but both should only depend on abstraction, not on concretions This is the most information principle in my opinion and also the hardest one to understand. To understand this, first question is: what is abstraction and why we need it? To answer this, letâ€™s see this example UML: This is the concrete implementation for an application with a simple service. Service is created by ServiceFactory by calling serviceFactory.createService(). It works fine but it has several problems: Application can access everthing inside Service and ServiceFactory, it including something they donâ€™t use (violation of ISP); Both Service and ServiceFactory are dependencies of Application, which means when their code changed, Application will need to re-comple and re-generated everytime (violation of OCP); If we want to add new type of service in future, both Application and ServiceFactory need change the code and still hard to extends (violation of OCP again). So according to what we learned before, here is a better solution for all three points above: As you can see in the solution UML, we make both ServiceFactory and Service as Interface and give them implemnentations for each interface. Note that implementation is hided from Application so it only communicate with interfaces. Why? Look back into all three problems above and you will find all of them is successfully solved by using Interface! Now letâ€™s understand the description of this principle with the example: consider Application as low-level module and ServiceFactory, Service as high-level module, Application should not depends on ServiceFactory and Service because of the violation of ISP, OCP and DIP, and they should all depends on the abstraction, which is Interface in this case. And by using interface, the control flow is successfully inverted from Application -&gt; ServiceFactory to ServiceFactoryImpl -&gt; Application, same for Service as well. This is how Inversion come from.","link":"/2020/05/11/ClearArchitecture1/"},{"title":"Dependency Injection","text":"Dependency Injection is a huge topic in Android development and itâ€™s very important because it can give us a clean, well-designed, easy-to-change environment no matter we develop new features or implement any testing. So here is some thoughts about DI and an useful framework which helps you do all dirty jobs behind the scene. What is Dependency InjectionBefore answering this question, a better question to ask might be: What is dependencyTo answer this question, letâ€™s take a look at this Kotlin code here: 12345678910111213class SimpleFeature constructor( val businessLogicDelegate: BusinessLogicDelegate, val validator: Validator, val listener: Listener) { fun doSomeThing() { val helper = Helper() if (validator.validate()) { businessLogicDelegate.doSomething(helper, listener) } }} This is a very common secenario in real life: I have a class and serveral parameters in its constructor, I need call some methods of those parameters inside this class. At the same time, I also need initialize a helper class inside and use it. In this case, both the parameters and helper class will be considered as the Dependency of SimplyFeature class. Cause this SimpleFeature needs â€œdepend onâ€œ something to finsh its own job. In another word, if any classâ€™s method is called inside a class A, those class will be considered as Aâ€™s dependency. So now I know dependency, what is dependency injection?Letâ€™s look back to this code again: 12345678910111213class SimpleFeature constructor( val businessLogicDelegate: BusinessLogicDelegate, val validator: Validator, val listener: Listener) { fun doSomeThing() { val helper = Helper() if (validator.validate()) { businessLogicDelegate.doSomething(helper, listener) } }} There are two main issues in this code block: Inside the doSomeThing(), we need to initialize a Helper class to help finishing business logic. This can work for sure, but if this helper needs to be a static class, or I need to using a Signleton helper class, here, how can I use it? When writing unit test with Mockito or Mockk, a common way is passing in a â€œmockâ€œ instance and testing if the expected method of this mock is called with correct parameter. But how can we pass in the mock of Helper class if the new operator is called inside? To solve these problems, what can we do? Just simply pass a helper instance in the constructor so it can become the dependency of SimpleFeature as well! The constructor will look like this: 12345678910111213class SimpleFeature constructor( val businessLogicDelegate: BusinessLogicDelegate, val validator: Validator, val listener: Listener, val helper: Helper) { fun doSomeThing() { if (validator.validate()) { businessLogicDelegate.doSomething(helper, listener) } }} Now it looks great! I can pass in any Helper class and also mocking it and do the unit test! Nice! Now we can make a conclusion here: Dependency Injection means:Passing the dependency into the class and use it One thing need to mention here is: passing through classâ€™s constructor is only one of the way to do DI. More details about this concept can be find here. How can I use dependencies injection?To use dependencies injection effectively, let me introduce this super-useful library here: This Dagger 2 library are powerful for android application dependency injection, by using this, all we need to do itâ€™s define each classâ€™s dependency list and the scope to use it. All other stuff will be handled by this library automatically and anonymously. So how to use it? First, we need to have a module class: 12345678910111213141516@Moduleinterface MainModule { @Binds fun providesBusinessLogicDelegate(businessLogicDelegateImpl: BusinessLogicDelegateImpl): BusinessLogicDelegate @Binds fun providesValidator(validatorImpl: ValidatorImpl): Validator @Binds fun providesListener(listenerImpl: ListenerImpl): Listener @Binds fun providesHelper(helperImpl: HelperImpl): Helper} What is this Module use for? Basically this is the place you want dagger helps you to initialize all your dependency. There are two ways to initial dependency in dagger, one is through @Bind annotation and another is @Provides. In here Iâ€™m using @Binds since itâ€™s much simpler if all dependencies has implement an interface. Then we need another class which is called componenet class: 1234567@Component (modules = [MainModule::class])interface MainComponent { fun inject(activity: MainActivity) fun inject(feature: SimpleFeature)} Inside this Component, the inject() method defines â€œwhere those dependencies should be injected toâ€. And following the @Component annotation we can declare all modules that can be included, so we can inject multiple moduleâ€™s dependencies inside one single class that called by inject() method. So far so good! After create these two classes above, we defined What is the dependency and Where should we inject into. Now the final step will be refactor our SimpleFeature class: 12345678910111213class SimpleFeature @Inject constructor( val businessLogicDelegate: BusinessLogicDelegate, val validator: Validator, val listener: Listener, val helper: Helper) { fun doSomeThing() { if (validator.validate()) { businessLogicDelegate.doSomething(helper, listener) } }} Since all parameters inside the constructor are initialized in module class and the injection of this feature class also declared in component class, the only change needed in here is add @Inject annotation before constructor, then dagger knows that all parameters can be find in module and injected by component magically. Done! Now enjoy inject any dependency you want! Now there are still some notes worth mention here: What we using here is just a very brief introduction of Dagger, it has a lot powerful methods and tools that worth to try and play with it. More detail should be found in here One of the very useful feature of Dagger is @Scope annotation. It can be used in complicated structured project to define different scope for different dependencies to access. This part will be added in future as a follow-up of our DI topic. The main purpose of DI is align with one of the basic SOLID principle in softwate development, which is know as Dependency Inversion Rules. This principle states: High-level Module should not depends on low-level module, both should depend on abstractions (interface); Abstractions should not depend on details. Details (concrete implementation) should depends on abstraction. We will cover all these principles one by one in future, they are very important in industrial software development world. Although there are tons of advantages in DI, but it has its limit or disadvantage for sure. For example, when dependency is missing, itâ€™s hard to find out which dependency is missing by checking the build output. So at this time, log is very useful to check.","link":"/2020/02/28/DependencyInjection/"}],"tags":[{"name":"Chinese","slug":"Chinese","link":"/tags/Chinese/"},{"name":"English","slug":"English","link":"/tags/English/"},{"name":"Reading","slug":"Reading","link":"/tags/Reading/"},{"name":"RX","slug":"RX","link":"/tags/RX/"}],"categories":[{"name":"Android","slug":"Android","link":"/categories/Android/"},{"name":"Clean Code","slug":"Clean-Code","link":"/categories/Clean-Code/"},{"name":"Clean Architecture","slug":"Clean-Architecture","link":"/categories/Clean-Architecture/"}]}